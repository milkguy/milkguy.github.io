<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/12/23/%E5%B0%8F%E7%A8%8B%E5%BA%8Fbug/"/>
    <url>/2023/12/23/%E5%B0%8F%E7%A8%8B%E5%BA%8Fbug/</url>
    
    <content type="html"><![CDATA[<h2 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h2><ul><li>管理员系统Logo</li><li>返回按钮</li><li>管理员页面退出登录跳转到用户登录页面</li><li></li></ul><h2 id="小程序功能"><a href="#小程序功能" class="headerlink" title="小程序功能"></a>小程序功能</h2><ul><li>用户名，密码具有记忆功能</li><li>选择所属单位只能看到当前单位的数据</li><li>检验类别为生产检验，显示数据为每焊接500个接头…</li><li>每次填写自动获取上次内容</li><li>操作员侧和非操作员侧</li><li>返回按钮怎么设计</li><li>查看页面里没有图片</li></ul><p>11V02</p><p>01V09</p><p>05V08</p><p>03Mn05   </p><p>小程序报错</p><p>健杰那个报错</p><p>没识别出来灰斑给提示</p><p>基础信息填写页面不做成必填项</p><p>小程序备案流程</p><p>灰斑识别和面积优化：</p><p>圈的准，亮度，角度影响</p><p>图像均衡化</p><ul><li>自我介绍，互相认识</li><li>刘老师讲话</li><li>5月13号到现在，接了一个项目</li><li>项目存在问题，流程优化<ul><li>设计</li><li>专人专干</li><li>契约精神</li><li>制定排期</li><li>代码管理</li><li>定期汇报检查</li></ul></li><li>后续发展规划<ul><li>中铁物总</li><li>发朋友圈</li><li>横向纵向一起推</li><li>大模型</li><li>自研产品</li></ul></li><li>团建</li><li>前期挣得少</li><li></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/12/17/%E9%92%A2%E8%BD%A8%E9%A1%B9%E7%9B%AE%E7%BB%93%E9%A1%B9/"/>
    <url>/2023/12/17/%E9%92%A2%E8%BD%A8%E9%A1%B9%E7%9B%AE%E7%BB%93%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="验收"><a href="#验收" class="headerlink" title="验收"></a>验收</h2><h3 id="验收内容"><a href="#验收内容" class="headerlink" title="验收内容"></a>验收内容</h3><ul><li>小程序</li><li>验收报告</li><li>汇报PPT</li></ul><p>标准灰斑：03Mn08</p><h2 id="算法部分"><a href="#算法部分" class="headerlink" title="算法部分"></a>算法部分</h2><ul><li><p>灰斑识别：原理，准确率</p></li><li><p>面积计算：原理，面积占比怎么保证准确性，原理，准确率</p><ul><li>标准灰斑：误差有多少，测试了多少张照片</li><li>呼市现场拍的测量过的灰斑</li><li>比较多的灰斑</li><li>基地试用情况</li><li><strong>局部面积：找测的比较准确的</strong><ul><li>局部整体对比，体现面积误差，找误差比较小的</li></ul></li></ul></li><li><p>位置显示：原理，准确率</p></li><li><p>灰斑合格判断</p></li><li><p>怎么样去识别灰斑，颜色</p></li><li><p>影响灰斑识别的因素</p><ul><li>光照，现场环境：前后两次识别差距</li><li>拍照角度：做训练，计算误差，</li><li>分析误差原因</li></ul></li><li><p>标准灰斑</p><ul><li>面积比较准的10张图片</li><li>微信小程序识别结果</li><li>计算图片面积截图</li></ul></li><li><p>呼市测量比较准确的图片</p><ul><li>识别结果</li><li>呼市现场记录数据</li></ul></li><li><p>陈工对接图片</p><ul><li>多张，去呼市之前的模型</li><li>最新版模型</li></ul></li><li><p>多个版本迭代的效果</p></li><li><p>识别误差的原因</p><ul><li>不同角度</li><li>不同手机</li><li>不同光照条件</li><li>同一张照片不同识别结果</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/12/10/%E9%92%A2%E8%BD%A8%E9%A1%B9%E7%9B%AE/"/>
    <url>/2023/12/10/%E9%92%A2%E8%BD%A8%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="钢轨项目小程序端问题"><a href="#钢轨项目小程序端问题" class="headerlink" title="钢轨项目小程序端问题"></a>钢轨项目小程序端问题</h1><ul><li><p>必填项加*</p></li><li><p>选填项不加</p></li><li><p>查询页面</p><ul><li>点开查看详情，总面积是0，外面显示正常</li><li>查询的时候如果数据为空的话，清除上次查询数据</li><li>查询这块选择日期有时候会有bug</li><li></li></ul></li></ul><p>A2：3.3</p><p><strong>A1: 3.6， A3：4.8，A2：3.3</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/12/08/%E9%92%A2%E8%BD%A8%E6%99%BA%E8%83%BD%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F%E6%B5%8B%E8%AF%95%E7%89%88%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
    <url>/2023/12/08/%E9%92%A2%E8%BD%A8%E6%99%BA%E8%83%BD%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F%E6%B5%8B%E8%AF%95%E7%89%88%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="钢轨智能识别系统使用手册"><a href="#钢轨智能识别系统使用手册" class="headerlink" title="钢轨智能识别系统使用手册"></a>钢轨智能识别系统使用手册</h2><h3 id="账号管理系统"><a href="#账号管理系统" class="headerlink" title="账号管理系统"></a>账号管理系统</h3><ul><li><p>局部</p></li><li><p>人为做标准</p></li><li><p>和陈总的照片对比</p></li><li><p>首页</p></li></ul><p><img src="/../picture/image-20231201214707560.png" alt="image-20231201214707560"></p><ul><li><p>底部</p><ul><li><p>数据录入</p><ul><li>上面三张轮播图<ul><li>一张铁路的</li><li>一张中铁物总</li><li>一张钢轨</li></ul><p> </p></li><li><img src="/../picture/image-20231202003015568.png" alt="image-20231202003015568"></li></ul></li><li><p>断口</p><ul><li>录入基本信息—&gt;提交</li><li>新增一个端口<ul><li>基本数据显示在上方</li><li>下方<ul><li>编号：自增</li><li>试件编号</li><li>炉罐号</li><li>识别灰斑</li><li>灰斑面积：A1…</li><li>总面积</li><li>是否合格</li></ul></li></ul></li></ul></li><li><p><img src="/../picture/image-20231202005423556.png" alt="image-20231202005423556"></p></li><li><p>试件编号</p></li><li><p>炉罐号</p></li><li><p>灰斑面积：A1…</p></li><li><p>总面积</p></li><li><p>右上角：绿色合格，红色不合格</p></li><li><p>数据查询</p></li><li><p>我的</p></li></ul></li><li></li><li></li><li></li><li><ul><li>数据录入<ul><li><img src="/../picture/image-20231201214846474.png" alt="image-20231201214846474"></li><li><img src="/../picture/image-20231201215014071.png" alt="image-20231201215014071"></li></ul></li><li>数据查询</li><li>我的</li></ul></li><li><p><img src="/../picture/image-20231201214819994.png" alt="image-20231201214819994"></p></li></ul><p><strong>表编号：</strong> 加一个字段</p><p><strong>上传时间：</strong></p><p><strong>试验人员：</strong></p><p><strong>检验结果：</strong>全部合格算合格</p><p><strong>钢厂：</strong></p><p><strong>钢轨材质：</strong></p><p><strong>路局：</strong></p><p>a</p><p><strong>试验编号：</strong></p><p><strong>灰斑位置及尺寸</strong></p><p><strong>总面积</strong></p><p><strong>是否合格 绿色合格，红色不合格</strong></p><p>卡片1</p><p>试件编号</p><p>炉罐号</p><p>灰斑面积 :</p><p>灰斑总面积</p><p>露头灰斑：多选</p><p>是否合格</p><p>识别灰斑（上传图片）</p><p>灰斑图片</p><p>灰斑面积</p><p>灰斑总面积</p><p>灰斑图片</p><p>灰斑面积  A1</p><p>灰斑总面积</p><ul><li><p>单个端口录入页面多张图片逻辑</p></li><li><p>多个断口是否需要显示共有数据卡片</p></li><li><p>通知</p></li><li></li></ul><p>html</p><p>css</p><p>2周 js b站找视频，方应航</p><p>学一周，每天刷三道题，提升写代码能力（一起刷）</p><p>计算机网络，http，一个小时（一起看）</p><p>Linux基础，y总linux基础课，</p><p>Vue框架，b站，项目（全栈之巅）</p><p>Java 毕设 论文</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/11/24/Untitled/"/>
    <url>/2023/11/24/Untitled/</url>
    
    <content type="html"><![CDATA[<h1 id="行测考试准备"><a href="#行测考试准备" class="headerlink" title="行测考试准备"></a>行测考试准备</h1><p><img src="/../picture/image-20231029185549248.png" alt="image-20231029185549248"></p><p><img src="/../picture/image-20231107181345940.png" alt="image-20231107181345940"></p><p><img src="/../picture/image-20231109195449329.png" alt="image-20231109195449329"></p><h2 id="工作任务"><a href="#工作任务" class="headerlink" title="工作任务"></a>工作任务</h2><ul><li><p><img src="/../picture/image-20231111215227995.png" alt="image-20231111215227995"></p></li><li><p>研究内容：包括：选题背景、研究内容、关键技术、论文计划、论文进度及目标(字数不少于：5000)</p></li><li><p>进展情况：包括：报告工作计划、实际进展情况(字数不少于：300)</p></li><li><p>工作成果：目前已完成学位论文工作的内容、取得的阶段性成果和主要创新点（包括所完成的理论和实验研究以及所获得的结论；已发表的与学位论文相关的学术论文等,字数不少于：1500)）</p></li><li><p>计划及进度安排：下一步工作计划及进度安排（内容、时间及工作量估计,字数不少于：150）</p></li><li><p>问题及整改方案：论文后期工作存在的困难、问题及整改方案(字数不少于：200)</p></li><li><p>参考文献</p></li></ul><p>该学生的硕士论文选题新颖，进度合理，与专业研究方向密切相关。论文课题中研究的安全多方计算技术可以实现对区块链数据的隐私保护。该学生长期学习和研究区块链和安全多方计算方向的问题，对该方向具有一定的积累。课题中的研究方法具有较高的使用价值和可行性。该学生已经发表了一篇与课题相关的学术期刊论文，进度合理，同意进行中期答辩。</p><p>随着互联网技术的发展，大量的数据信息涉及生活的方方面面，然而在享受着大数据带给人们便利的同时，数据存储和共享安全问题日益突显[1]。因此，大数据时代下的区块链上数据安全存储和共享成为急需解决的问题。为了解决存储问题，文献[2]提出了将共享数据存储到云服务器上，虽然节省了自身的存储空间，但使用云服务器来存储数据时，数据将不再处于自己的可控范围，数据的安全性和计算的可信度完全取决于云服务器的安全程度，导致许多潜在的安全风险。当用户存储在云服务器上的隐私或数据泄漏时，会造成巨大的损失。例如，2009年谷歌，亚马逊等许多知名IT公司都发生了严重的云数据泄漏事故。因此，云存储中的数据安全问题已经成为用户关注的焦点。</p><p>微软研究院的Kamara等人[3]提出了面向公有云的加密存储框架，数据访问者将共享文件的令牌和凭证发给授权用户，授权用户使用令牌从云中提取共享文件的密文，使用凭证来解密密文，该方案除了能解决数据存储的安全问题之外，还能有效的解决数据的访问控制问题，但是该方案只提供了一个宏观的模型，并没有给出具体的实现方法。文献[4]提出了一种分散式云存储安全架构，该架构采用信息扩展法、分散存储管理等技术实现了数据安全存储管理和传输，但该方案并没有说明如何保证数据的完整性，数据分片技术难以确保数据的隐私性和安全性。文献[5]提出了一种基于VMM的云数据机密性保护方法，该方法使用SSL来保证数据的传输安全，使用Daoli安全虚拟监控系统保护数据存储的安全，该方案能保证多用户环境下数据不会泄露给其他用户，但数据还是有可能泄露给云服务提供商。伴随着密码学技术的发展，基于传统加密技术的数据安全存储得到了广泛的应用，文献[6]提出了一种基于代理重加密的数据分布式安全存储方案，数据所有者使用对称密钥来加密文件，再使用主公钥加密所有内容的加密密钥，只有拥有主公钥的参与者才能解密密文，该方案的主要问题是当存在恶意服务器和其中一个恶意用户勾结就能计算出所有密文数据的解密密钥。在一些数据共享的应用场景中，数据通常需要由多个用户共同维护，Emura 等人 [7]首次提出密文长度固定的属性加密方案，基于门限方法对属性公钥进行联合加密，从而实现密文长度不随属性数量的增加而改变。Herranz [8] 等人采用门限策略，制定适用于单调门限的访问结构。</p><p>2008年，伴随着中本聪题为《Bitcoin: A peer-to-peer electronic cash system》[9]论文的发表，区块链作为在安全领域发展的一项新技术，受到了人们的广泛关注。区块链技术的出现给数据的安全可靠存储提供了解决方案。区块链具有去中心化、不可篡改等特点，能有效保证数据的完整性，同时能通过数据加密来保证数据的机密性，有效的解决了云服务器存储的安全问题。由于区块链系统的去中心化特性，每个节点都存有一个账本数据，随着时间的发展，区块链上的交易数据会越来越多，区块链的数据容量不断增大，同步大量数据会消耗很长时间，并且十分浪费硬盘的存储资源。为了降低区块链的存储占用空间，文献[10]提出了一种分布式的存储方案，文献[11]提出了将数据存储量减小到了区块链负载的一小部分，但该方案无法解决单点故障时恢复通信成本高的问题。文献[12]于2018年提出了改进分布式存储方案，该方案将一个全局秘密和多个局部秘密分层的保密结构与分布式存储区块链相结合，解决了文献[10-11]提出的单点故障问题。</p><p>随着互联网技术的发展，大量的数据信息涉及生活的方方面面，然而在享受着大数据带给人们便利的同时，数据存储和共享安全问题日益突显[1]。因此，大数据时代下的区块链上数据安全存储和共享成为急需解决的问题。为了解决存储问题，文献[2]提出了将共享数据存储到云服务器上，虽然节省了自身的存储空间，但使用云服务器来存储数据时，数据将不再处于自己的可控范围，数据的安全性和计算的可信度完全取决于云服务器的安全程度，导致许多潜在的安全风险。当用户存储在云服务器上的隐私或数据泄漏时，会造成巨大的损失。例如，2009年谷歌，亚马逊等许多知名IT公司都发生了严重的云数据泄漏事故。因此，云存储中的数据安全问题已经成为用户关注的焦点。</p><p>微软研究院的Kamara等人[3]提出了面向公有云的加密存储框架，数据访问者将共享文件的令牌和凭证发给授权用户，授权用户使用令牌从云中提取共享文件的密文，使用凭证来解密密文，该方案除了能解决数据存储的安全问题之外，还能有效的解决数据的访问控制问题，但是该方案只提供了一个宏观的模型，并没有给出具体的实现方法。文献[4]提出了一种分散式云存储安全架构，该架构采用信息扩展法、分散存储管理等技术实现了数据安全存储管理和传输，但该方案并没有说明如何保证数据的完整性，数据分片技术难以确保数据的隐私性和安全性。文献[5]提出了一种基于VMM的云数据机密性保护方法，该方法使用SSL来保证数据的传输安全，使用Daoli安全虚拟监控系统保护数据存储的安全，该方案能保证多用户环境下数据不会泄露给其他用户，但数据还是有可能泄露给云服务提供商。伴随着密码学技术的发展，基于传统加密技术的数据安全存储得到了广泛的应用，文献[6]提出了一种基于代理重加密的数据分布式安全存储方案，数据所有者使用对称密钥来加密文件，再使用主公钥加密所有内容的加密密钥，只有拥有主公钥的参与者才能解密密文，该方案的主要问题是当存在恶意服务器和其中一个恶意用户勾结就能计算出所有密文数据的解密密钥。在一些数据共享的应用场景中，数据通常需要由多个用户共同维护，Emura 等人 [7]首次提出密文长度固定的属性加密方案，基于<img src="/../picture/wps8.png" alt="img">门限方法对属性公钥进行联合加密，从而实现密文长度不随属性数量的增加而改变。Herranz [8] 等人采用<img src="/../picture/wps9.png" alt="img">门限策略，制定适用于单调门限的访问结构。</p><p>2008年，伴随着中本聪题为《Bitcoin: A peer-to-peer electronic cash system》[9]论文的发表，区块链作为在安全领域发展的一项新技术，受到了人们的广泛关注。区块链技术的出现给数据的安全可靠存储提供了解决方案。区块链具有去中心化、不可篡改等特点，能有效保证数据的完整性，同时能通过数据加密来保证数据的机密性，有效的解决了云服务器存储的安全问题。由于区块链系统的去中心化特性，每个节点都存有一个账本数据，随着时间的发展，区块链上的交易数据会越来越多，区块链的数据容量不断增大，同步大量数据会消耗很长时间，并且十分浪费硬盘的存储资源。为了降低区块链的存储占用空间，文献[10]提出了一种分布式的存储方案，文献[11]提出了将数据存储量减小到了区块链负载的一小部分，但该方案无法解决单点故障时恢复通信成本高的问题。文献[12]于2018年提出了改进分布式存储方案，该方案将一个全局秘密和多个局部秘密分层的保密结构与分布式存储区块链相结合，解决了文献[10-11]提出的单点故障问题。  </p><p>为了解决区块链上数据存储容量的问题，基于区块链和云服务器相结合的链上-链下存储方案被广泛应用，Gaetani等人[13]设计了基于区块链的云计算数据库系统，使用区块链确保数据完整性，提高性能并增强稳定性。Liang等人[14]提出了区块链分布式存储和云数据可追溯方案。吕等人[15]提出了基于链上-链下相结合的日志安全存储与检索方案，该模型结合区块链与分布式存储技术，实现了去中心化、去信任、数据难以篡改的安全设备日志存储，并对外向安全管理员提供密文检索接口，同时可以利用区块链实现数据的完整性校验，但是检索效率比较低。针对多用户维护的共享数据，Zheng等人[16]提出了一种基于区块链的可信数据共享方案，该方案解决了多用户共同维护的数据安全性存储和共享问题，用户私钥是由一个可信第三方机构来生成和管理，实际上，并不能保证第三方机构总是可信的，一旦第三方机构被俘获，整个系统的用户私钥都会被泄露，造成很大的安全隐患；而且，在解密明文时使用云服务器来计算，云服务器会解密加密之后的密文，这样会将解密之后的明文泄露给云服务器，造成数据泄露。</p><p>针对上述问题，本文提出了一种基于门限Paillier的区块链数据安全共享方案，实现了无可信第三方的安全存储和数据共享。用户使用Paillier加密算法将数据加密后上传到云服务器中，并将密文哈希值存储到区块链上，保证了数据的完整性。在解密阶段，设计了一种基于<img src="/../picture/wps10.png" alt="img">门限Paillier解密方案，至少有<img src="/../picture/wps11.png" alt="img">个用户就可以解密数据。本文贡献如下：</p><p>为了解决区块链上数据存储容量的问题，基于</p><p>随着互联网技术的发展，大量的数据信息涉及生活的方方面面，然而在享受着大数据带给人们便利的同时，数据存储和共享安全问题日益突显[1]。因此，大数据时代下的区块链上数据安全存储和共享成为急需解决的问题。为了解决存储问题，文献[2]提出了将共享数据存储到云服务器上，虽然节省了自身的存储空间，但使用云服务器来存储数据时，数据将不再处于自己的可控范围，数据的安全性和计算的可信度完全取决于云服务器的安全程度，导致许多潜在的安全风险。当用户存储在云服务器上的隐私或数据泄漏时，会造成巨大的损失。例如，2009年谷歌，亚马逊等许多知名IT公司都发生了严重的云数据泄漏事故。因此，云存储中的数据安全问题已经成为用户关注的焦点。</p><p>微软研究院的Kamara等人[3]提出了面向公有云的加密存储框架，数据访问者将共享文件的令牌和凭证发给授权用户，授权用户使用令牌从云中提取共享文件的密文，使用凭证来解密密文，该方案除了能解决数据存储的安全问题之外，还能有效的解决数据的访问控制问题，但是该方案只提供了一个宏观的模型，并没有给出具体的实现方法。文献[4]提出了一种分散式云存储安全架构，该架构采用信息扩展法、分散存储管理等技术实现了数据安全存储管理和传输，但该方案并没有说明如何保证数据的完整性，数据分片技术难以确保数据的隐私性和安全性。文献[5]提出了一种基于VMM的云数据机密性保护方法，该方法使用SSL来保证数据的传输安全，使用Daoli安全虚拟监控系统保护数据存储的安全，该方案能保证多用户环境下数据不会泄露给其他用户，但数据还是有可能泄露给云服务提供商。伴随着密码学技术的发展，基于传统加密技术的数据安全存储得到了广泛的应用，文献[6]提出了一种基于代理重加密的数据分布式安全存储方案，数据所有者使用对称密钥来加密文件，再使用主公钥加密所有内容的加密密钥，只有拥有主公钥的参与者才能解密密文，该方案的主要问题是当存在恶意服务器和其中一个恶意用户勾结就能计算出所有密文数据的解密密钥。在一些数据共享的应用场景中，数据通常需要由多个用户共同维护，Emura 等人 [7]首次提出密文长度固定的属性加密方案，基于门限方法对属性公钥进行联合加密，从而实现密文长度不随属性数量的增加而改变。Herranz [8] 等人采用门限策略，制定适用于单调门限的访问结构。</p><p>2008年，伴随着中本聪题为《Bitcoin: A peer-to-peer electronic cash system》[9]论文的发表，区块链作为在安全领域发展的一项新技术，受到了人们的广泛关注。区块链技术的出现给数据的安全可靠存储提供了解决方案。区块链具有去中心化、不可篡改等特点，能有效保证数据的完整性，同时能通过数据加密来保证数据的机密性，有效的解决了云服务器存储的安全问题。由于区块链系统的去中心化特性，每个节点都存有一个账本数据，随着时间的发展，区块链上的交易数据会越来越多，区块链的数据容量不断增大，同步大量数据会消耗很长时间，并且十分浪费硬盘的存储资源。为了降低区块链的存储占用空间，文献[10]提出了一种分布式的存储方案，文献[11]提出了将数据存储量减小到了区块链负载的一小部分，但该方案无法解决单点故障时恢复通信成本高的问题。文献[12]于2018年提出了改进分布式存储方案，该方案将一个全局秘密和多个局部秘密分层的保密结构与分布式存储区块链相结合，解决了文献[10-11]提出的单点故障问题。</p><p>为了解决区块链上数据存储容量的问题，基于区块链和云服务器相结合的链上-链下存储方案被广泛应用，Gaetani等人[13]设计了基于区块链的云计算数据库系统，使用区块链确保数据完整性，提高性能并增强稳定性。Liang等人[14]提出了区块链分布式存储和云数据可追溯方案。吕等人[15]提出了基于链上-链下相结合的日志安全存储与检索方案，该模型结合区块链与分布式存储技术，实现了去中心化、去信任、数据难以篡改的安全设备日志存储，并对外向安全管理员提供密文检索接口，同时可以利用区块链实现数据的完整性校验，但是检索效率比较低。针对多用户维护的共享数据，Zheng等人[16]提出了一种基于区块链的可信数据共享方案，该方案解决了多用户共同维护的数据安全性存储和共享问题，用户私钥是由一个可信第三方机构来生成和管理，实际上，并不能保证第三方机构总是可信的，一旦第三方机构被俘获，整个系统的用户私钥都会被泄露，造成很大的安全隐患；而且，在解密明文时使用云服务器来计算，云服务器会解密加密之后的密文，这样会将解密之后的明文泄露给云服务器，造成数据泄露。</p><p>安全两方计算协议于1982年被图灵奖获得者姚期智先生提出[8]，安全多方计算从此诞生。后来国内外学者相继提出安全多方计算协议，经过多年发展，安全多方计算已经运用到各个领域。安全多方计算是密码学的一个关键领域，被认为是各种现实隐私保护问题的实际解决方案，特别是那些只需要共享秘密且各方之间没有太多交互的问题，例如分布式投票、私人竞标和拍卖、共享签名或解密功能以及私人信息检索[9]等。</p><p>安全多方计算参与者分为诚实参与者、半诚实参与者、恶意参与者，在整个协议执行过程中，诚实参与者完全遵照协议，不存在提供虚假数据、泄漏、窃听和中止协议的行为；半诚实参与者虽然会按照要求执行协议，不存在提供虚假数据、中止协议等行为，但是他们会保留协议执行过程中的相关数据，从而推断其他参与人的信息；恶意参与者不遵照协议，他们可能存在提供虚假数据、泄漏他们收集到的所有信息，窃听甚至中止协议等行为。到目前为止，研究最多的是在半诚实模型下的安全多方计算协议[10]，这是因为安全多方计算协议的参与者大多数是半诚实的，而且研究半诚实模型下的安全多方计算协议是研究恶意模型下协议的基础，有了半诚实模型下的安全协议，才可以针对协议中可能发现的恶意行为进行改进从而成为恶意模型下安全的协议[11]。安全多方计算作为一种保护隐私的密码学技术，允许多个参与者在不共享私密数据的情况下进行计算。通过使用安全多方计算，区块链系统可以实现在不泄露用户隐私的前提下进行智能合约的执行、数据验证等操作，本课题旨在研究基于安全多方计算的区块链数据隐私保护方案，通过结合安全多方技术，为区块链上数据安全存储提供新的解决方案。</p><ul><li><p>百万富翁问题</p></li><li><p>安全多方计算</p></li><li><p>模拟范例</p></li><li><p>秘密共享</p></li><li><p>不经意传输</p></li><li><p>混淆电路</p></li><li><p>不经意传输方案</p></li><li><p>研究背景修改</p></li><li><p>研究内容修改</p></li><li><p>第一部分研究内容修改</p></li><li><p>第四页自上而下分为五层</p></li><li><p>第五页以业务需求为基础</p></li><li><p>第五页可以广泛应用于多种应用场景</p></li></ul><p>数据按单位分</p><ul><li><p>管理员：</p><ul><li>选择路局</li><li>全部权限</li></ul></li><li></li><li><p>管理账号：整个权限一个账号</p></li><li><p>散客登录取消</p></li><li><p>给几个账号，查看全部权限</p></li><li></li><li></li><li><p>登录实名认证</p></li><li><p>登录给邀请码还是怎么给分配还是所有人都能注册</p></li><li><p>散客看的内容</p></li><li><p>多张照片如果结果不一样怎么选，如果一张照片内容不全，是否需要编辑</p></li><li><p>操作员测和非操作员测</p></li><li><p>生成pdf发邮件</p></li><li><p>一条数据还是多条</p></li><li><p>生成pdf</p></li></ul><p>论文针对</p><p>论文针对基于安全多方计算的区块链数据隐私保护方案进行研究与实现，选题具有一定的理论意义和实用价值。</p><p>论文完成工作如下：对研究目标及内容深入展开，已经实现基于门限Paillier的区块链数据安全存储与共享协议，并提出了基于安全多方计算的区块链用户身份匿名保护协议，在无第三方机构的情况下实现了数据的安全存储与共享，通过链上链下相结合的存储方案，既保证了数据的完整性，又解决了区块链的存储限制问题。</p><p>论文后续将要完成以下工作：继续深化实验与验证，确保提出的协议和方案在实际应用中的可行性与有效性。同时，在方案的基础上实现数据隐私保护系统，优化系统模块并进行功能测试。</p><p>论文进展正常，通过阶段报告。</p><p>论文基于Kubernetes调度策略和容器云调度平台进行研究与实现，选题方向新颖且应用性较强，具有一定的理论意义和实用价值。</p><p>论文完成工作如下：分析当前主流研究中对Kubernetes调度策略的改进方法，对特定使用场景提出调度策略的优化方案，编写基于综合指标决策方法代码，并使用集群节点资源实时数据进行测试，通过这一技术手段，扩展了Kubernetes调度的使用场景。</p><p>论文后期将要完成以下工作：继续优化调度策略的实现方法以及验证，确保提出的方案具备可行性和有效性，同时，完成系统方案的设计与实现，确保系统设计的合理性，并对系统功能模块做完整性功能测试。</p><p>论文进展正常，通过阶段报告。</p><ul><li>修改中期报告</li><li>给刘老师写审稿意见</li><li>英语六级</li></ul><p>帮我写一个工作室的宣传介绍，工作室名称：致创未来工作室，工作室主营业务：网站、小程序、app开发，人工智能、深度深度学习、大模型、区块链、大数据等相关项目开发，</p><p><strong>致创未来工作室</strong>是一个致力于创新和科技领域的专业团队。我们专注于网站、小程序、App业务开发，以及人工智能、深度学习、大模型、区块链、大数据、信息安全等新领域的项目研发。作为一支高素质的团队，我们以卓越的科研能力和丰富的开发经验脱颖而出。</p><p><strong>团队介绍：</strong> 团队成员来自清华大学、北京航天航空大学、北京邮电大学、西安电子科技大学的硕士博士研究生和百度、阿里巴巴、腾讯、字节跳动、美团等一线互联网的资深软件开发工程师，团队成员有深厚的学术背景和丰富的实战经验。</p><p><strong>业务范围：</strong> <strong>致创未来工作室</strong>主营业务涵盖网站、小程序、App开发，同时我们擅长处理人工智能、深度学习、大模型、区块链、大数据、信息安全等领域的项目。</p><p><strong>成功案例：</strong> 团队成员已经成功完成多项国家级重点课题的研发。此外，我们在与政府、中铁物总、大唐电信、国家电网、中国移动、三甲医院等多家单位合作的项目中也取得了卓越成果。</p><p><strong>联系方式：</strong><a href="mailto:&#x7a;&#x63;&#119;&#108;&#x5f;&#115;&#x74;&#117;&#100;&#x69;&#x6f;&#64;&#x31;&#x36;&#x33;&#46;&#99;&#111;&#109;">&#x7a;&#x63;&#119;&#108;&#x5f;&#115;&#x74;&#117;&#100;&#x69;&#x6f;&#64;&#x31;&#x36;&#x33;&#46;&#99;&#111;&#109;</a></p><p>选择致创未来工作室，您将与一支充满激情和创造力的团队紧密合作，共同开创未来的辉煌。我们期待着与您共同探索科技的边界，为您的项目注入新的活力和创新。</p><p>修改意见</p><ul><li>写一段总的描述，画一个模型图，表示总的研究内容和每一部分之间的关系</li><li>去掉所有的修饰动词</li><li>3.1 图里的修饰词修改一下</li><li>3.2 研究内容题目改一下</li></ul><p>本文，本节去掉</p><ul><li>按条件查找</li><li>生成pdf</li><li>权限</li><li>先选表格，再选数据</li><li>修改区域，可以增加，可以删除</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/10/26/%E8%A1%8C%E6%B5%8B%E5%A4%87%E8%80%83/"/>
    <url>/2023/10/26/%E8%A1%8C%E6%B5%8B%E5%A4%87%E8%80%83/</url>
    
    <content type="html"><![CDATA[<h2 id="言语"><a href="#言语" class="headerlink" title="言语"></a>言语</h2><p><img src="/../picture/image-20231018093140502.png" alt="image-20231018093140502"></p><p><img src="/../picture/image-20231018163842169.png" alt="image-20231018163842169"></p><ul><li>数据采集与整理：首要任务是采集社交媒体平台上由这些模型生成的文本和图像数据。这包括获取数据样本，建立数据集，以便进行深入的分析。</li><li>检测工具开发：虽然研究目标侧重于分析，但我们需要开发一定的检测工具来获取可分析的数据。这包括设计和实施自然语言处理和计算机视觉技术，以辅助数据的获取。这些工具将用于采集、分类和组织数据，使其可供进一步研究。</li><li>内容特点分析：对模型生成的内容进行全面的特点分析，包括文本和图像的语义、情感、风格和真实性。这有助于我们理解这些内容的本质，以及它们如何影响社交媒体用户。</li><li>滥用情况调查：通过深入分析数据，我们将识别和量化这些模型在社交媒体上的滥用情况。这将包括虚假信息、深度伪造内容、恶意操作等的检测与分类。我们将关注这些滥用情况的趋势、频率和影响。</li><li>舆论误导分析：我们将研究模型生成的内容如何与社交媒体用户的观点和行为互动，以评估它们是否对舆论产生误导作用。这将涵盖虚假信息扩散、社交媒体动态和用户行为的分析。</li><li>发布者信息和地域关联分析：我们将探索生成内容的发布者信息和地域关联，以揭示是否存在特定地区或组织与这些内容的关联性。这有助于我们了解滥用背后的可能动机和来源。</li><li>安全策略建议：最后，通过深入分析的结果，我们将提出针对性的安全策略建议。这包括改进社交平台的内容过滤和审核机制，提高用户教育和安全意识，以及采取措施减少虚假信息传播的可能性。</li></ul><p>10 13</p><p>11 14</p><p>12 15</p><p>13 16</p><p>14 17</p><p>15 18</p><p>16 19</p><p><strong>设置初始账号，admin，123456</strong></p><p><strong>登录进来以后，点断口，跳进来的界面是我的，不是录入</strong></p><p><strong>识别完以后，如果没识别出来，给前端提示信息</strong></p><p><strong>重新上传，清除上一张图片的信息</strong></p><p><strong>加虚框</strong></p><p>面积优化</p><p>速度提升</p><p>1231009-7</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/10/15/%E9%97%AE%E9%A2%98/"/>
    <url>/2023/10/15/%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<ul><li><p>第一页内容不完整</p></li><li><p>资格审查索引表中缺页码信息</p></li><li><p>评分索引表中缺页码信息</p></li><li><p>投标一览表中信息没填</p></li><li><p>投标保证金汇款凭证复印件</p></li><li><p>发票邮寄联系人信息没填</p></li><li><p>授权委托书信息不完整</p></li><li><p>商务条款偏离表内容不完整，需要添加页码</p></li><li><p>上午偏离表中内容与招标文件内容一致，可以额外扩展描述</p></li><li><p>技术条款偏离表需要补充</p></li><li><p>第26页声明函中缺法定代表人信息</p></li><li><p>第27页承诺函中缺法定代表人信息</p></li><li><p>纳税记录到7月</p></li><li><p>第219页声明函中缺法定代表人信息</p></li><li><p>第228页项目分项报价表没有</p></li><li><p>相关业务最好写8个，以防专家有的不认可</p></li><li></li><li><p>第66页营业执照换图</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/10/10/%E5%8D%81%E5%9B%9B%E4%BA%94/"/>
    <url>/2023/10/10/%E5%8D%81%E5%9B%9B%E4%BA%94/</url>
    
    <content type="html"><![CDATA[<p>人工智能技术与OA（Office Automation）办公系统相结合，正在市场中迅速发展，为企业提供更高效、智能和协作性的办公环境。以下是人工智能技术与OA办公系统结合的市场发展趋势以及主要技术攻关内容：</p><p><strong>市场发展趋势：</strong></p><ol><li><p><strong>自动化和智能化办公环境</strong>：企业追求自动化的工作流程，AI技术可以自动执行任务，优化资源分配，减少手动劳动，提高效率。</p></li><li><p><strong>数据驱动的决策</strong>：AI可以分析大数据，提供决策支持，帮助管理者更准确地了解企业绩效，预测趋势，制定战略。</p></li><li><p><strong>智能客户服务</strong>：AI驱动的虚拟助手和聊天机器人可以改善客户服务，回答常见问题，处理疑难问题，提供实时支持。</p></li><li><p><strong>个性化体验</strong>：OA办公系统可以通过AI技术提供个性化的用户体验，根据员工的工作习惯和需求进行定制化，提高用户满意度。</p></li><li><p><strong>安全性和隐私保护</strong>：AI可以用于身份验证、异常检测和威胁监测，提高OA系统的安全性，保护敏感数据。</p></li></ol><p><strong>主要技术攻关内容：</strong></p><ol><li><p><strong>自然语言处理（NLP）</strong>：开发NLP模型，以识别和理解用户的语言输入，支持智能搜索、语音识别和自动文档分类。</p></li><li><p><strong>数据分析和机器学习</strong>：构建数据分析和机器学习模型，以从海量数据中提取有用信息，支持决策制定和趋势分析。</p></li><li><p><strong>智能搜索和知识管理</strong>：设计智能搜索引擎，使员工能够更轻松地找到和共享文件、文档和知识库中的信息。</p></li><li><p><strong>虚拟助手和聊天机器人</strong>：开发虚拟助手和聊天机器人，用于自动回答问题、提供指导、执行任务和处理客户服务请求。</p></li><li><p><strong>自动化工作流程</strong>：实施自动化工作流程，以将任务自动分配给适当的人员，降低错误率并提高工作效率。</p></li><li><p><strong>数据隐私和安全技术</strong>：加强数据加密、身份验证和访问控制，确保OA系统的数据得到保护，并遵守隐私法规。</p></li><li><p><strong>集成和互操作性</strong>：确保AI技术与现有OA系统和其他企业应用程序无缝集成，以提高整体协作和工作效率。</p></li><li><p><strong>用户体验设计</strong>：设计直观的用户界面，使员工能够轻松使用AI功能，提高OA系统的可用性。</p></li></ol><p>随着时间的推移，AI技术与OA办公系统的结合将继续演进，为企业提供更多的智能功能，推动办公环境的现代化和效率提升。</p><p>智能OA（Office Automation）办公系统是一种多功能、智能化的工作平台，旨在提升办公效率、简化管理流程，以及改善员工的工作体验。以下是一些关于智能OA办公系统应用的描述：</p><ol><li><p><strong>办公流程自动化</strong>：智能OA办公系统通过自动化工作流程，可将繁琐的、重复性的任务自动分配给合适的人员或系统执行。这包括自动化审批流程、任务分发、文件归档等。</p></li><li><p><strong>协作与沟通</strong>：该系统提供了一种高效的协作环境，员工可以轻松地共享文档、日历、任务列表等。实时消息传递和在线会议功能使团队成员可以随时随地协作，不受地理位置限制。</p></li><li><p><strong>文件和知识管理</strong>：智能OA办公系统提供了强大的文件管理和知识库功能。员工可以上传、存储、共享和搜索文件，以及创建知识库，以便团队成员可以共享知识和信息。</p></li><li><p><strong>任务和项目管理</strong>：员工可以使用系统追踪任务、项目和工作进展。项目计划、任务分配、进度监控等功能有助于团队保持组织性和高效率。</p></li><li><p><strong>数据分析与报告</strong>：智能OA办公系统可以从各种数据源中提取数据，并生成可视化的报告和分析结果，以帮助管理层做出更明智的决策。</p></li><li><p><strong>安全与权限控制</strong>：系统具备严格的安全性功能，包括身份验证、数据加密、访问控制和安全审计。这确保了敏感信息的保护和合规性。</p></li><li><p><strong>智能搜索和推荐</strong>：通过整合搜索技术和人工智能，员工可以迅速找到所需信息，并获得系统生成的相关建议，从而提高了信息检索效率。</p></li><li><p><strong>移动办公</strong>：系统通常提供移动应用程序，员工可以使用手机或平板电脑随时随地访问办公系统，以便更加灵活地工作。</p></li><li><p><strong>个性化用户体验</strong>：智能OA办公系统会根据用户的角色和需求提供个性化设置和建议，以改善用户体验并提高满意度。</p></li><li><p><strong>节省时间和资源</strong>：通过自动化、智能化和高效的协作工具，智能OA办公系统帮助企业节省时间、精力和资源，从而提高了整体生产力。</p></li></ol><p>综上所述，智能OA办公系统不仅提供了现代办公所需的基本功能，还通过整合智能技术，为企业提供更高效、便捷和智能的工作环境，从而在竞争激烈的市场中脱颖而出。</p><p>智能OA（Office Automation）办公系统的开发涉及多个关键技术领域，需要克服一系列技术挑战，以实现更高效、更智能的办公环境。以下是一些智能OA办公系统的技术攻关重点：</p><ol><li><p><strong>自动化工作流程</strong>：</p><ul><li><strong>工作流引擎</strong>：开发强大的工作流引擎，能够自动化和协调各种办公任务，包括审批流程、文档管理和通知。</li></ul></li><li><p><strong>数据管理和分析</strong>：</p><ul><li><strong>大数据处理</strong>：处理大量结构化和非结构化数据，包括文档、电子邮件、图片和音频，以提取有用的信息。</li><li><strong>数据挖掘和机器学习</strong>：应用机器学习算法进行数据分析，以发现趋势、模式和异常，支持决策制定。</li></ul></li><li><p><strong>自然语言处理（NLP）</strong>：</p><ul><li><strong>文本分析</strong>：开发NLP技术，以识别文本中的关键信息、主题和情感，以支持智能搜索和分类。</li><li><strong>语音识别</strong>：实现准确的语音识别，以支持语音交互和自动化任务。</li></ul></li><li><p><strong>智能搜索和知识管理</strong>：</p><ul><li><strong>全文搜索引擎</strong>：设计高效的全文搜索引擎，以快速检索文档和信息。</li><li><strong>知识图谱</strong>：建立知识图谱，以捕捉和共享组织内部的知识，促进知识管理和协作。</li></ul></li><li><p><strong>虚拟助手和聊天机器人</strong>：</p><ul><li><strong>自然对话处理</strong>：开发自然、流畅的对话模型，以实现虚拟助手和聊天机器人的自然交互。</li><li><strong>任务执行</strong>：使虚拟助手能够执行任务，如日程安排、文件共享和通知发送。</li></ul></li><li><p><strong>安全性和隐私保护</strong>：</p><ul><li><strong>身份验证技术</strong>：采用生物识别、多因素身份验证等高级技术，确保只有授权人员可以访问系统。</li><li><strong>数据加密和安全审计</strong>：保护数据的隐私和完整性，记录和审计系统访问和操作。</li></ul></li><li><p><strong>移动应用和云计算</strong>：</p><ul><li><strong>移动办公支持</strong>：开发跨平台的移动应用程序，使员工可以随时随地访问办公系统。</li><li><strong>云计算架构</strong>：采用云计算架构，以实现可扩展性、弹性和高可用性。</li></ul></li><li><p><strong>用户体验设计</strong>：</p><ul><li><strong>人机界面</strong>：设计直观、易用的用户界面，以提高员工的采用率和满意度。</li><li><strong>个性化建议</strong>：提供个性化的建议和设置，根据员工的工作习惯和需求进行定制化。</li></ul></li></ol><p>综合来看，智能OA办公系统的技术攻关需要跨足多个领域，包括自动化、数据分析、NLP、虚拟助手和安全性等。随着技术的不断进步和创新，这些系统将继续演化，为企业提供更智能、高效的办公环境。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/09/28/%E7%A7%8B%E6%8B%9B%E6%9D%90%E6%96%99/"/>
    <url>/2023/09/28/%E7%A7%8B%E6%8B%9B%E6%9D%90%E6%96%99/</url>
    
    <content type="html"><![CDATA[<p>电子：</p><ul><li>简历电子版（已准备）</li><li><strong>毕业证，学位证</strong>，学历认证报告，电子版（未准备）</li><li>应聘人员信息登记表（电子版，纸质版手写签字）</li><li>个人综述（500字），word文档</li><li>性格测试（已完成）</li><li>专业笔试（一会做）</li><li>个人出境记录（不提供）</li></ul><p>纸质：</p><ul><li>大学以上的毕业证、学位证复印件</li><li>家庭所有成员户口本复印件</li><li>户口所在地开设的无犯罪证明</li><li>本人身份证复印件2份</li><li>本人护照复印件1份</li></ul><p>大模型在军用领域的应用</p><p>1、代码代码自动生成：(1)武器装备的基础代码生成可以通过大模型来实现，提高软件的开发效率，加速武器装备研发进程。(2)生成控制代码，对武器装备生产过程实现精准控制，降低人力成本，提升武器装备的研发效率。2、根据描述自动生成作战仿真程序、文字、视频、模型，速构建作战模拟仿真场景，提升作战仿真能力。</p><p>3、进行情报分析：通过大模型的语言分析能力，提高情报信息的融合处理速度，提高未来在陆、海、空、天、电等多域作战空间所产生的信息洪流的分析能力，辅助作战指挥员针对不同的作战环境快速做出决策。</p><p>4、助力渗透攻击：大模型可以生成海量信息，可以高效生成海量假信息，影响他国民众的价值取向，引导舆论情绪。</p><p>尊敬的各位领导，面试官，大家好：</p><p>我是来自北京邮电大学网络空间安全学院的贾利凯，我的研究方向是区块链技术，我的技术栈是Java后端开发，读研期间，我主要跟着导师做实验室的横向和纵向课题，参与国家重点研发计划等多项课题，我本科毕业于内蒙古科技大学软件工程专业，本科期间，多次参加计算机类科技创新比赛，我的参赛情况在简历的后一页。学习成绩我本科专业第一，获得两次国家奖学金，获得省级三好学生和省级优秀毕业生，研究生期间获得一次北京邮电大学一等奖学金，一次二等奖学金。今年5月来咱们所里网络与信息安全总体部实习</p><ul><li>dataset数据集</li><li>dataload 加载数据</li><li>transformer图像处理<ul><li>compose：合并</li><li>totensor：格式转换</li><li>Normalize：归一化处理</li><li>Resize：修改尺寸</li></ul></li><li>transvision：数据集处理</li><li>卷积</li><li>池化</li><li>非线性激活</li><li>线性层</li><li>损失函数和反向传播</li><li>模型评估和预测</li></ul><p>[1] 兰祥, 郭瑞, 王俊茗. 电子投票系统中基于区块链的无证书环签密方案[J&#x2F;OL]. 计算机工程与应用: 1-16[2023-09-20]. <a href="http://kns.cnki.net/kcms/detail/11.2127.">http: &#x2F;&#x2F;kns.cnki.net&#x2F;kcms&#x2F;detail&#x2F; 11. 2127.</a> TP. 20230814. 2014. 024. html.</p><p>[2] 刘红, 张靖宇, 雷梦婷等. 基于区块链的公平和可验证电子投票智能合约[J]. 应用科学学报, 2023, 41(04): 541-562.</p><p>[3] 沈华, 李博轮. 一种基于CP-ABE和区块链的时间锁加密电子投票方案[J&#x2F;OL]. 计算机应用研究: 1-9[2023-09-20]. <a href="https://doi.org/10.19734/j.issn">https://doi.org/10.19734/j.issn</a>. 1001-3695. 2023. 02. 0108.</p><p>[4] Yao A C. Theory and application of trapdoor functions[C]&#x2F;&#x2F;23rd Annual Symposium on Foundations of Computer Science (SFCS 1982). IEEE, 1982: 80-91.</p><p>[5] Murugeshwari B, Selvaraj D, Sudharson K, et al. Data mining with privacy protection using precise elliptical curve cryptography[J]. Intelligent Automation &amp; Soft Computing, 2023, 35(1): 839-851.</p><p>[6] Issa W, Moustafa N, Turnbull B, et al. Blockchain-based federated learning for securing internet of things: A comprehensive survey[J]. ACM Computing Surveys, 2023, 55(9): 1-43. </p><p>[7] Juels A, Catalano D, Jakobsson M. Coercion-resistant electronic elections [J]. Towards Trustworthy Elections, 2010: 37-63.</p><p>[8] 付伟伟, 王晓京, 彭行一, 等. 基于随机矩阵的一种新型电子投票方案[J]. 计算机应 用, 2019, 39(S2): 280-283. </p><p>[9] 邵清, 洪皓洁, 李斌. 基于Elgamal强盲签名的区块链电子投票方案研究[J]. 小型微型计算机系统, 2021, 42(11): 2400-2406. </p><p>[10] Choi S, Kang J, Chung K S. Design of Blockchain based e-Voting System for Vote  Requirements[C]. Journal of Physics: Conference Series, 2021, 1944: 012002. </p><p>[11] 王旭升. 基于区块链的安全多方计算研究与分析[D]. 兰州理工大学, 2022.DOI: 10. 27206&#x2F;d. cnki. ggsgu. 2021. 000334.</p><p>[12] 李亚伟. 集合运算的安全多方计算及应用[D].长安大学, 2023. DOI: 10. 26976&#x2F;d. cnki. gchau. 2022. 001357.</p><p>[13] Hu XX, Wang BC, Hu YP. Threshold NTRU Public-Key Cryptosystem[J]. Application Research of Computers, 2005(11):103-105.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/09/19/%E7%A7%8B%E6%8B%9BMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%AB%E8%82%A1%E6%96%87/"/>
    <url>/2023/09/19/%E7%A7%8B%E6%8B%9BMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%AB%E8%82%A1%E6%96%87/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h1><h3 id="执行一条MySQL，中间发生了什么"><a href="#执行一条MySQL，中间发生了什么" class="headerlink" title="执行一条MySQL，中间发生了什么"></a>执行一条MySQL，中间发生了什么</h3><p><img src="/../picture/image-20230904133652420.png" alt="image-20230904133652420"></p><h4 id="MySQL架构分层"><a href="#MySQL架构分层" class="headerlink" title="MySQL架构分层"></a>MySQL架构分层</h4><ul><li>Server层：负责建立、连接、分析和执行SQL，绝大部分SQL功能都在这部分，包括：连接器，查询缓存，解析器，预处理器，优化器，执行器等，所有的内置函数和跨存储引擎的功能都在这部分实现</li><li>存储引擎层：负责数据的存储和提取，InnorDB为默认的存储引擎，索引的数据结构就是在这部分实现的</li></ul><h4 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h4><ul><li>show processlist：查询连接数</li><li>show variables like ‘wait_timeout’：设置空闲连接时长</li><li>show variables like ‘max_connections’ 查询最大连接数</li></ul><h4 id="一条MySQL的执行流程"><a href="#一条MySQL的执行流程" class="headerlink" title="一条MySQL的执行流程"></a>一条MySQL的执行流程</h4><ul><li>连接器：<ul><li>先与客户端进行三次握手连接</li><li>验证账户密码，如果验证正确则会获取到用户的操作权限，后面的数据访问都是依照这个权限来的</li></ul></li><li>查询缓存：<ul><li>判断SQL语句的执行类型，如果是select语句，就会存查询缓存里查找一下是否有这条数据</li><li>MySQL8.0之后就把查询缓存给取消掉了，因为如果表中的数据有更新的话，查询缓存就会自动被清空</li></ul></li><li>解析SQL：<ul><li>词法分析：识别关键字</li><li>语法分析：判断语法是否正确，构建出SQL语法树</li></ul></li><li>执行SQL：<ul><li>预处理阶段：<ul><li>检查SQL查询语句中的表或者字段是否存在</li><li>将select语句中的*扩展为所有列</li></ul></li><li>优化阶段：<ul><li>将SQL查询语句的执行计划确定下来，如果有多个索引的话，优化器会考虑查询成本</li><li>使用explain语句可以查看使用了哪个索引</li></ul></li><li>执行阶段：根据执行计划执行SQL查询语句，从存储引擎读取记录，返回给客户端<ul><li>主键索引查询</li><li>全表扫描查询</li><li>索引下推</li></ul></li></ul></li></ul><h1 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h1><h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><p><img src="/../picture/image-20230904142715715.png" alt="image-20230904142715715"></p><h3 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h3><ul><li>索引是帮助存储引擎快速获取数据的一种数据结构，索引是数据的目录，索引是以空间换时间的设计思想</li></ul><h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><ul><li>按照数据：B+树索引、Hash索引、全文索引</li><li>物理存储：聚簇索引（主键索引）、二级索引（辅助索引）</li><li>字段特性：主键索引、唯一索引、普遍索引、前缀索引</li><li>字段个数：单列索引、联合索引</li></ul><h4 id="按数据结构分"><a href="#按数据结构分" class="headerlink" title="按数据结构分"></a>按数据结构分</h4><p><img src="/../picture/image-20230905094054068.png" alt="image-20230905094054068"></p><h4 id="创建表的时候InnonDB选择的索引列"><a href="#创建表的时候InnonDB选择的索引列" class="headerlink" title="创建表的时候InnonDB选择的索引列"></a>创建表的时候InnonDB选择的索引列</h4><ul><li>如果有主键，默认使用主键作为聚簇索引的索引键</li><li>如果没有主主键，选择第一个不包括NULL值的唯一值作为聚簇索引的索引键</li><li>如果以上两种情况都没有，InnoDB自动生成一个隐式自增id作为聚簇索引的索引键</li><li>其它索引都属于辅助索引（Secondary Index），也被称为二级索引或非聚簇索引。<strong>创建的主键索引和二级索引默认使用的是 B+Tree 索引</strong>。</li></ul><h4 id="B-树是什么样子的"><a href="#B-树是什么样子的" class="headerlink" title="B+树是什么样子的"></a>B+树是什么样子的</h4><ul><li>B+树是一种多叉树，叶子节点存放数据，非叶子节点只存放索引</li><li>每个节点里的数据是按主键顺序存放</li><li>叶子节点包含了所有的主键值信息</li></ul><p><img src="/../picture/image-20230905105056516.png" alt="image-20230905105056516"></p><blockquote><p>数据库的索引和数据都是存储在硬盘的，我们可以把读取一个节点当作一次磁盘 I&#x2F;O 操作。B+Tree 存储千万级的数据只需要 3-4 层高度就可以满足，这意味着从千万级的表查询目标数据最多需要 3-4 次磁盘 I&#x2F;O，所以B+Tree 相比于 B 树和二叉树来说，最大的优势在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I&#x2F;O 依然维持在 3-4次。</p></blockquote><h4 id="B-树主键索引和二级索引的区别"><a href="#B-树主键索引和二级索引的区别" class="headerlink" title="B+树主键索引和二级索引的区别"></a>B+树主键索引和二级索引的区别</h4><ul><li>主键索引叶子结点存放的是实际数据</li><li>二级索引的叶子节点存放的是主键的值，而不是实际数据</li></ul><blockquote><p>回表：在二级索引中查到主键的值，然后通过主键索引中的B+树查询对应的叶子节点，获取到整行数据。 要查两次B+树才能查到数据</p></blockquote><p><img src="/../picture/image-20230905105757060.png" alt="image-20230905105757060"></p><blockquote><p>索引覆盖：当需要查询的数据能在二级索引里查到，比如说查询主键的值</p></blockquote><h4 id="B-树的优点"><a href="#B-树的优点" class="headerlink" title="B+树的优点"></a>B+树的优点</h4><ul><li>对比B树<ul><li>B+树只在叶子节点存放数据，而B树在非叶子节点也存放数据，所以B+树的单个节点存储到数据量更小，在相同的磁盘I&#x2F;O次数下能查到更多的节点</li><li>B+树的叶子节点采用双向链表，适合顺序查找</li></ul></li><li>对比二叉树<ul><li>B+树是多叉树，而二叉树是二叉的，所以查询相同的数据，二叉树的深度要比B+树深很多，所以一次查询数据B+树对磁盘的I&#x2F;O操作要比二叉树少不少</li></ul></li><li>对比Hash存储<ul><li>哈希存储适合做等值查询，不适合做范围查询</li></ul></li></ul><h4 id="按物理存储分"><a href="#按物理存储分" class="headerlink" title="按物理存储分"></a>按物理存储分</h4><ul><li>主键索引：B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；</li><li>二级索引： B+Tree 的叶子节点存放的是主键值，而不是实际数据。</li></ul><h4 id="按字段特性分"><a href="#按字段特性分" class="headerlink" title="按字段特性分"></a>按字段特性分</h4><ul><li>主键索引：PRIMARY KEY (index_column_1) USING BTREE</li><li>唯一索引：UNIQUE KEY(index_column_1,index_column_2,…) </li><li>普通索引：INDEX(index_column_1,index_column_2,…) </li><li>前缀索引：<ul><li>前缀索引是指对字符类型字段的前几个字符建立的索引</li><li>用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。</li><li>INDEX(column_name(length))</li></ul></li></ul><h4 id="按字段个数分"><a href="#按字段个数分" class="headerlink" title="按字段个数分"></a>按字段个数分</h4><ul><li>单列索引：建立在单列上的索引</li><li>联合索引：建立在多列上的索引</li></ul><p><img src="/../picture/image-20230905111342834.png" alt="image-20230905111342834"></p><ul><li>先按 product_no 字段比较，在 product_no 相同的情况下再按 name 字段比较。也就是说，联合索引查询的 B+Tree 是先按 product_no 进行排序，然后再 product_no 相同的情况再按 name 字段排序</li></ul><h4 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h4><ul><li>索引按照最左优先的方式进行匹配，如果不遵循最左匹配原则的话，索引就会失效</li><li>需要注意的是，因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。</li><li>利用索引的前提是索引里的key是有序的</li></ul><h4 id="联合索引的查询范围"><a href="#联合索引的查询范围" class="headerlink" title="联合索引的查询范围"></a>联合索引的查询范围</h4><ul><li><strong>并不是查询过程使用了联合索引查询，就代表联合索引中的所有字段都用到了联合索引进行索引查询</strong>，也就是可能存在部分字段用到联合索引的 B+Tree，部分字段没有用到联合索引的 B+Tree 的情况。</li><li>这种特殊情况就发生在范围查询。联合索引的最左匹配原则会一直向右匹配直到遇到「范围查询」就会停止匹配。<strong>也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引</strong>。</li><li>select * from t_table where a &gt; 1 and b &#x3D; 2，<strong>这条查询语句只有 a 字段用到了联合索引进行索引查询，而 b 字段并没有使用到联合索引</strong>。</li><li>select * from t_table where a &gt;&#x3D; 1 and b &#x3D; 2，<strong>这条查询语句 a 和 b 字段都用到了联合索引进行索引查询</strong></li><li>SELECT * FROM t_table WHERE a BETWEEN 2 AND 8 AND b &#x3D; 2，<strong>这条查询语句 a 和 b 字段都用到了联合索引进行索引查询</strong></li><li>SELECT * FROM t_user WHERE name like ‘j%’ and age &#x3D; 22，<strong>这条查询语句 a 和 b 字段都用到了联合索引进行索引查询</strong></li></ul><blockquote><p><strong>联合索引的最左匹配原则，在遇到范围查询（如 &gt;、&lt;）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 &gt;&#x3D;、&lt;&#x3D;、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配，前面我也用了四个例子说明了</strong>。</p></blockquote><h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><ul><li><strong>在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</strong>。</li></ul><h4 id="索引区分度"><a href="#索引区分度" class="headerlink" title="索引区分度"></a>索引区分度</h4><ul><li><strong>建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到</strong>。</li></ul><p><img src="/../picture/image-20230905121252594.png" alt="image-20230905121252594"></p><ul><li>MySQL的查询优化器发现某个值出现在表的数据行中的百分比（惯用的百分比界线是”30%”）很高的时候，它一般会忽略索引，进行全表扫描。</li></ul><h4 id="联合索引排序"><a href="#联合索引排序" class="headerlink" title="联合索引排序"></a>联合索引排序</h4><ul><li>使用联合索引，根据索引的有序性可以对数据进行排序</li></ul><h4 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h4><ul><li>优点：可以提高查询速度</li><li>缺点：<ul><li>需要占据物理空间，数量越大，占据的空间越大</li><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增大</li><li>会降低表的增删改的效率，因为每次增删改索引，B+ 树为了维护索引有序性，都需要进行动态维护</li></ul></li></ul><h4 id="什么时候适用索引"><a href="#什么时候适用索引" class="headerlink" title="什么时候适用索引"></a>什么时候适用索引</h4><ul><li>字段有唯一性限制，比如说商品编码</li><li>经常使用where查询条件查询，使用索引能提高整表的查询速度</li><li>经常使用GROUP BY和ORDER BY的字段，这样在查询的时候就不需要再排序了</li></ul><h4 id="什么时候不需要创建索引"><a href="#什么时候不需要创建索引" class="headerlink" title="什么时候不需要创建索引"></a>什么时候不需要创建索引</h4><ul><li><code>WHERE</code> 条件，<code>GROUP BY</code>，<code>ORDER BY</code> 里用不到的字段，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。</li><li>字段中存在大量数据</li><li>数据太少的时候不需要创建索引</li><li>经常更新的字段就不需要创建索引，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。</li></ul><h4 id="索引优化方法"><a href="#索引优化方法" class="headerlink" title="索引优化方法"></a>索引优化方法</h4><ul><li><p>前缀索引优化</p><ul><li><p>减少索引字段的大小</p></li><li><p>提高查询速度</p></li><li><blockquote><p>order by无法使用前缀索引，前缀索引不能当做覆盖索引</p></blockquote></li></ul></li><li><p>覆盖索引优化</p><ul><li>将需要查询的数据建立一个联合索引，避免回表操作</li></ul></li><li><p>主键索引最好自增</p><ul><li>每次插入新数据按照顺序添加到当前索引节点的位置，不需要再移动已有数据，当页面写满，就会自动开辟一个新页面。</li><li>如果使用非自增主键，插入主键的索引值都是随机的，如果插入数据在中间位置，会移动其他数据，还有可能造成页分裂。<strong>页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率</strong>。</li></ul></li><li><p>主键字段长度不要太大，因为<strong>主键字段长度越小，意味着二级索引的叶子节点越小（二级索引的叶子节点存放的数据是主键值），这样二级索引占用的空间也就越小</strong>。</p></li><li><p>索引最好设置为NOT NULL</p><ul><li>如果为NULL，优化器在做索引选择的时候更加复杂</li></ul></li></ul><h4 id="防止索引失效的方法"><a href="#防止索引失效的方法" class="headerlink" title="防止索引失效的方法"></a>防止索引失效的方法</h4><ul><li>使用左右模糊匹配，<code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；</li><li>对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效；</li><li>联合索引要正确使用最左匹配原则，否则会失效</li><li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li></ul><h4 id="查看索引失效的方法"><a href="#查看索引失效的方法" class="headerlink" title="查看索引失效的方法"></a>查看索引失效的方法</h4><ul><li>使用explain来查看MySQL语句的执行计划</li></ul><p><img src="/../picture/image-20230905140327849.png" alt="image-20230905140327849"></p><ul><li>type 表示数据扫描类型，常见的扫描类型执行效率从低到高<ul><li>All（全表扫描）</li><li>index（全索引扫描）</li><li><strong>range（索引范围扫描）</strong>：这一界别的索引作用越来越明显</li><li>ref（非唯一索引扫描）</li><li>eq_ref（唯一索引扫描）</li><li>const（主键或唯一索引扫描）</li></ul></li></ul><blockquote><p><strong>const 是与常量进行比较，查询效率会更快，而 eq_ref 通常用于多表联查中</strong>。</p></blockquote><ul><li>Extra列<ul><li>Using filesort：文件排序查询</li><li>Using temporary：使用临时表保存中间结果</li><li>Using index：使用了覆盖索引，避免了回表操作，效率比较好</li></ul></li></ul><h1 id="事务隔离机制"><a href="#事务隔离机制" class="headerlink" title="事务隔离机制"></a>事务隔离机制</h1><p>事务的执行要么全部成功，要么全部失败</p><h3 id="事务有哪些特征"><a href="#事务有哪些特征" class="headerlink" title="事务有哪些特征"></a>事务有哪些特征</h3><ul><li>原子性：一个事务中的所有操作，要么全部完成，要么全部不完成，如果在事务执行过程中发生错误，会被回滚到事务最初始的状态</li><li>一致性：事务操作前后，数据满足完整性的约束，数据库保持一致性的状态</li><li>隔离性：数据库允许多个并发事务同事对数据进行读写和修改的能力，防止多个事务并发执行时由于交叉执行导致的数据不一致的问题，保证多个事务同时使用相同的数据，不会互相干扰</li><li>持久性：事务处理结束后，对数据的修改是永久的</li></ul><h3 id="InnoDB怎样保证数据事务的四个特征"><a href="#InnoDB怎样保证数据事务的四个特征" class="headerlink" title="InnoDB怎样保证数据事务的四个特征"></a>InnoDB怎样保证数据事务的四个特征</h3><ul><li>持久性：通过redo log（重做日志）保证</li><li>原子性：通过undo log（回滚日志）保证</li><li>隔离性：通过MVCC多版本隔离机制和锁机制保证</li><li>一致性：通过持久性+原子性+隔离性来保证</li></ul><h3 id="并发执行事务会出现什么问题"><a href="#并发执行事务会出现什么问题" class="headerlink" title="并发执行事务会出现什么问题"></a>并发执行事务会出现什么问题</h3><ul><li>脏读：一个事务读取到了另一个未提交事务修改过的数据，就是脏读<ul><li>A修改数据，未提交事务，B读取到修改后的数据，A回滚事务</li></ul></li></ul><p><img src="/../picture/image-20230908145043980.png" alt="image-20230908145043980"></p><ul><li>幻读：在一个事务多内多次查询条件的记录数量，前后两次查询的记录不一样，就发生了幻读<ul><li>A读取余额大于100万的数据有5条，B读取也有5条，A插入一条，并提交事务，B在读取就变成了6条，就发生了幻读</li></ul></li></ul><p><img src="/../picture/image-20230908145002024.png" alt="image-20230908145002024"></p><ul><li>不可重复读：同一个事务内多次读取同一个数据，前后两次数据不一样，就发生了不可重复度<ul><li>A读取数据，未提交事务，B修改数据，提交事务，A读取数据，前后两次结果不一致</li></ul></li></ul><p><img src="/../picture/image-20230908145027026.png" alt="image-20230908145027026"></p><h3 id="事务并发对程序产生影响的排序"><a href="#事务并发对程序产生影响的排序" class="headerlink" title="事务并发对程序产生影响的排序"></a>事务并发对程序产生影响的排序</h3><ul><li>脏读：读到其他事务未提交的数据</li><li>不可重复读：前后读取到数据不一致</li><li>幻读：前后读到的数量不一致</li><li>影响情况从高到低：脏读 &gt; 不可重复读 &gt; 幻读</li></ul><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><ul><li>读未提交：一个事务没有提交时，做的变更就被其他事务看到了</li><li>读提交：一个事务提交之后，做的变更才能被其他事务看到</li><li>可重复读：一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，<strong>MySQL InnoDB存储引擎默认的隔离级别</strong></li><li>串行化：会对记录加上读写锁，在多个事务对这条记录进行读取操作的时候，如果发生了读写冲突，后访问的事务必须等前一个事务执行完成以后，才能再接着继续执行</li></ul><blockquote><ul><li>事务隔离级别从高到底的顺序：串行化 &gt; 可重复度 &gt; 读已提交 &gt; 读未提交</li></ul></blockquote><h4 id="不同隔离级别可能会发生的问题"><a href="#不同隔离级别可能会发生的问题" class="headerlink" title="不同隔离级别可能会发生的问题"></a>不同隔离级别可能会发生的问题</h4><ul><li>读未提交：脏读、幻读、不可重复度</li><li>读已提交：不可重复度、幻读</li><li>可重复度：幻读</li><li>串行化：无</li></ul><blockquote><p>MySQL在可重复度隔离级别下，可以很大程度避免幻读发生，所以不使用串行化来避免幻读，串行化的隔离级别很影响性能</p></blockquote><h3 id="MySQL-innoDB解决幻读的两种方法"><a href="#MySQL-innoDB解决幻读的两种方法" class="headerlink" title="MySQL innoDB解决幻读的两种方法"></a>MySQL innoDB解决幻读的两种方法</h3><ul><li>快照读（select语句）：通过MVCC解决，在可重复度隔离级别下，一直和事务启动时看到的数据是一致的，所以即使中途插入数据，也查不出来这条数据，这就很好的解决幻读问题</li><li>当前读（select for update（语句））：<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li></ul><h3 id="分析以下场景在不同事务隔离级别之下的查询结果"><a href="#分析以下场景在不同事务隔离级别之下的查询结果" class="headerlink" title="分析以下场景在不同事务隔离级别之下的查询结果"></a>分析以下场景在不同事务隔离级别之下的查询结果</h3><p><img src="/../picture/image-20230909152721701.png" alt="image-20230909152721701"></p><ul><li><p>读未提交：200，200，200</p></li><li><p>读提交：100，200，200</p><ul><li>在每个语句执行之前，重新生成一个新的Read View</li></ul></li><li><p>可重复度：100，100，200</p><ul><li>启动事务之前，生成一个新的Read View</li></ul></li><li><p>串行化：100，100，200</p><ul><li>加读写锁控制</li></ul></li></ul><h3 id="bigin-x2F-start-transaction和start-transaction-with-consistent-snapshot的区别"><a href="#bigin-x2F-start-transaction和start-transaction-with-consistent-snapshot的区别" class="headerlink" title="bigin&#x2F;start transaction和start transaction with consistent snapshot的区别"></a>bigin&#x2F;start transaction和start transaction with consistent snapshot的区别</h3><ul><li>bigin&#x2F;start transaction没有启动事务，执行了增删改查操作之后，才真正启动事务</li><li>start transaction with consistent snapshot 马上启动事务</li></ul><h3 id="Read-View在MVCC（多版本并发控制机制）中是怎样工作的"><a href="#Read-View在MVCC（多版本并发控制机制）中是怎样工作的" class="headerlink" title="Read View在MVCC（多版本并发控制机制）中是怎样工作的"></a>Read View在MVCC（多版本并发控制机制）中是怎样工作的</h3><h4 id="Read-View中的四个值"><a href="#Read-View中的四个值" class="headerlink" title="Read View中的四个值"></a>Read View中的四个值</h4><p><img src="/../picture/image-20230912215057682.png" alt="image-20230912215057682"></p><ul><li>creator_trx_id：创建当前Read View的事务的id</li><li>m_ids：创建Read View时，当前数据库中活跃事务的id列表，<strong>活跃事务是指，启动了但还没有提交的事务</strong></li><li>min_trx_id：是指在常见Read_View时，当前数据库中活跃事务中事务id的最小十五，也就是m_ids中的最小值</li><li>max_trx_id：这个不是最大值，而是最大值+1，是指当前数据库中应该给下一个事务的id值</li></ul><h4 id="聚簇索引中的两个隐藏列"><a href="#聚簇索引中的两个隐藏列" class="headerlink" title="聚簇索引中的两个隐藏列"></a>聚簇索引中的两个隐藏列</h4><p><img src="/../picture/image-20230912215423296.png" alt="image-20230912215423296"></p><ul><li>trx_id：当一个事务对聚簇索引中的记录进行修改时，就会把该事务的id记录在trx_id列中</li><li>roll_pointer：是指对聚簇索引进行修改时，会把旧版本写到undo日志中，这个隐藏列是一个指针，指向每一个旧版本记录，通过指针可以找到修改之前的记录</li></ul><p><img src="/../picture/image-20230912215601799.png" alt="image-20230912215601799"></p><p>一个事务访问记录的时候，会遇到如下这几种情况：</p><ul><li>如果trx_id值小于Read View中min_trx_id值，就表示在创建Read View之前这个事务就已经提交了，所以该版本的记录对应的事务是可见的</li><li>如果trx_id值大于max_trx_id，说明在创建该Read View时这个版本记录还没生成，所以该版本的记录对当前事务不可见</li><li>如果trx_id值在min_trx_id和max_trx_id之间，则判断是否在m_ids列表中<ul><li>如果在，则表示生成该版本时记录的事务依然活跃着，还没有提交，所以该版本的记录对当前事务不可见</li><li>如果不在，说明生成该版本记录的活跃事务已经被提交了，所以该版本的记录对当前事务可见</li></ul></li></ul><blockquote><p><strong>这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）。</strong></p></blockquote><h3 id="可重复读是怎样工作的"><a href="#可重复读是怎样工作的" class="headerlink" title="可重复读是怎样工作的"></a>可重复读是怎样工作的</h3><ul><li>可重复读隔离级别是启动事务时生成一个Read View，在整个事务期间都用这一个Read View</li></ul><h3 id="读提交是怎样工作的"><a href="#读提交是怎样工作的" class="headerlink" title="读提交是怎样工作的"></a>读提交是怎样工作的</h3><ul><li>读提交是在每次读取数据时，都会生成一个新的Read View</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/09/19/JUC/"/>
    <url>/2023/09/19/JUC/</url>
    
    <content type="html"><![CDATA[<h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><ul><li>CopyOnWriteArrayList()线程安全数组</li><li>Lock</li></ul><p>![image-20230917172425407](&#x2F;Users&#x2F;milkboy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230917172425407.png)</p><ul><li>原子性</li><li>lock 锁</li></ul><h2 id="什么是JUC"><a href="#什么是JUC" class="headerlink" title="什么是JUC"></a>什么是JUC</h2><ul><li>工具包</li><li>包、分类</li></ul><p>![image-20230917172831390](&#x2F;Users&#x2F;milkboy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230917172831390.png)</p><p>创建多线程方式的实现Callable接口就在juc包下</p><ul><li>locks锁</li></ul><p>![image-20230917172930579](&#x2F;Users&#x2F;milkboy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230917172930579.png)</p><h2 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h2><ul><li><p>进程：程序的集合</p><ul><li>一个进程可以包含多个线程</li><li>至少包含一个线程</li><li>Java默认有2个线程，main线程，gc线程</li></ul></li><li><p>Thread、Runnable、Callable、线程池</p></li><li><p>Java开不了线程，native本地方法去调，调用底层c++，本地线程</p></li></ul><h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><ul><li>并发：一段时间同时操作，快速交替，单核</li><li>并行：同一时刻，多核</li></ul><h2 id="并发本质：充分利用CPU资源"><a href="#并发本质：充分利用CPU资源" class="headerlink" title="并发本质：充分利用CPU资源"></a>并发本质：充分利用CPU资源</h2><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><ul><li>wait和sleep的区别<ul><li>不同的类，wait是Object类，sleep是Thread类，企业中一般用juc下的TimeUnit工具类操作</li><li>锁的释放：wait会释放锁，sleep不会释放</li><li>使用的范围不同：<ul><li>wait：同步代码块</li><li>sleep：任何地方</li></ul></li><li>是否需要捕获异常：<ul><li>wait：不需要</li><li>sleep：需要</li></ul></li></ul></li></ul><h2 id="Locks锁"><a href="#Locks锁" class="headerlink" title="Locks锁"></a>Locks锁</h2><p>![image-20230917175419259](&#x2F;Users&#x2F;milkboy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230917175419259.png)</p><ul><li>ReentrantLock：默认非公平锁<ul><li>new</li><li>加锁 try catch</li><li>解锁</li></ul></li><li>Lock和Synchronized锁的区别</li></ul><p>![image-20230917180348014](&#x2F;Users&#x2F;milkboy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230917180348014.png)</p><ul><li>怎样判断锁的是谁</li></ul><h3 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h3><p>![image-20230917200631317](&#x2F;Users&#x2F;milkboy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230917200631317.png)</p><p>![image-20230917202037343](&#x2F;Users&#x2F;milkboy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230917202037343.png)</p><ul><li>Condition优势：精准通知和唤醒线程<ul><li>![image-20230917203333911](&#x2F;Users&#x2F;milkboy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230917203333911.png)</li><li>使用多个监视器进行精准唤醒</li></ul></li></ul><h2 id="8锁现象"><a href="#8锁现象" class="headerlink" title="8锁现象"></a>8锁现象</h2><p> synchronized锁的是方法的调用者</p><p>静态方法锁的是class对象，class模版</p><h2 id="并发数组不安全"><a href="#并发数组不安全" class="headerlink" title="并发数组不安全"></a>并发数组不安全</h2><p>![image-20230917213128970](&#x2F;Users&#x2F;milkboy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230917213128970.png)</p><ul><li>Vector</li></ul><p>![image-20230917213513274](&#x2F;Users&#x2F;milkboy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230917213513274.png)</p><ul><li>CopyOnWriteList<ul><li>![image-20230917213530518](&#x2F;Users&#x2F;milkboy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230917213530518.png)</li></ul></li></ul><p>![image-20230917214036491](&#x2F;Users&#x2F;milkboy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230917214036491.png)</p><p>![image-20230917215759224](&#x2F;Users&#x2F;milkboy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230917215759224.png)</p><ul><li>hashMap加载因子和初始容量，初始容量16，加载因子0.75</li><li>![image-20230917220342457](&#x2F;Users&#x2F;milkboy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230917220342457.png)</li></ul><h2 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h2><ul><li>可以有返回值，可以抛出异常</li><li>方法不同call()</li></ul><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><ul><li>辅助工具类</li><li>减法计数器</li><li>countDowntLatch.countDown减1<ul><li>辅助类</li><li>await等待计数器归零</li><li>必须要执行任务的时候再使用</li><li>原理：</li></ul></li></ul><p>![image-20230917222013988](&#x2F;Users&#x2F;milkboy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230917222013988.png)</p><p>![image-20230917222526937](&#x2F;Users&#x2F;milkboy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230917222526937.png)</p><ul><li>信号量，限流的时候会用</li><li>![image-20230917222651291](&#x2F;Users&#x2F;milkboy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230917222651291.png)</li></ul><p>![image-20230917222808393](&#x2F;Users&#x2F;milkboy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230917222808393.png)</p><ul><li>读写锁：读的时候可以由多个线程操作，写的时候保证了原子性，只能由一个线程操作</li></ul><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><ul><li><p>三大方法</p></li><li><p>七大参数</p><ul><li>核心线程数</li><li>最大线程数</li><li>超时等待数</li><li>队列</li><li>现场工厂</li><li>拒绝策略<ul><li>new AbortPolicy 默认，银行满了，还有人进来，不处理，抛出异常</li><li>CallerRunPolicy 哪来的去哪里</li><li>DiscardPolicy 队列满了，不会抛出异常</li><li>DiscardOldestPolicy 尝试去和第一个竞争，尝试竞争第一个</li></ul></li></ul></li><li><p>最大承载 &#x3D; 队列 + 最大线程数</p></li><li><p>![image-20230918094821423](&#x2F;Users&#x2F;milkboy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230918094821423.png)</p></li></ul><p>![image-20230918101219830](&#x2F;Users&#x2F;milkboy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230918101219830.png)</p><p>明天 周二下午面试安排 （ 目前在总体部实习生 明年毕业）7054会议室</p><p>1、贾利凯 14:00 侯茂春<br>2、刘一泽14:25 蒋亚楠<br>3、邓彩叶14:45 刘新顺<br>4、敦晓荣15:05 产品 李亚卓<br>5、茅莹   15:30 李亚卓<br>6、王积慧15:45 刘新顺<br>7、谢镕阳 16:15 叶蔚<br>    请带教老师或者各业务室负责人一定参加，需要进行推荐介绍。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/09/18/%E7%A7%8B%E6%8B%9BJava%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/"/>
    <url>/2023/09/18/%E7%A7%8B%E6%8B%9BJava%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/</url>
    
    <content type="html"><![CDATA[<h2 id="基础知识一"><a href="#基础知识一" class="headerlink" title="基础知识一"></a>基础知识一</h2><h3 id="Java语言特点："><a href="#Java语言特点：" class="headerlink" title="Java语言特点："></a>Java语言特点：</h3><ul><li>简单易学</li><li>面向对象（封装、继承、多态）</li><li>平台无关性（JVM）</li><li>支持多线程</li><li>可靠性</li><li>安全性</li><li>支持网络编程</li><li>编译与解释并存</li></ul><h3 id="JVM、JDK、JRE"><a href="#JVM、JDK、JRE" class="headerlink" title="JVM、JDK、JRE"></a>JVM、JDK、JRE</h3><ul><li>JVM：Java字节码虚拟机，针对不同操作系统具有不同实现，使用相同的字节码，可以得到相同的运行结果，是Java一次编译随处运行的关键。</li><li>JDK：功能齐全的Java SDK，包括JRE，Javac，Javadoc等工具</li><li>JRE：Java运行时环境，包括JVM和Java基础类库</li></ul><h3 id="什么是字节码"><a href="#什么是字节码" class="headerlink" title="什么是字节码"></a>什么是字节码</h3><p>​JVM可以理解的代码，也就是.class文件，只面向Java虚拟机，Java语言通过字节码的方式解决了解释性语言效率低的问题，又保留了解释性语言可移植的特点</p><p><img src="/../picture/image-20230904092658304.png" alt="image-20230904092658304"></p><blockquote><p>JIT(just-in-time compilation)：运行时编译，对于热点代码，当编译器完成编译后，会把对应的机器码保存下来，下次可以直接使用</p><p>AOT：JDK9的新特性，直接将字节码编译成机器码</p></blockquote><h3 id="为什么说Java是编译和解释并存的语言？"><a href="#为什么说Java是编译和解释并存的语言？" class="headerlink" title="为什么说Java是编译和解释并存的语言？"></a>为什么说Java是编译和解释并存的语言？</h3><ul><li>编译型：将源代码直接翻译成机器码，编译效率高，开发效率低</li><li>解释型：一句一句解释为机器码以后再执行，开发效率高，执行速度慢</li><li>Java既有编译语言的特点，又有解释语言的特点，先编译成.class字节码文件，然后解释型再执行</li></ul><h3 id="Java和C-区别"><a href="#Java和C-区别" class="headerlink" title="Java和C++区别"></a>Java和C++区别</h3><ul><li>Java有垃圾回收机制，C++没有</li><li>Java不能操作指针直接访问内存，更安全</li><li>Java的类是单继承的，C++是多继承的，Java接口可以多继承</li><li>Java支持方法重载，不支持运算符重载，C++都支持</li></ul><h3 id="注解的形式"><a href="#注解的形式" class="headerlink" title="注解的形式"></a>注解的形式</h3><ul><li>单行、多行、文档</li></ul><h3 id="标识符和关键字"><a href="#标识符和关键字" class="headerlink" title="标识符和关键字"></a>标识符和关键字</h3><ul><li>标识符：程序、类、方法、变量的名字</li><li>关键字：被赋予特殊含义的标识符</li></ul><h3 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h3><ul><li>a++：先赋值，再自增</li><li>++a：先自增，再赋值</li></ul><h3 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h3><ul><li>&lt;&lt;：高位丢失，低位补0，结果乘2</li><li><code>&gt;&gt;</code>：低位丢失，高位加符号位，+0，-1</li><li><code>&gt;&gt;&gt;</code>：低位丢失，高位补0</li></ul><blockquote><p>float和short类型的不能移位，byte,short,char移位前都会转化成int</p><p>如果移位的位数大于本来都位数，需要进行取余，int取余32，long取余64</p></blockquote><h3 id="contine，break，return"><a href="#contine，break，return" class="headerlink" title="contine，break，return"></a>contine，break，return</h3><ul><li>contine：跳出一次循环</li><li>break：退出整个循环</li><li>return跳出方法</li></ul><h3 id="Java基本数据类型"><a href="#Java基本数据类型" class="headerlink" title="Java基本数据类型"></a>Java基本数据类型</h3><ul><li>整数：byte、short、int、long</li><li>字符：char</li><li>布尔：boolean</li><li>浮点数：float，double</li></ul><p><img src="/../picture/image-20230904094917184.png" alt="image-20230904094917184"></p><blockquote><p>Long类型的后面要加L，字符型：单引号，字符串型：双引号</p><p>包装类：Byte、Shorter、Integer、Long、Boolean、Character、Float、Double</p></blockquote><h3 id="基本类型和包装类型的区别"><a href="#基本类型和包装类型的区别" class="headerlink" title="基本类型和包装类型的区别"></a>基本类型和包装类型的区别</h3><ul><li>用途：除了常量和部分局部变量会用基本数据类型，其他的方法参数，对象属性之类的基本都用包装类型，包装类型可以用泛型，基本类型不会</li><li>存储方式：<ul><li>基本数据类型的局部变量存储在Java虚拟机栈中的局部变量表中</li><li>基本数据类型成员变量未被static修饰，存放在Java虚拟机的堆中</li><li>包装类型属于对象，对象的实例都存储在堆中</li></ul></li><li>占用空间：基本数据类型占用空间比较小</li><li>默认值：成员变量包装类型不赋值就是null，基本数据类型有默认值</li><li>比较方式：基本数据类型&#x3D;&#x3D;比较的是值，旧包装类型&#x3D;&#x3D;比较的是内存地址，如果想要比较值，使用equals()方法</li></ul><blockquote><p>基本数据类型存放在栈中是一个常见误区，类的成员变量如果没有被static修饰的话，就存放在堆中</p></blockquote><h3 id="包的缓存机制"><a href="#包的缓存机制" class="headerlink" title="包的缓存机制"></a>包的缓存机制</h3><ul><li>Byte、Short、Integer、Long默认创建了[-128, 127]，Character创建了[0, 127]，Boolean直接返回True或者False</li><li>源码判断，如果在缓存范围之内，直接返回缓存值就行，如果不在，就创建一个新对象</li></ul><h3 id="自动装箱机制和拆箱机制"><a href="#自动装箱机制和拆箱机制" class="headerlink" title="自动装箱机制和拆箱机制"></a>自动装箱机制和拆箱机制</h3><ul><li><p>装箱：将基本数据类型用对应的引用类型包装起来 </p><ul><li>&#96;&#96;&#96;java<br>Integer i &#x3D; 10;<br>调用了包装类型的ValueOf()方法<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs excel"><br>* 拆箱：将包装类型转化为基本数据类型<br><br>  * ```java<br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span> = <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span> = <span class="hljs-number">10</span>.intValue()<br>    调用了xxxValue方法<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="为什么浮点数会精度丢失"><a href="#为什么浮点数会精度丢失" class="headerlink" title="为什么浮点数会精度丢失"></a>为什么浮点数会精度丢失</h3><ul><li>计算机表示数字时，宽度是有限的，所以使用浮点数表示时，就会造成精度丢失</li><li>Java解决精度丢失使用<code>BigDecimal</code>包，使用BigDecimal时注意要将浮点数加双引号表示</li></ul><h3 id="Java超出数据范围精度时该怎么使用"><a href="#Java超出数据范围精度时该怎么使用" class="headerlink" title="Java超出数据范围精度时该怎么使用"></a>Java超出数据范围精度时该怎么使用</h3><ul><li>使用BigInteger包来使用，BigInteger包内部使用int[ ]数组来存储，效率相对比较低</li></ul><h3 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h3><ul><li>语法形式：<ul><li>成员变量属于类，局部变量属于方法或代码块</li><li>成员变量可以被public，static修饰，局部变量不可以，但是都可以用final修饰</li></ul></li><li>存储方式：<ul><li>成员变量使用static修饰，属于类，存储在栈中，没使用static修饰，属于实例，存储在堆中</li></ul></li><li>生存时间：<ul><li>成员变量属于对象的一部分，随着对象创建产生，而局部变量随着方法调用产生，方法调用结束消亡</li></ul></li><li>默认值：<ul><li>成员变量没有初始化的话，自动以默认值来赋值，局部变量不会赋默认值</li></ul></li></ul><h3 id="静态变量作用"><a href="#静态变量作用" class="headerlink" title="静态变量作用"></a>静态变量作用</h3><ul><li>所有类共有一个静态变量，只会被分配一次内存，无论创建多少个对象，都只共享一份静态变量</li><li>静态变量需要通过类名去访问</li></ul><h3 id="字符常量和字符串常量的区别"><a href="#字符常量和字符串常量的区别" class="headerlink" title="字符常量和字符串常量的区别"></a>字符常量和字符串常量的区别</h3><ul><li>字符常量占用两个字符</li></ul><h3 id="静态方法为什么不能调用非静态成员"><a href="#静态方法为什么不能调用非静态成员" class="headerlink" title="静态方法为什么不能调用非静态成员"></a>静态方法为什么不能调用非静态成员</h3><ul><li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名来直接访问。而非静态方法是属于实例对象的，需要通过实例对象去访问，在类的非静态成员变量不存在的时候，静态方法就已经存在了，此时调用非静态成员就属于非法操作</li></ul><h3 id="静态方法和实例方法有什么不同"><a href="#静态方法和实例方法有什么不同" class="headerlink" title="静态方法和实例方法有什么不同"></a>静态方法和实例方法有什么不同</h3><ul><li>调用方式：静态方法一般用类名.方法名来访问，而实例方法一般使用对象.方法名</li><li>访问是否首先：静态方法只允许访问静态成员，不允许访问实例成员，而实例方法不存在这种问题</li></ul><h3 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h3><ul><li>重载：在同一个类中，方法名必须相同，参数个数，参数类型，返回值类型，参数顺序都可以不同，返回不同的结果</li><li>重写：发生在运行期间，子类可以对父类允许访问的方法的实现过程进行重写的过程<ul><li>子类对父类的重新改造，外部样子不变，内部逻辑改变</li><li>重写<code>两同两小一大</code></li></ul></li></ul><p><img src="/../picture/image-20230904121445304.png" alt="image-20230904121445304"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hero</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;超级英雄&quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SuperMan</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Hero</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;超人&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Hero <span class="hljs-title function_">hero</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SuperSuperMan</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SuperMan</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;超级超级英雄&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> SuperMan <span class="hljs-title function_">hero</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperMan</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="可变长参数"><a href="#可变长参数" class="headerlink" title="可变长参数"></a>可变长参数</h3><ul><li>可变长参数底层实现是一个数组</li></ul><h2 id="基础知识点二"><a href="#基础知识点二" class="headerlink" title="基础知识点二"></a>基础知识点二</h2><h3 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h3><ul><li>面向过程把问题拆分成一个一个的方法，然后通过方法的执行来解决问题</li><li>面向对象会抽离出对象，用对象执行方法的方式解决问题</li></ul><h3 id="创建对象用什么关键字"><a href="#创建对象用什么关键字" class="headerlink" title="创建对象用什么关键字"></a>创建对象用什么关键字</h3><ul><li>创建一个对象用new关键字，new创建的对象实例存放在堆内存中，对象引用指向对象实例，对象引用存放在栈内存中<ul><li>一个引用可以指向0个或1个对象</li><li>一个对象可以有n个引用指向</li></ul></li></ul><h3 id="对象相等和引用相等的区别"><a href="#对象相等和引用相等的区别" class="headerlink" title="对象相等和引用相等的区别"></a>对象相等和引用相等的区别</h3><ul><li>对象相等是指对象中存放的内容相等</li><li>引用相等是指指向他们都内存地址是否相同</li></ul><h3 id="如果一个类没有声明构造方法，这个类能正常执行吗"><a href="#如果一个类没有声明构造方法，这个类能正常执行吗" class="headerlink" title="如果一个类没有声明构造方法，这个类能正常执行吗"></a>如果一个类没有声明构造方法，这个类能正常执行吗</h3><ul><li>如果一个类没有声明构造方法，默认有一个不带参数的构造方法</li><li>如果自己添加了构造方法，这个方法就没有了</li></ul><h3 id="构造方法有哪些特点，是否可以被重写"><a href="#构造方法有哪些特点，是否可以被重写" class="headerlink" title="构造方法有哪些特点，是否可以被重写"></a>构造方法有哪些特点，是否可以被重写</h3><ul><li>构造方法特点<ul><li>方法名和类名相同</li><li>没有返回值，不能用void声明</li><li>创建类的对象时自动执行</li></ul></li><li>构造方法可以被重载，不可以被重写</li></ul><h3 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h3><ul><li>封装：把对象的属性隐藏在内部，不允许外部对象直接访问，但是可以给外部对象提供一些访问和操作的方法</li><li>继承：使用已存在的类作为基础建立新的类，新类可以增加新的数据或新的功能，也可以使用父类的功能，但不能选择性的继承父类，通过继承可以快速创建新累，可以提高代码的重用<ul><li>子类拥有父类的属性和方法，父类中的私有属性和私有方法无法访问，只是拥有</li><li>子类可以拥有自己的属性和方法，可以对父类进行扩展</li><li>子类可以用自己的方法实现父类</li></ul></li><li>多态：一个对象具有多种状态，具体表现为父类的引用指向子类的实例<ul><li>对象的类型和引用类型直接具有继承关系</li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定</li><li>多态不能调用只存在子类而不存在父类中的方法</li><li>子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有重写父类的方法，执行的就是父类的方法</li></ul></li></ul><h3 id="抽象类和接口有什么区别"><a href="#抽象类和接口有什么区别" class="headerlink" title="抽象类和接口有什么区别"></a>抽象类和接口有什么区别</h3><ul><li>共同点<ul><li>都不能被实例化</li><li>都包含抽象方法，子类必须重写这些方法</li><li>都有默认实现方法</li></ul></li><li>不同点</li></ul><p><img src="/../picture/image-20230905164721630.png" alt="image-20230905164721630"></p><h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p><img src="/../picture/image-20230905170343429.png" alt="image-20230905170343429"></p><ul><li>浅拷贝：浅拷贝会在堆上创建一个新对象，对于基本的数据类型进行值传递，对引用数据类型，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用一个内部对象</li><li>深拷贝：完全复制整个对象</li><li>引用拷贝：两个不同的引用指向同一个对象</li></ul><h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; getClass()<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，用于创建并返回当前对象的一份拷贝。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyAll</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span><br><span class="hljs-comment"> */</span><br>publicfinal <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, <span class="hljs-type">int</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 实例被垃圾回收器回收的时候触发的操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123; &#125;<br></code></pre></td></tr></table></figure><h3 id="x3D-x3D-和equals的区别"><a href="#x3D-x3D-和equals的区别" class="headerlink" title="&#x3D;&#x3D;和equals的区别"></a>&#x3D;&#x3D;和equals的区别</h3><ul><li>基本数据类型&#x3D;&#x3D;比较的是值，引用类型&#x3D;&#x3D;比较的是数值</li><li>equals比较两个对象是否相等<ul><li>String重写了equals，所以String比较的是两个字符串的值</li></ul></li></ul><blockquote><p>使用String创建一个值的时候，先要从常量池中判断一下有没有这个值，如果没有的话才会重新创建一个String对象，如果有的话直接从常量池中引用了</p></blockquote><h3 id="HashCode有什么用"><a href="#HashCode有什么用" class="headerlink" title="HashCode有什么用"></a>HashCode有什么用</h3><ul><li>获取哈希码，确定该对象在哈希表中的索引位置，根据键很快就能获取到值</li></ul><h4 id="为什么还有有hashCode了"><a href="#为什么还有有hashCode了" class="headerlink" title="为什么还有有hashCode了"></a>为什么还有有hashCode了</h4><ul><li>拿HashSet举例，在添加元素的时候，会判断两个元素是否相同，先判断hashCode的值，如果HashCode的值相同再使用equals判断，这样效率比较高</li><li>如果两个对象HashCode值相同，两个对象不一定相同，哈希碰撞</li><li>如果两个对象HashCode相同，equals判断也相同，才相同</li><li>如果两个对象HashCode不同，那这两个对象就不相同</li></ul><h3 id="为什么重写equals方法的时候必须要重写HashCode方法"><a href="#为什么重写equals方法的时候必须要重写HashCode方法" class="headerlink" title="为什么重写equals方法的时候必须要重写HashCode方法"></a>为什么重写equals方法的时候必须要重写HashCode方法</h3><ul><li>两个相同的对象HashCode必须相同，如果不重写可能会出现两个对象相等，HashCode值却不相同的情况</li></ul><h3 id="String、StringBuffer、StringBuilder"><a href="#String、StringBuffer、StringBuilder" class="headerlink" title="String、StringBuffer、StringBuilder"></a>String、StringBuffer、StringBuilder</h3><ul><li>可变性：<ul><li>String不可变</li><li>StringBuilder和StringBuffer可变</li></ul></li><li>线程安全性：<ul><li>String线程安全</li><li>StringBuffer加了同步锁，线程安全</li><li>StringBuilder没加同步锁，线程不安全</li></ul></li><li>性能：<ul><li>String改变的时候，会生成一个新的String对象</li><li>StringBuffer和StringBuilder在自身操作对象</li><li>StringBuilder性能稍微好一点</li></ul></li><li>总结：<ul><li>少量数据用String</li><li>单线程操作大量数据用StringBuilder</li><li>多线程操作大量数据用StringBuffer</li></ul></li></ul><h3 id="String为什么不可变"><a href="#String为什么不可变" class="headerlink" title="String为什么不可变"></a>String为什么不可变</h3><p>​String数组的底层使用private final(不可被继承)修饰了一个字符数组，没有提供操作这个数组的方法，所以不可变</p><h3 id="字符的拼接用“-”还是用StringBuilder"><a href="#字符的拼接用“-”还是用StringBuilder" class="headerlink" title="字符的拼接用“+”还是用StringBuilder"></a>字符的拼接用“+”还是用StringBuilder</h3><ul><li>使用+拼接字符串的时候，从对应的字节码文件可以看出来，其实是先使用StringBuilder.append方法拼接上，然后再使用toString()方法转化成一个String对象</li><li>循环拼接的话，会创建多个StringBuilder，所以一般用StringBuilder直接拼接</li></ul><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><ul><li>JVM为了提升性能和减少内存消耗对String类的影响，专门开辟了一个区域，避免字符串重复创建</li></ul><h3 id="String-intern"><a href="#String-intern" class="headerlink" title="String.intern"></a>String.intern</h3><ul><li>将指定的字符串对象的引用保存在字符串的常量池中<ul><li>如果字符串的常量池中保存了引用，直接返回</li><li>如果没有保存，创建一个新的字符串对象引用并返回</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在堆中创建字符串对象”Java“</span><br><span class="hljs-comment">// 将字符串对象”Java“的引用保存在字符串常量池中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Java&quot;</span>;<br><span class="hljs-comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> s1.intern();<br><span class="hljs-comment">// 会在堆中在单独创建一个字符串对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Java&quot;</span>);<br><span class="hljs-comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> s3.intern();<br><span class="hljs-comment">// s1 和 s2 指向的是堆中的同一个对象</span><br>System.out.println(s1 == s2); <span class="hljs-comment">// true</span><br><span class="hljs-comment">// s3 和 s4 指向的是堆中不同的对象</span><br>System.out.println(s3 == s4); <span class="hljs-comment">// false</span><br><span class="hljs-comment">// s1 和 s4 指向的是堆中的同一个对象</span><br>System.out.println(s1 == s4); <span class="hljs-comment">//true</span><br><br></code></pre></td></tr></table></figure><h3 id="String拼接字符串"><a href="#String拼接字符串" class="headerlink" title="String拼接字符串"></a>String拼接字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;str&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ing&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;str&quot;</span> + <span class="hljs-string">&quot;ing&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str4</span> <span class="hljs-operator">=</span> str1 + str2;<br><span class="hljs-type">String</span> <span class="hljs-variable">str5</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;string&quot;</span>;<br>System.out.println(str3 == str4);<span class="hljs-comment">//false</span><br>System.out.println(str3 == str5);<span class="hljs-comment">//true</span><br>System.out.println(str4 == str5);<span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><ul><li><p><strong>对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。</strong></p></li><li><p>常量折叠：</p></li><li><p>常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。对于 <code>String str3 = &quot;str&quot; + &quot;ing&quot;;</code> 编译器会给你优化成 <code>String str3 = &quot;string&quot;;</code> 。</p></li><li><p>适用于常量折叠的情况：编译期间就可以确定的值</p><ul><li>基本数据类型以及常量字符串</li><li>final修饰的基本数据类型和字符串变量</li><li>字符串的拼接，基本数据类型键的预算(+、-、*、&#x2F;、&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;)</li></ul></li><li><p>使用final修饰的字符串会被编译器当做常量来处理</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;str&quot;</span>;<br><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ing&quot;</span>;<br><span class="hljs-comment">// 下面两个表达式其实是等价的</span><br><span class="hljs-type">String</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;str&quot;</span> + <span class="hljs-string">&quot;ing&quot;</span>;<span class="hljs-comment">// 常量池中的对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> str1 + str2; <span class="hljs-comment">// 常量池中的对象</span><br>System.out.println(c == d);<span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><ul><li>如果编译器在运行时才能确定值的话，就无法进行优化（str2就是在运行期间才能确定值）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;str&quot;</span>;<br><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> getStr();<br><span class="hljs-type">String</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;str&quot;</span> + <span class="hljs-string">&quot;ing&quot;</span>;<span class="hljs-comment">// 常量池中的对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> str1 + str2; <span class="hljs-comment">// 在堆上创建的新的对象</span><br>System.out.println(c == d);<span class="hljs-comment">// false</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getStr</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ing&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="基础知识三"><a href="#基础知识三" class="headerlink" title="基础知识三"></a>基础知识三</h2><p><img src="/../picture/image-20230906134847777.png" alt="image-20230906134847777"></p><h3 id="Exception和Error有什么区别"><a href="#Exception和Error有什么区别" class="headerlink" title="Exception和Error有什么区别"></a>Exception和Error有什么区别</h3><ul><li>Exception：程序本身可以处理的异常，可以通过catch来捕获，Exception又可以分为Checked Exception和Unchecked Exception</li><li>Error：程序无法处理的错误，不建议通过catch捕获，一般异常发生时，Java虚拟机一般会选择线程终止</li></ul><h3 id="Checked-Exception和Unchecked-Exception有什么区别"><a href="#Checked-Exception和Unchecked-Exception有什么区别" class="headerlink" title="Checked Exception和Unchecked Exception有什么区别"></a>Checked Exception和Unchecked Exception有什么区别</h3><ul><li>Checked Exception受检查异常：Java在代码编译过程中，受检查异常如果没有被catch或throws的话，就没办法顺利通过编译</li><li>Unchecked Exception不受检查异常：Java在代码编译过程中，不处理不受检查异常也可以正常编译通过<ul><li>RuntimeExcepion异常及其子类都是非受检查异常</li></ul></li></ul><h3 id="Throwable类常用的方法有哪些"><a href="#Throwable类常用的方法有哪些" class="headerlink" title="Throwable类常用的方法有哪些"></a>Throwable类常用的方法有哪些</h3><ul><li><code>String getMessage()</code>: 返回异常发生时的简要描述</li><li><code>String toString()</code>: 返回异常发生时的详细信息</li><li><code>String getLocalizedMessage()</code>: 返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code>返回的结果相同</li><li><code>void printStackTrace()</code>: 在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li></ul><h3 id="Try-Catch-Finally"><a href="#Try-Catch-Finally" class="headerlink" title="Try Catch Finally"></a>Try Catch Finally</h3><ul><li>try：捕获异常</li><li>catch：处理try捕获到的异常</li><li>fianlly：不论是否捕获或者处理异常，finally快里的语句都会被执行，如果有return语句，finally代码块里的语句也会在方法返回之前执行</li></ul><blockquote><p>不要在finally中使用return语句，会覆盖try中的return语句的返回值的</p></blockquote><h3 id="finally中的代码一定会执行吗"><a href="#finally中的代码一定会执行吗" class="headerlink" title="finally中的代码一定会执行吗"></a>finally中的代码一定会执行吗</h3><ul><li>finally在执行之前虚拟机被中止了，就执行不了</li><li>程序所在的线程死亡</li><li>关闭CPU</li></ul><h3 id="异常使用需要注意的地方"><a href="#异常使用需要注意的地方" class="headerlink" title="异常使用需要注意的地方"></a>异常使用需要注意的地方</h3><ul><li>不要把异常定义为静态变量，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动 new 一个异常对象抛出。</li><li>抛出的异常信息一定要有意义。</li></ul><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h4 id="泛型的概念"><a href="#泛型的概念" class="headerlink" title="泛型的概念"></a>泛型的概念</h4><p>​泛型是JDK5引入的一个新特性，使用泛型参数，可以增强代码的可读性和稳定性</p><h4 id="泛型的使用方式"><a href="#泛型的使用方式" class="headerlink" title="泛型的使用方式"></a>泛型的使用方式</h4><ul><li>泛型类</li><li>泛型接口</li><li>泛型方法</li></ul><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt; E &gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">printArray</span><span class="hljs-params">( E[] inputArray )</span>一般被称为静态泛型方法;在 java 中泛型只是一个占位符，必须在传递类型后才能使用。类在实例化时才能真正的传递类型参数，由于静态方法的加载先于类的实例化，也就是说类中的泛型还没有传递真正的类型参数，静态的方法的加载就已经完成了，所以静态泛型方法是没有办法使用类上声明的泛型的。只能使用自己声明的&lt;E&gt;<br></code></pre></td></tr></table></figure></blockquote><h4 id="什么是泛型擦除"><a href="#什么是泛型擦除" class="headerlink" title="什么是泛型擦除"></a>什么是泛型擦除</h4><p>​Java的泛型基本上都是在编译器这个层面上执行的，在生成的字节码中是不包含泛型信息的，使用泛型的时候加上类型参数，在编译的时候会去掉，这个过程称为类型擦除，使用反射操作可以在整形数组中添加字符串</p><ul><li>既然存在类型擦除，那么Java是如何保证在ArrayList添加字符串会报错呢？<ul><li>编译器是通过先检查代码中泛型的类型，然后再进行类型擦除，然后再进行编译的</li></ul></li></ul><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><ul><li>反射赋予了我们再运行时分析类和执行类的能力，通过反射可以获取到任何一个类的属性和方法</li><li>框架中大量使用了动态代理，动态代理的实现依赖反射</li><li>Java中的注解也大量用到了反射</li></ul><h4 id="反射的优缺点"><a href="#反射的优缺点" class="headerlink" title="反射的优缺点"></a>反射的优缺点</h4><ul><li>优点：可以让代码更加灵活，为各种框架提供了开箱即用的便利</li><li>缺点：在运行时有了分析和操作类的能力，增加了安全问题<ul><li>可以无视泛型参数的安全检查</li><li>泛型的性能比较差</li></ul></li></ul><h3 id="获取class对象的四种方法"><a href="#获取class对象的四种方法" class="headerlink" title="获取class对象的四种方法"></a>获取class对象的四种方法</h3><ul><li>知道具体类的情况下：Test test &#x3D; Test.class;</li><li>通过class.forName()传入类的全路径获取：Class test &#x3D; class.forName(“com.milkboy.Test”)</li><li>通过实例对象的getClass方法获得：Test test &#x3D; test.getClass()</li><li>通过类加载器传入路径获取：Class test &#x3D; ClassLoader.getSystemClassLoader().loadClass(“com.milkboy.Test”);</li></ul><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><ul><li>注解是JDK5引入的一种新特性，可以看做做是一种特殊的注释，主要用于修饰类、方法捉着变量，提供某些信息供程序在编译或者运行时使用</li><li>注解的本质是继承了一个Annomation接口</li></ul><h4 id="注解的解析方法"><a href="#注解的解析方法" class="headerlink" title="注解的解析方法"></a>注解的解析方法</h4><ul><li>编译期直接扫描：编译器在编译Java代码的时候扫描对应的注解并处理</li><li>运行期通过反射处理：例如@Value、@Component都是通过反射处理的</li></ul><h3 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h3><ul><li>服务提供者接口：专门提供给服务者或者框架功能开发者去使用的一个接口，SPI将服务接口和具体的服务实现分离开来，将服务调用方和服务实现着解耦，能够提升程序的扩展性、可维护性。</li></ul><h4 id="SPI和API的区别"><a href="#SPI和API的区别" class="headerlink" title="SPI和API的区别"></a>SPI和API的区别</h4><ul><li><p><img src="/../picture/image-20230908092121470.png" alt="image-20230908092121470"></p></li><li><p><img src="/../picture/image-20230908092140505.png" alt="image-20230908092140505"></p></li><li><p>SPI：接口存在于调用方这边时，就是 SPI ，由接口调用方确定接口规则，然后由不同的厂商去根据这个规则对这个接口进行实现，从而提供服务。</p></li></ul><h4 id="SPI的优缺点"><a href="#SPI的优缺点" class="headerlink" title="SPI的优缺点"></a>SPI的优缺点</h4><ul><li>优点：有效提高接口的灵活性</li><li>缺点：<ul><li>遍历加载所有实现类，不能做到按需加载</li><li>当有多个ServiceLoader同时load时，会有并发问题</li></ul></li></ul><h3 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h3><ul><li>使用范围：持久化Java对象，比如说将Java对象保存在文件中，或者在网络中传输Java对象都会使用到序列化</li><li>什么是序列化，什么是反序列化<ul><li>序列化：将数据结构或对象转化为二进制字节流的过程</li><li>反序列化：将在序列化过程中所生成的二进制字节流转化成数据结构或对象</li></ul></li><li>Java中序列化的都是对象的实例</li></ul><h4 id="序列化和反序列化的应用场景"><a href="#序列化和反序列化的应用场景" class="headerlink" title="序列化和反序列化的应用场景"></a>序列化和反序列化的应用场景</h4><ul><li>对象在网络中传输时先序列化，接受到序列化之后的对象的时候再反序列化</li><li>将对象存储在文件之前序列化，从文件中提取的时候再反序列化</li><li>将对象存储在数据库(Redis)之前序列化，从数据库中读取出来的时候再反序列化</li><li>将对象存储在内存之前要进行序列化，从内存中读取的时候再反序列化</li></ul><blockquote><p><strong>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</strong></p></blockquote><ul><li>在计算机网络的7层模型中，序列化在表示层，在4层网络模型中在应用层</li></ul><h4 id="Java常见序列化协议"><a href="#Java常见序列化协议" class="headerlink" title="Java常见序列化协议"></a>Java常见序列化协议</h4><ul><li>Java自带序列化的方式：实现Serializable接口</li><li>如果不想序列化的字段，可以使用transient关键字来修饰<ul><li>使用transient修饰的变量，反序列化以后会变成这个变量的默认值</li></ul></li></ul><h4 id="不使用Java自带序列化工具的原因"><a href="#不使用Java自带序列化工具的原因" class="headerlink" title="不使用Java自带序列化工具的原因"></a>不使用Java自带序列化工具的原因</h4><ul><li>不支持跨语言调用</li><li>性能差</li><li>存在安全问题</li></ul><h4 id="推荐使用kryo序列化和反序列化工具"><a href="#推荐使用kryo序列化和反序列化工具" class="headerlink" title="推荐使用kryo序列化和反序列化工具"></a>推荐使用kryo序列化和反序列化工具</h4><ul><li>Kryo是一个高性能序列化工具，拥有变长存储的特性，并使用了字节码生成机制，拥有较高的运行速度和较小的字节码体积</li></ul><h3 id="I-x2F-O流"><a href="#I-x2F-O流" class="headerlink" title="I&#x2F;O流"></a>I&#x2F;O流</h3><ul><li>输入和输出</li></ul><h3 id="Java语法糖"><a href="#Java语法糖" class="headerlink" title="Java语法糖"></a>Java语法糖</h3><ul><li>泛型、自动拆箱和装箱、变长参数、枚举、内部类、增强for循环、try-with-resources 语法、lambda 表达式等</li></ul><h1 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h1><h2 id="Java集合一"><a href="#Java集合一" class="headerlink" title="Java集合一"></a>Java集合一</h2><h3 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h3><ul><li>Java集合也叫容器，主要是由两个接口派生而来的，一个是Collection接口，主要是存放单一元素，另一个是Map，主要是存放键值对的</li></ul><h3 id="List、Set、Queue、Map的区别"><a href="#List、Set、Queue、Map的区别" class="headerlink" title="List、Set、Queue、Map的区别"></a>List、Set、Queue、Map的区别</h3><ul><li>List：存放单一元素，存储顺序是有序的，可重复的</li><li>Set：存放独一无二的元素，存储顺序是不可重复的</li><li>Queue：队列，先进先出，存储顺序是有序且可重复的</li><li>Map：存储键值对</li></ul><h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><ul><li>List：<ul><li>ArrayList：Object[]数组</li><li>LinkedList：双向链表</li><li>Vector：Object[]数组</li></ul></li><li>Set：<ul><li>HashSet：底层HashMap</li><li>LinkedHashSet：LinkedHashMap</li><li>TreeSet：（有序、唯一）红黑树</li></ul></li><li>Map：<ul><li>HashMap：<ul><li>jkd1.8之前使用数组加链表实现，数组是主题，链表则是为了解决哈希冲突</li><li>jdk1.8之后解决哈希冲突发生了变化，当链表长度大于8时会将立案标准转化成转化成红黑树，减少搜索时间（自平衡二叉树），如果当数组长度小于64会先进行数组扩容，而不是先转化成红黑树</li></ul></li><li></li></ul></li></ul><h3 id="如何选用集合"><a href="#如何选用集合" class="headerlink" title="如何选用集合"></a>如何选用集合</h3><ul><li>根据业务场景需要，选择对应存储结构的数据结构存储</li></ul><h3 id="为什么要使用集合"><a href="#为什么要使用集合" class="headerlink" title="为什么要使用集合"></a>为什么要使用集合</h3><ul><li>集合大小可变、支持泛型、提供多种内置方法，提高了数据存储和处理的灵活性</li></ul><h3 id="ArrayList和Array的区别"><a href="#ArrayList和Array的区别" class="headerlink" title="ArrayList和Array的区别"></a>ArrayList和Array的区别</h3><ul><li>ArrayList：使用Object[]动态数组实现</li><li>ArrayList：会根据实际存储的元素动态扩容，而Array创建之后就不会扩容了</li><li>ArrayList：可以使用泛型，而Array却不可以</li><li>ArrayList：只能存储对象，对于基本数据类型，只能使用其包装类</li><li>ArrayList：提供了丰富的插入、删除、遍历等操作，而Array只是一个数组</li><li>ArrayList：创建时不需要指定大小，而Array创建时必须指定大小</li></ul><h3 id="ArrayList和Vector的区别"><a href="#ArrayList和Vector的区别" class="headerlink" title="ArrayList和Vector的区别"></a>ArrayList和Vector的区别</h3><ul><li>ArrayList是List的主要实现类，底层使用Object[]存储，适用于查找工作，不安全</li><li>Vector是List的古老实现类，底层使用Object[]存储，线程安全（使用synchronized关键字进行了同步处理）</li></ul><h3 id="ArrayList插入数据的时间复杂度"><a href="#ArrayList插入数据的时间复杂度" class="headerlink" title="ArrayList插入数据的时间复杂度"></a>ArrayList插入数据的时间复杂度</h3><ul><li>插入<ul><li>头部插入：后面的所有位置都要移动，O(n)</li><li>尾部插入：<ul><li>未达到容量上限O(1)</li><li>达到容量上限需要扩容时，O(n) —&gt; O(1)</li><li>指定位置插入O(n)</li></ul></li></ul></li><li>删除<ul><li>头部O(n)</li><li>尾部O(1)</li><li>指定位置O(n)</li></ul></li></ul><h3 id="LinkedList插入和删除的时间复杂度"><a href="#LinkedList插入和删除的时间复杂度" class="headerlink" title="LinkedList插入和删除的时间复杂度"></a>LinkedList插入和删除的时间复杂度</h3><ul><li>头部：只需要修改头结点O(1)</li><li>尾部：只需要修改尾结点O(1)</li><li>指定位置插入删除：O(n)</li></ul><h3 id="为什么LinkedList不能实现RandomAccess接口"><a href="#为什么LinkedList不能实现RandomAccess接口" class="headerlink" title="为什么LinkedList不能实现RandomAccess接口"></a>为什么LinkedList不能实现RandomAccess接口</h3><ul><li>RandomAccess是一个标记接口，用来表明实现该接口的类支持随机访问（通过索引快速访问元素），而LinkedList底层数据结构是链表，内存地址不连续，只能通过指针来访问，不支持快速访问，所以不能实现RandomAccess接口</li></ul><h3 id="LinkedList和ArrayList的区别"><a href="#LinkedList和ArrayList的区别" class="headerlink" title="LinkedList和ArrayList的区别"></a>LinkedList和ArrayList的区别</h3><ul><li>线程安全：都不安全</li><li>底层数据结构：LinkedList是双向链表，ArrayList是Object数组</li><li>插入删除元素位置是否受影响<ul><li>ArrayList：数组存储</li><li>LinkedList：链表存储</li></ul></li><li>是否支持快速访问：<ul><li>ArrayList：实现了RandomAccess接口，支持快速访问</li><li>LinkedList：没有实现RandomAccess接口，不支持快速访问</li></ul></li><li>内存占用空间：<ul><li>ArrayList：预留空间浪费</li><li>LinkedList：每一个元素消耗的更多</li></ul></li></ul><blockquote><p>项目中一般不使用LinkedList，一般都用ArrayList</p></blockquote><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ul><li>Java实现排序的方式<ul><li>Compareable接口<ul><li>重写compareTo方法</li></ul></li><li>Comparator接口<ul><li>重写compare方法</li></ul></li></ul></li></ul><h3 id="无重复性和不可重复性"><a href="#无重复性和不可重复性" class="headerlink" title="无重复性和不可重复性"></a>无重复性和不可重复性</h3><ul><li>无重复性：不按照数组索引顺序添加，而是根据数据的哈希值决定</li><li>不可重复性：添加的元素按照equals()判断，返回false，同时重写equals方法和hashCode方法</li></ul><h3 id="HashSet、LinkedHashSet、TreeSet三者的区别"><a href="#HashSet、LinkedHashSet、TreeSet三者的区别" class="headerlink" title="HashSet、LinkedHashSet、TreeSet三者的区别"></a>HashSet、LinkedHashSet、TreeSet三者的区别</h3><ul><li>都是Set接口的实现类，都无重复性，都是现成安全的</li><li>底层数据结构不同<ul><li>HashSet底层数据结构是哈希表（基于HashMap实现）</li><li>LinkedHashSet底层数据结构是链表和哈希表，元素的插入和取出顺序满足先进先出</li><li>TreeSet底层数据结构是红黑树，元素有序</li></ul></li><li>应用场景不同<ul><li>HashSet不需要保证元素的插入和取出顺序</li><li>LinkedHashSet：保证元素的插入和取出顺序满足FIFO的场景</li><li>TreeSet用于支持对元素自定义排序规则的场景</li></ul></li></ul><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><h4 id="Queue和Deque的区别"><a href="#Queue和Deque的区别" class="headerlink" title="Queue和Deque的区别"></a>Queue和Deque的区别</h4><ul><li>Queue：单端队列：元素只能从一端插入，从另一端删除，遵循先进先出的原则</li><li>当容量问题操作失败时，会有两种不同的结果</li><li><img src="/../picture/image-20230913093151716.png" alt="image-20230913093151716"></li><li>Deque：双端队列，两端都可以插入和删除</li><li><img src="/../picture/image-20230913093332370.png" alt="image-20230913093332370"></li></ul><h3 id="ArrayDeque和LinkedList的区别"><a href="#ArrayDeque和LinkedList的区别" class="headerlink" title="ArrayDeque和LinkedList的区别"></a>ArrayDeque和LinkedList的区别</h3><ul><li>相同点：都实现了Deque接口，都具有队列的功能</li><li>不同点：<ul><li>底层数据结构：ArrayDeque底层是可变长的数组和双指针，LinkedList底层是链表</li><li>ArrayDeque不支持存储null，LinkedList支持</li><li>ArrayDeque插入过程需要扩容，LinkedList不需要，但是需要申请新的堆空间，ArrayList性能相对更好一点</li></ul></li></ul><h3 id="PriorityQueue-小顶堆"><a href="#PriorityQueue-小顶堆" class="headerlink" title="PriorityQueue 小顶堆"></a>PriorityQueue 小顶堆</h3><ul><li>优先级高的元素先出队</li><li>现成不安全</li><li>小顶堆，可以接受一个Comparator构造参数，实现大顶堆</li></ul><h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><ul><li>阻塞队列，是一个接口，继承自Queue，如果队列没有元素，一直阻塞，如果队列已满，需要等到可以放入新元素的时候再放入，常用于生产者消费者模型</li></ul><h3 id="ArrayBlockQueue和LinkedBlockQueue有什么区别"><a href="#ArrayBlockQueue和LinkedBlockQueue有什么区别" class="headerlink" title="ArrayBlockQueue和LinkedBlockQueue有什么区别"></a>ArrayBlockQueue和LinkedBlockQueue有什么区别</h3><ul><li>底层实现：ArrayBlockQueue是数组，LinkedBlockQueue是链表</li><li>ArrayBlockQueue有边界，创建的时候需要制定大小，而LinkedBlockQueue不需要</li><li>ArrayBlockQueue中的锁是没有分离的，而LinkedBlockQueue是所分离的</li><li>ArrayBlockQueue需要提前分配数组内存，而LinkedBlockQueue不需要</li></ul><h2 id="集合二"><a href="#集合二" class="headerlink" title="集合二"></a>集合二</h2><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="HashMap和HashTable的区别"><a href="#HashMap和HashTable的区别" class="headerlink" title="HashMap和HashTable的区别"></a>HashMap和HashTable的区别</h4><ul><li>线程安全：HashMap是不安全的，HashTable是安全的（内部使用synchronized修饰）</li><li>效率：HashMap效率更高</li><li>初始容量和扩容量：<ul><li>创建时不指定容量<ul><li>Hashtable初始容量大小是11，每次扩容2n+1</li><li>HashMap初始容量大小是16，每次扩容2n</li></ul></li><li>创建时指定容量：<ul><li>Hashtable直接使用给定大小</li><li>HashMap会将其扩充为2的幂次方的大小</li></ul></li></ul></li><li>底层数据结构：<ul><li>HashMap：数组+链表&#x2F;数组+红黑树</li></ul></li></ul><h4 id="HashMap和HashSet的区别"><a href="#HashMap和HashSet的区别" class="headerlink" title="HashMap和HashSet的区别"></a>HashMap和HashSet的区别</h4><ul><li>HashSet底层基于HashMap实现</li><li><img src="/../picture/image-20230913111406846.png" alt="image-20230913111406846"></li></ul><h4 id="HashMap和TreeMap的区别"><a href="#HashMap和TreeMap的区别" class="headerlink" title="HashMap和TreeMap的区别"></a>HashMap和TreeMap的区别</h4><ul><li><p>都集成自AbstractMap接口</p></li><li><p>TreeMap还实现了NavigableMap接口和SortedMap接口</p><ul><li><p>NavigableMap接口：使TreeMap接口有了对集合内元素的搜索能力</p></li><li><p>SortedMap接口：有了对集合中元素根据键排序的能力，也可以实现自定义排序</p></li><li><pre><code class="java">/** * @author shuang.kou * @createTime 2020年06月15日 17:02:00 */public class Person &#123;    private Integer age;    public Person(Integer age) &#123;        this.age = age;    &#125;    public Integer getAge() &#123;        return age;    &#125;    public static void main(String[] args) &#123;        TreeMap&lt;Person, String&gt; treeMap = new TreeMap&lt;&gt;(new Comparator&lt;Person&gt;() &#123;            @Override            public int compare(Person person1, Person person2) &#123;                int num = person1.getAge() - person2.getAge();                return Integer.compare(num, 0);            &#125;        &#125;);        treeMap.put(new Person(3), &quot;person1&quot;);        treeMap.put(new Person(18), &quot;person2&quot;);        treeMap.put(new Person(35), &quot;person3&quot;);        treeMap.put(new Person(16), &quot;person4&quot;);        treeMap.entrySet().stream().forEach(personStringEntry -&gt; &#123;            System.out.println(personStringEntry.getValue());        &#125;);    &#125;&#125;</code></pre></li></ul></li></ul><h3 id="HashSet如何检查重复"><a href="#HashSet如何检查重复" class="headerlink" title="HashSet如何检查重复"></a>HashSet如何检查重复</h3><ul><li>先判断HashCode是否相等</li><li>如果相等再调用equals()方法来判断</li></ul><h3 id="HashMap的底层实现"><a href="#HashMap的底层实现" class="headerlink" title="HashMap的底层实现"></a>HashMap的底层实现</h3><ul><li>JDK1.8之前：HashMap底层是数组和链表，先通过hashcode得到hash值，然后通过(n-1)&amp;hash判断当前位置是否存在元素，如果存在元素，则判断该元素与需要存入hash值的元素的key是否相同，相同就覆盖，不相同就通过拉链法解决冲突</li><li>JDK1.8之后，当链表长度大于8时，判断一下数组长度，如果当前数组长度小于64，先进行数组扩容，如果数组长度大于64，则先将链表转化成红黑树，以减少搜索时间</li></ul><h3 id="HashMap的长度为什么是2的幂次方"><a href="#HashMap的长度为什么是2的幂次方" class="headerlink" title="HashMap的长度为什么是2的幂次方"></a>HashMap的长度为什么是2的幂次方</h3><h3 id="HashMap多线程操作导致死循环问题"><a href="#HashMap多线程操作导致死循环问题" class="headerlink" title="HashMap多线程操作导致死循环问题"></a>HashMap多线程操作导致死循环问题</h3><ul><li>在JDK1.8之前，当一个桶位中有多个元素需要进行扩容时，多个线程同时操作链表，头插法可能会指向链表中错误的位置，所以JDK11.9之后会使用尾插法，不过不建议多线程环境下使用HashMap，可能会造成数据覆盖问题</li></ul><h3 id="HashMap为什么线程不安全"><a href="#HashMap为什么线程不安全" class="headerlink" title="HashMap为什么线程不安全"></a>HashMap为什么线程不安全</h3><ul><li>当两个线程同时对一个桶中的数据进行put操作，线程1执行完哈希冲突判断，时间片消耗完了，线程2插入数据，线程1再插入，覆盖掉了线程2的数据</li></ul><h3 id="CurrentHashMap和HashTable的区别"><a href="#CurrentHashMap和HashTable的区别" class="headerlink" title="CurrentHashMap和HashTable的区别"></a>CurrentHashMap和HashTable的区别</h3><ul><li>底层数据结构：HashMap：数组+链表&#x2F;二叉树</li><li>实现线程安全的方式：<ul><li>jdk1.7之前：ConcurrentHashMap对整个桶进行了分割操作，每一把锁只加锁其中一部分数据，多线程访问容器里不同的数据段的数据，就会存在锁竞争</li><li>jdk1.8之后：并发控制使用synchronized和cas操作</li><li>hashtable（同一把锁）：synchronized来控制，效率低</li></ul></li></ul><h2 id="集合注意事项"><a href="#集合注意事项" class="headerlink" title="集合注意事项"></a>集合注意事项</h2><h3 id="集合判空"><a href="#集合判空" class="headerlink" title="集合判空"></a>集合判空</h3><ul><li>使用isEmpty，不使用size&#x3D;&#x3D;0</li><li>isEmpty可读性更好</li></ul><h3 id="集合转Map"><a href="#集合转Map" class="headerlink" title="集合转Map"></a>集合转Map</h3><ul><li>Collections.toMap</li></ul><h3 id="遍历集合"><a href="#遍历集合" class="headerlink" title="遍历集合"></a>遍历集合</h3><h3 id="集合去重"><a href="#集合去重" class="headerlink" title="集合去重"></a>集合去重</h3><ul><li>使用set特性去重</li></ul><h3 id="集合转数组"><a href="#集合转数组" class="headerlink" title="集合转数组"></a>集合转数组</h3><ul><li>Arrays.asList()</li><li>list.toArray()</li></ul><p><img src="/../picture/image-20230918215811209.png" alt="image-20230918215811209"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/09/13/Java%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE/"/>
    <url>/2023/09/13/Java%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="秒杀项目"><a href="#秒杀项目" class="headerlink" title="秒杀项目"></a>秒杀项目</h2><h3 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h3><ul><li><p>两次md5加密，前端到后端加密一次，后端到数据库再加密一次</p></li><li><p>异常处理</p></li><li><p>判断是否登录成功进行秒杀</p><ul><li><p>登录成功+cookie和session</p></li><li><p>添加cookie工具类和uuid工具类</p><ul><li>登录注册模块是怎么设计实现的</li></ul></li><li><p>分布式Session是怎么实现的</p><p><img src="/../picture/image-20230903211542908.png" alt="image-20230903211542908"></p><p><img src="/../picture/image-20230903211603160.png" alt="image-20230903211603160"></p></li></ul></li><li><p>安装redis</p><ul><li>redis五种常用的数据结构基本操作</li><li>失效时间</li><li>删除数据</li></ul></li><li><p>redis实现分布式session</p><ul><li><p>方式一</p><ul><li><p>添加依赖</p><ul><li>&#96;&#96;&#96;java<!--        redis 分布式session--><pre><code class="hljs">    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;!--对象池依赖--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;        &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;!--spring session 依赖--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;        &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;    &lt;/dependency&gt;</code></pre><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">    *</span> 写配置文件<br><br><span class="hljs-bullet">  *</span> 方式二：将用户信息拿出来，存储到redis中<br><br><span class="hljs-bullet">    *</span> 通过Validation组件来完成参数校验<br><span class="hljs-bullet">    *</span> 全局异常处理<br><br><span class="hljs-section">## 登录功能</span><br><br><span class="hljs-bullet">*</span> 两次MD5加密<br><span class="hljs-bullet">*</span> vlidation做校验判断，手机号码验证规则<br><span class="hljs-bullet">*</span> 全局异常处理<br><span class="hljs-bullet">  *</span> @ControllerAdvice和ExceptionHandler实现<br><span class="hljs-bullet">*</span> 分布式session<br><span class="hljs-bullet">  *</span> 多态服务器Nginx反向代理，多个登录，没有session，又会让用户重新登录<br><span class="hljs-bullet">  *</span> ![<span class="hljs-string">image-20230906210151873</span>](<span class="hljs-link">../picture/image-20230906210151873.png</span>)<br><br>​<br><br><span class="hljs-section">## 创建商品表和订单表</span><br><br><span class="hljs-bullet">*</span> 商品列表页<br><span class="hljs-bullet">*</span> 商品详情页<br><span class="hljs-bullet">*</span> 订单页<br><span class="hljs-bullet">*</span> 商品表<br><span class="hljs-bullet">*</span> 订单表<br><span class="hljs-bullet">*</span> 秒杀商品表<br><span class="hljs-bullet">  *</span> 方便后期处理<br><span class="hljs-bullet">  *</span> 各种活动，需要不停的加字段<br><span class="hljs-bullet">  *</span> 两个链接，原价和秒杀价一起卖<br><span class="hljs-bullet">  *</span> 和商品表的主键id关联<br><span class="hljs-bullet">*</span> 秒杀订单表<br><br><br><br><span class="hljs-section">### 建表</span><br><br><span class="hljs-bullet">*</span> 使用逆向生成工具生成基本都代码结构<br><span class="hljs-bullet">*</span> 开发商品秒杀页和商品详情页的前后端接口<br><span class="hljs-bullet">*</span> 倒计时制作<br><span class="hljs-bullet">*</span> 秒杀按钮操作<br><span class="hljs-bullet">  *</span> 开始之前不能点<br><span class="hljs-bullet">  *</span> 秒杀结束以后也不能点<br><span class="hljs-bullet">*</span> 秒杀项目实现<br><span class="hljs-bullet">  *</span> 判断库存是否有<br><span class="hljs-bullet">  *</span> 每一个用户只能买一件商品，不能重复去抢购<br><span class="hljs-bullet">  *</span> 下单，跳转到订单页面<br><br><br><br><span class="hljs-section">## 压力测试</span><br><br><span class="hljs-bullet">*</span> JMeter<br><span class="hljs-bullet">  *</span> Qps：每秒的查询率，对服务器的请求，规定时间内访问服务器测试的衡量的标准<br><span class="hljs-bullet">  *</span> Tps：对页面的一次访问<br><span class="hljs-bullet">*</span> 安装JMeter<br><span class="hljs-bullet">  *</span> 进行压力测试（商品列表页面）<br><span class="hljs-bullet">  *</span> ![<span class="hljs-string">image-20230909212241534</span>](<span class="hljs-link">../picture/image-20230909212241534.png</span>)<br><span class="hljs-bullet">  *</span> ![<span class="hljs-string">image-20230909215957722</span>](<span class="hljs-link">../picture/image-20230909215957722.png</span>)<br><span class="hljs-bullet">  *</span> ![<span class="hljs-string">image-20230909220219877</span>](<span class="hljs-link">../picture/image-20230909220219877.png</span>)<br><span class="hljs-bullet">  *</span> milkboy,d9137ecc6a6f44a3831062d16f7d7b5e<br><span class="hljs-bullet">  *</span> milkguy,9f18011804354cfbb2265d8b99ea69fb<br><br><span class="hljs-bullet">*</span> 配置不同用户<br><span class="hljs-bullet">  *</span> 准备一个csv文件<br><span class="hljs-bullet">  *</span> 通过userId和userTicket中间用,分割<br><span class="hljs-bullet">  *</span> ![<span class="hljs-string">image-20230910115518494</span>](<span class="hljs-link">../picture/image-20230910115518494.png</span>)<br><br><br><br><span class="hljs-bullet">*</span> 超买超卖问题<br><span class="hljs-bullet">  *</span> 商品详情：QPS：700多<br><span class="hljs-bullet">  *</span> 秒杀接口详情：QPS：100多<br><span class="hljs-bullet">  *</span> 数据库被打穿了，秒杀商品的时候数据库被打穿了<br><span class="hljs-bullet">  *</span> 超卖<br><br><br><br><span class="hljs-section">## 秒杀优化</span><br><br><span class="hljs-section">### 添加缓存（Redis）</span><br><br><span class="hljs-bullet">*</span> 瓶颈期最大的是数据库的操作（频繁被读取，数据更新不频繁、数据一致性问题）<br><span class="hljs-bullet">*</span> 页面缓存<br><span class="hljs-bullet">*</span> URL缓存<br><span class="hljs-bullet">*</span> 对象缓存<br><span class="hljs-bullet">*</span> 页面静态化<br><span class="hljs-bullet">*</span> 静态资源优化<br><span class="hljs-bullet">*</span> cdn优化<br><span class="hljs-bullet">*</span> 加Redis之后的优化<br><span class="hljs-bullet">  *</span> ![<span class="hljs-string">image-20230911221919061</span>](<span class="hljs-link">../picture/image-20230911221919061.png</span>)<br><span class="hljs-bullet">*</span> 页面缓存：304<br><span class="hljs-bullet">*</span> 库存超卖问题<br><br><br><br><span class="hljs-section">### 秒杀判断逻辑</span><br><br><span class="hljs-bullet">*</span> 先判断是否有用户<br><br><span class="hljs-bullet">*</span> 然后再判断是否有库存<br><br><span class="hljs-bullet">*</span> 再生成订单<br><br><span class="hljs-bullet">*</span> 生成秒杀订单<br><br><span class="hljs-bullet">*</span> 会出现超卖情况<br><br><span class="hljs-bullet">  *</span> 更新数据库的时候，先做判断<br><br><span class="hljs-bullet">    *</span> <span class="hljs-code">```java</span><br><span class="hljs-code">      seckillGoodsService.update(new UpdateWrapper&lt;SeckillGoods&gt;().set(&quot;stock_count&quot;, seckillGoods.getStockCount()).eq(&quot;id&quot;, seckillGoods.getId()).gt(&quot;stock_count&quot;, 0));</span><br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>如果一个人同时发两个请求过来，很有可能会抢购到两件商品，将用户id和商品id组合索引添加成唯一索引，解决超卖问题</p></li><li><p>判断是否重复抢购，每次都要从数据库里查询，可以放在Redis中</p></li></ul></li><li><p>解决方案</p><ul><li>扣库存的时候使用SQL语句做处理</li><li>加一个判断，每次扣之前先判断是否库存数量等于0</li><li>返回false，更新失败</li><li>加索引，防止一个人一次秒杀多个商品</li><li>判断是否重复获取，获取订单的时候从redis里获取</li></ul></li></ul><p><img src="/../picture/image-20230913151913323.png" alt="image-20230913151913323"></p><h3 id="缓存总结"><a href="#缓存总结" class="headerlink" title="缓存总结"></a>缓存总结</h3><ul><li>页面缓存</li><li>url缓存</li><li>对象缓存</li><li>库存超卖问题<ul><li>SQL语句减库存</li><li>QPS提升</li></ul></li></ul><h3 id="接口优化"><a href="#接口优化" class="headerlink" title="接口优化"></a>接口优化</h3><ul><li>接口优化</li><li>请求进入队列异步下单<ul><li>通过redis预减库存，减少数据库的访问</li><li>内存标记，减少redis访问</li><li>请求进入队列访问，异步下单</li></ul></li><li>数据库性能</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/08/26/%E7%A7%8B%E6%8B%9BSpringBoot%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/08/26/%E7%A7%8B%E6%8B%9BSpringBoot%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot-学习"><a href="#SpringBoot-学习" class="headerlink" title="SpringBoot 学习"></a>SpringBoot 学习</h1><h1 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h1><ul><li>@SpringBootApplication 告诉程序这是一个SpringBoot应用</li><li>@ResponseBody 方法中返回的内容返回给浏览器，不是跳转具体的内容</li></ul><h2 id="创建一个SpringBoot项目"><a href="#创建一个SpringBoot项目" class="headerlink" title="创建一个SpringBoot项目"></a>创建一个SpringBoot项目</h2><ul><li><p>创建一个空的Maven项目</p></li><li><p>在pox.xml中添加如下依赖</p><ul><li>&#96;&#96;&#96;xml<br><parent><br>    <groupId>org.springframework.boot</groupId><br>    <artifactId>spring-boot-starter-parent</artifactId><br>    <version>2.3.4.RELEASE</version><br></parent><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br>* 导入依赖<br><br>  * ```xml<br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>写主程序类</p><ul><li>&#96;&#96;&#96;java<br>@SpringBootApplication<br>public class MainApplication {<br>public static void main(String[] args) {<br>    SpringApplication.run(MainApplication.class, args);<br>}<br>}<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br>* 编写业务逻辑<br><br>  * ```java<br>    <span class="hljs-meta">@RestController</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br>        <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/Hello&quot;</span>)</span><br>        <span class="hljs-keyword">public</span> String Handle01() &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello World&quot;</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>执行主程序类</p></li><li><p>添加依赖</p><ul><li>&#96;&#96;&#96;xml<br><build><br>    <plugins><br>        <plugin><br>            <groupId>org.springframework.boot</groupId><br>            <artifactId>spring-boot-maven-plugin</artifactId><br>        </plugin><br>    </plugins><br></build><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stata"><br><span class="hljs-comment">* package打包部署</span><br><br><span class="hljs-comment">* ```java</span><br>  java -jar <span class="hljs-keyword">boot</span>-01-HelloWorld-1.0-SNAPSHOT.jar <span class="hljs-comment">//启动应用</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><ul><li><p>父项目用来做依赖管理：声明了开发中常用依赖的版本号</p><ul><li>&#96;&#96;&#96;xml<br>&#x2F;&#x2F; 父依赖<br><parent><br>    <groupId>org.springframework.boot</groupId><br>    <artifactId>spring-boot-starter-parent</artifactId><br>    <version>2.3.4.RELEASE</version><br></parent><br>&#x2F;&#x2F; 父依赖的父依赖  <parent>    <groupId>org.springframework.boot</groupId>    <artifactId>spring-boot-dependencies</artifactId>    <version>2.3.4.RELEASE</version>  </parent><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br>* 如果想修改对应依赖的版本，在pom.xml中添加如下代码，maven的就近优先原则<br><br>```xml<br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mysql.version</span>&gt;</span>8.0.29<span class="hljs-tag">&lt;/<span class="hljs-name">mysql.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>场景启动器：只要引入了spring-boot-starter-*，该业务需要的所有依赖都会自动引入</p><ul><li>&#96;&#96;&#96;xml<br>    <dependency><br>        <groupId>org.springframework.boot</groupId><br>        <artifactId>spring-boot-starter-web</artifactId><br>    </dependency><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br>* 所有场景启动器都会引入一个底层的场景启动器<br><br>  * ```xml<br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h2><ul><li><p>自动配置好Tomcat</p><ul><li>引入Tomcat依赖</li><li>配置Tomcat</li></ul></li><li><p>自动配置好SpringMVC</p><ul><li>引入SpringMVC全套组件</li><li>自动配置好SpringMVC常用组件</li></ul></li><li><p>自动配置好Web常见功能</p></li><li><p>默认的包结构</p><ul><li>主程序所在包及其下面的所有子包里面的组件都会被默认扫描</li><li>无需配置以前的包扫描</li><li>如果需要修改扫描的基础包，可以在主启动类程序上添加修改项</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan(&quot;com.milkboy&quot;)</span> <span class="hljs-comment">// 和下面二选一就行</span><br><span class="hljs-meta">@SpringBootApplication(scanBasePackages = &quot;com.milkboy&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ConfigurableApplicationContext</span> <span class="hljs-variable">run</span> <span class="hljs-operator">=</span> SpringApplication.run(MainApplication.class, args);<br>        String[] names = run.getBeanDefinitionNames();<br>        <span class="hljs-keyword">for</span> (String name : names) &#123;<br>            System.out.println(name);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>各种配置都有默认值配置</p><ul><li>默认配置都会映射到一个类上 MultipartProperties</li><li>配置文件最终都会绑定到某个类上，这个类会在容器中创建对象</li></ul></li><li><p>按需加载所有自动配置项</p><ul><li>非常多的starter，引入哪个，就加载哪个</li><li>引入了哪些场景，就会自动配置哪些场景</li><li>SpringBoot所有的自动配置功能都在spring-boot-autoconfigure这个包中</li></ul></li></ul><h2 id="常用注解-1"><a href="#常用注解-1" class="headerlink" title="常用注解"></a>常用注解</h2><h3 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h3><ul><li><p>将一个Java类写成一个配置类，这个配置类用来替代原来的配置文件（applicationContext.xml）</p></li><li><p>给里面的方法添加Bean标签，会在容器中创建一个名字为方法名的对象，一般用构造方法创建对象，也可以在括号中修改名字</p><ul><li>&#96;&#96;&#96;java<br>@Bean(“user001”) &#x2F;&#x2F; 以方法名作为组件的id，返回类型作为组件的类型，返回的对象就是组件在容器中的实例，支持自定义给名字<br>public User user01() {<br>    User zhangsan &#x3D; new User(“zhangsan”, 18);<br>    zhangsan.setPet(tomcatPet());<br>    return zhangsan;<br>}<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br>* 配置类本身也是一个组件，也可以从run.getBean(<span class="hljs-string">&quot;myConfig&quot;</span>, MyConfig.<span class="hljs-keyword">class</span>)中获取到<br><br>* <span class="hljs-meta">@Configuration(proxyBeanMethods = true)</span><br><br>  * 当为<span class="hljs-literal">true</span>时，表示的是SpringBoot Full模式，调用配置类新创建的对象每次都从容器中检查一下，如果有的话，就不创建新的，可用来实现**组件依赖**<br>  * 当为<span class="hljs-literal">false</span>的话，表示的是SpringBoot Lite模式，调用配置类新创建的对象每次都直接创建新的对象，不从容器中查找<br><br>  ```java<br>  <span class="hljs-keyword">package</span> com.milkboy.boot.config;<br>  <br>  <span class="hljs-keyword">import</span> com.milkboy.boot.bean.Pet;<br>  <span class="hljs-keyword">import</span> com.milkboy.boot.bean.User;<br>  <span class="hljs-keyword">import</span> org.springframework.context.<span class="hljs-keyword">annotation</span>.Bean;<br>  <span class="hljs-keyword">import</span> org.springframework.context.<span class="hljs-keyword">annotation</span>.Configuration;<br>  <br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  * 1、配置类里面使用@Bean标注在方法上给容器注册组件，默认也是单实例的</span><br><span class="hljs-comment">  * 2、配置类本身也是组件</span><br><span class="hljs-comment">  * 3、proxyBeanMethods：代理Bean的方法</span><br><span class="hljs-comment">  *   Full(proxyBeanMethods = true) 调用配置类中的对象不会创建新对象，从容器中加载</span><br><span class="hljs-comment">  *   Lite(proxyBeanMethods = false) 调用配置类中的对象会创建新对象</span><br><span class="hljs-comment">  *   组件依赖</span><br><span class="hljs-comment">  * */</span><br>  <span class="hljs-meta">@Configuration(proxyBeanMethods = true)</span> <span class="hljs-comment">//告诉SpringBoot这是一个配置类 == 配置文件</span><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  * 外界无论配置类中的这个组件注册方法调用多少次，获取的都是之前注册到容器中的单实例对象</span><br><span class="hljs-comment">  * 如果proxyBeanMethods = true， 获取到的就是代理对象，Springboot总会检查这个组建是否在容器中有，保持组件单实例</span><br><span class="hljs-comment">  * */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyConfig</span> </span>&#123;<br>  <br>      <span class="hljs-meta">@Bean(<span class="hljs-string">&quot;user001&quot;</span>)</span> <span class="hljs-comment">// 以方法名作为组件的id，返回类型作为组件的类型，返回的对象就是组件在容器中的实例，支持自定义给名字</span><br>      <span class="hljs-keyword">public</span> User user01() &#123;<br>          User zhangsan = new User(<span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">18</span>);<br>          zhangsan.setPet(tomcatPet());<br>          <span class="hljs-keyword">return</span> zhangsan;<br>      &#125;<br>  <br>      <span class="hljs-meta">@Bean</span><br>      <span class="hljs-keyword">public</span> Pet tomcatPet() &#123;<br>          <span class="hljs-keyword">return</span> new Pet(<span class="hljs-string">&quot;tomcat&quot;</span>);<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.milkboy.boot;<br><br><span class="hljs-keyword">import</span> com.milkboy.boot.bean.Pet;<br><span class="hljs-keyword">import</span> com.milkboy.boot.bean.User;<br><span class="hljs-keyword">import</span> com.milkboy.boot.config.MyConfig;<br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.context.ConfigurableApplicationContext;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.ComponentScan;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 告诉SpringBoot这是一个SpringBoot应用</span><br><span class="hljs-comment">* */</span><br><span class="hljs-comment">//@ComponentScan(&quot;com.milkboy&quot;)</span><br><span class="hljs-comment">//@SpringBootApplication(scanBasePackages = &quot;com.milkboy&quot;)</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ConfigurableApplicationContext</span> <span class="hljs-variable">run</span> <span class="hljs-operator">=</span> SpringApplication.run(MainApplication.class, args);<br>        String[] names = run.getBeanDefinitionNames();<br>        <span class="hljs-keyword">for</span> (String name : names) &#123;<br>            System.out.println(name);<br>        &#125;<br><span class="hljs-comment">//        User user001 = run.getBean(&quot;user001&quot;, User.class);</span><br><span class="hljs-comment">//        User user002 = run.getBean(&quot;user001&quot;, User.class);</span><br><span class="hljs-comment">//        System.out.println(user001 == user002);</span><br>        <span class="hljs-type">MyConfig</span> <span class="hljs-variable">myConfig</span> <span class="hljs-operator">=</span> run.getBean(<span class="hljs-string">&quot;myConfig&quot;</span>, MyConfig.class);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> myConfig.user01();<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> myConfig.user01();<br>        System.out.println(user == user1);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user001</span> <span class="hljs-operator">=</span> run.getBean(<span class="hljs-string">&quot;user001&quot;</span>, User.class);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user002</span> <span class="hljs-operator">=</span> run.getBean(<span class="hljs-string">&quot;user001&quot;</span>, User.class);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user003</span> <span class="hljs-operator">=</span> run.getBean(<span class="hljs-string">&quot;user001&quot;</span>, User.class);<br>        <span class="hljs-type">Pet</span> <span class="hljs-variable">tom</span> <span class="hljs-operator">=</span> run.getBean(<span class="hljs-string">&quot;tomcatPet&quot;</span>, Pet.class);<br>        System.out.println(user001 == user002);<br><span class="hljs-comment">//        System.out.println(tom);</span><br><span class="hljs-comment">//        System.out.println(user003.getPet() == tom);</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h3><ul><li><p>在配置类或者其他Component上导入其他类，调用其他类的无参构造函数，加载到容器中</p></li><li><p>&#96;&#96;&#96;java<br>@Import(User.class)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br>* 给容器中创建出User这个类型的组件，默认的名字就是全类名<br><br>### <span class="hljs-meta">@Conditional</span><br><br>* 条件装配：满足Conditional指定的条件，则进行组件注入<br>* 可以加在方法上，也可以加在类上，加在类上就是所有的方法都满足的话，容器中才会加载，加载方法上，就判断条件只对当前方法生效<br><br>### <span class="hljs-meta">@ImportResource(<span class="hljs-string">&quot;classpath:beans.xml&quot;</span>)</span><br><br>* 将Spring中的beans.xml配置文件注入到容器中<br><br>### <span class="hljs-meta">@ConfigurationProperties(prefix = <span class="hljs-string">&quot;mycar&quot;</span>)</span><br><br>* 方法一：Component+ConfigurationProperties<br><br>  * 加载配置文件中的数据<br><br>  * ![image-<span class="hljs-number">20230805113840107</span>](../picture/image-<span class="hljs-number">20230805113840107.</span>png)<br><br>  * ![image-<span class="hljs-number">20230805113858420</span>](../picture/image-<span class="hljs-number">20230805113858420.</span>png)<br><br>* 方法二：<br><br>  * 配置类上写：<span class="hljs-meta">@EnableConfigurationProperties(Car.class)</span><br>  * 实体类上写：<span class="hljs-meta">@ConfigurationProperties(prefix = <span class="hljs-string">&quot;mycar&quot;</span>)</span><br>  * 第一步是<br><br><br><br>## 自动配置原理<br><br>```java<br><span class="hljs-meta">@SpringBootConfiguration</span><br><span class="hljs-meta">@EnableAutoConfiguration</span><br><span class="hljs-meta">@ComponentScan(</span><br><span class="hljs-meta">    excludeFilters = &#123;@Filter(</span><br><span class="hljs-meta">    type = FilterType.CUSTOM,</span><br><span class="hljs-meta">    classes = &#123;TypeExcludeFilter.class&#125;</span><br><span class="hljs-meta">)</span>, <span class="hljs-meta">@Filter(</span><br><span class="hljs-meta">    type = FilterType.CUSTOM,</span><br><span class="hljs-meta">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span><br><span class="hljs-meta">)</span>&#125;<br>)<br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootApplication &#123;&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h3><ul><li>代表当前是一个配置类</li></ul><h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><ul><li>指定我们要扫描哪个包</li></ul><h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoConfigurationPackage</span><br><span class="hljs-meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><br></code></pre></td></tr></table></figure><ul><li><p>@AutoConfigurationPackage：自动配置包</p><ul><li><pre><code class="hljs">@Import(&#123;AutoConfigurationPackages.Registrar.class&#125;)public @interface AutoConfigurationPackage &#123;&#125;<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-operator"></span><br><span class="hljs-operator">  * </span>利用Registrar给容器中导入一系列组件，把一个包下的所有组件批量注册进来<span class="hljs-operator"></span><br><span class="hljs-operator"></span><br><span class="hljs-operator">* </span>@<span class="hljs-constructor">Import(&#123;AutoConfigurationImportSelector.<span class="hljs-params">class</span>&#125;)</span> 利用Selector这个机制，给容器中继续批量导入<span class="hljs-operator"></span><br><span class="hljs-operator"></span><br><span class="hljs-operator">  * </span>```java<br>    this.get<span class="hljs-constructor">AutoConfigurationEntry(<span class="hljs-params">annotationMetadata</span>)</span>; <span class="hljs-comment">// 利用这个方法给容器中批量导入一些组件</span><br>    List&lt;String&gt; configurations = this.get<span class="hljs-constructor">CandidateConfigurations(<span class="hljs-params">annotationMetadata</span>, <span class="hljs-params">attributes</span>)</span>; <span class="hljs-comment">// 获取到所有需要调用到容器中的配置类</span><br></code></pre></td></tr></table></figure></code></pre></li><li><p>实质上加载的是spring-boot-autoconfigure-2.3.4.RELEASE.jar&#x2F;META-INF&#x2F;spring.factories</p></li><li><p>&#96;&#96;&#96;xml</p></li></ul><h1 id="Auto-Configure"><a href="#Auto-Configure" class="headerlink" title="Auto Configure"></a>Auto Configure</h1><p>  org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;<br>  org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,<br>  org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,<br>  org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,<br>  org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,<br>  org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,<br>  org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,<br>  org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,<br>  org.springframework.boot.autoconfigure.context.LifecycleAutoConfiguration,<br>  org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,<br>  org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,<br>  org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,<br>  org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,<br>  org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,<br>  org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,<br>  org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,<br>  org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,<br>  org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,<br>  org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration,<br>  org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration,<br>  org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,<br>  org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,<br>  org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,<br>  org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRepositoriesAutoConfiguration,<br>  org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRestClientAutoConfiguration,<br>  org.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration,<br>  org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,<br>  org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,<br>  org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,<br>  org.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration,<br>  org.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration,<br>  org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,<br>  org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,<br>  org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,<br>  org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,<br>  org.springframework.boot.autoconfigure.data.r2dbc.R2dbcDataAutoConfiguration,<br>  org.springframework.boot.autoconfigure.data.r2dbc.R2dbcRepositoriesAutoConfiguration,<br>  org.springframework.boot.autoconfigure.data.r2dbc.R2dbcTransactionManagerAutoConfiguration,<br>  org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,<br>  org.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,<br>  org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,<br>  org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,<br>  org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,<br>  org.springframework.boot.autoconfigure.elasticsearch.ElasticsearchRestClientAutoConfiguration,<br>  org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,<br>  org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,<br>  org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,<br>  org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,<br>  org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,<br>  org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,<br>  org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,<br>  org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,<br>  org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration,<br>  org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration,<br>  org.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration,<br>  org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,<br>  org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,<br>  org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,<br>  org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,<br>  org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,<br>  org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,<br>  org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,<br>  org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,<br>  org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,<br>  org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,<br>  org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,<br>  org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,<br>  org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,<br>  org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,<br>  org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,<br>  org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration,<br>  org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,<br>  org.springframework.boot.autoconfigure.availability.ApplicationAvailabilityAutoConfiguration,<br>  org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,<br>  org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,<br>  org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,<br>  org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,<br>  org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,<br>  org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,<br>  org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,<br>  org.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration,<br>  org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,<br>  org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,<br>  org.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration,<br>  org.springframework.boot.autoconfigure.r2dbc.R2dbcAutoConfiguration,<br>  org.springframework.boot.autoconfigure.rsocket.RSocketMessagingAutoConfiguration,<br>  org.springframework.boot.autoconfigure.rsocket.RSocketRequesterAutoConfiguration,<br>  org.springframework.boot.autoconfigure.rsocket.RSocketServerAutoConfiguration,<br>  org.springframework.boot.autoconfigure.rsocket.RSocketStrategiesAutoConfiguration,<br>  org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,<br>  org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration,<br>  org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration,<br>  org.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration,<br>  org.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration,<br>  org.springframework.boot.autoconfigure.security.rsocket.RSocketSecurityAutoConfiguration,<br>  org.springframework.boot.autoconfigure.security.saml2.Saml2RelyingPartyAutoConfiguration,<br>  org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,<br>  org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,<br>  org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration,<br>  org.springframework.boot.autoconfigure.security.oauth2.client.reactive.ReactiveOAuth2ClientAutoConfiguration,<br>  org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration,<br>  org.springframework.boot.autoconfigure.security.oauth2.resource.reactive.ReactiveOAuth2ResourceServerAutoConfiguration,<br>  org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,<br>  org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration,<br>  org.springframework.boot.autoconfigure.task.TaskSchedulingAutoConfiguration,<br>  org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,<br>  org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,<br>  org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,<br>  org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,<br>  org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration,<br>  org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration,<br>  org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration,<br>  org.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration,<br>  org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,<br>  org.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration,<br>  org.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfiguration,<br>  org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,<br>  org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,<br>  org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,<br>  org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,<br>  org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,<br>  org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,<br>  org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,<br>  org.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration,<br>  org.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration,<br>  org.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration,<br>  org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration,<br>  org.springframework.boot.autoconfigure.webservices.client.WebServiceTemplateAutoConfiguration<br>  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">*</span> 默认全部加载，实际上会按需配置<br><span class="hljs-bullet">  *</span> 虽然127个场景的所有自动配置启动的时候都会默认全部加载，但是按照条件装配规则，最终会按需配置<br><span class="hljs-bullet">  *</span> 使用ConditionalOnClass 这个条件装配注解来限制加载<br><br><span class="hljs-section">### 总结：</span><br><br><span class="hljs-bullet">*</span> SpringBoot先加载所有的自动配置类<br><span class="hljs-bullet">*</span> 每个自动配置类按照条件进行生效，默认都会绑定配置文件制定的值。从xxxxProperties里面拿，xxxxProperties和配置文件进行绑定<br><span class="hljs-bullet">*</span> 生效的配置类就会给容器中装配很多组件<br><span class="hljs-bullet">*</span> 只要容器中有这些组件，相当于这些功能就有了<br><span class="hljs-bullet">*</span> 只要用户有自己配置的，就以用户配置的优先<br><span class="hljs-bullet">*</span> 定制化配置：<br><span class="hljs-bullet">  *</span> 用户直接自己在配置类里@Bean写一个组件，替换原生组件<br><span class="hljs-bullet">  *</span> 用户去看这个组件是获取的配置文件的什么值，修改配置文件中的值就行<br><span class="hljs-bullet">  *</span> xxxxAutoConfiguration ----&gt; 自动装配所有组件 ----&gt; 组件再从xxxxProperties里面拿值 ----&gt; xxxxProperties的值再和application.properties绑定，所以就是从application.properties里面拿值<br><br>![<span class="hljs-string">image-20230805184934424</span>](<span class="hljs-link">../picture/image-20230805184934424.png</span>)<br><br><span class="hljs-section">### Lombok</span><br><br><span class="hljs-bullet">*</span> 导入依赖<br><span class="hljs-bullet">*</span> 安装插件<br><span class="hljs-bullet">*</span> 添加注解<br><span class="hljs-bullet">  *</span> @Slf4j 日志<br><span class="hljs-bullet">  *</span> ToString<br><br><span class="hljs-section">### devtools</span><br><br><span class="hljs-bullet">*</span> 热更新<br><span class="hljs-bullet">*</span> 重启应用<br><br><span class="hljs-section">### Spring-Initailizr</span><br><br><span class="hljs-bullet">*</span> 创建SpringBoot项目<br><br><br><br><span class="hljs-section">## YAML</span><br><br><br><br><span class="hljs-section">## Web</span><br><br></code></pre></td></tr></table></figure></p></li></ul><p>spring:<br>  mvc:<br>    static-path-pattern: &#x2F;res&#x2F;**   &#x2F;&#x2F; 此功能会影响index.html和favicon.icon<br>        &#x2F;&#x2F; 静态资源加前缀<br>  resources:<br>    static-locations:<br>    &#x2F;&#x2F; 映射资源</p><figure class="highlight golo"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs golo"><br>* 只要静态资源放在类路径下： called `/static` (or `/public` or `/resources` or `/META-INF/resources`<br><br>* 访问 ： 当前项目根路径/ + 静态资源名 <br><br>* 原理： 静态映射/**。<br><br>  请求进来，先去找Controller看能不能处理。不能处理的所有请求又都交给静态资源处理器。静态资源也找不到则响应<span class="hljs-number">404</span>页面<br><br><br><br>![image<span class="hljs-number">-20230815172208524</span>](../picture/image<span class="hljs-number">-20230815172208524.</span>png)<br><br>* add-mappings<br>  * <span class="hljs-literal">true</span> // 开启静态资源<br>  * <span class="hljs-literal">false</span> // 关闭静态资源<br><br>* 静态资源都有缓存策略<br><br><br><br><span class="hljs-comment">### 发送请求当中的注解</span><br><br>![image<span class="hljs-number">-20230816112613935</span>](../picture/image<span class="hljs-number">-20230816112613935.</span>png)<br><br>* PathVariable：请求路径里的参数 /car/&#123;id&#125;<br>* RequestHeader：请求头信息<br>* RequestParam：url中的请求参数 /car?age=<span class="hljs-number">18</span><br>* CookieValue：获取到元素中Cookie的值<br>* RequestBody：请求体中的数据，使用JSON数据发送请求<br><br>```java<br>package com.milkboy.boot.controller;<br><br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.*;<br><br><span class="hljs-keyword">import</span> javax.servlet.http.Cookie;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-meta">@RestController</span><br>public class ParameterTestController &#123;<br>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">&quot;/car/&#123;id&#125;/owner/&#123;username&#125;&quot;</span>)<br>    public Map&lt;String, Object&gt; getCar(<span class="hljs-meta">@PathVariable</span>(<span class="hljs-string">&quot;id&quot;</span>) Integer id,<br>                                      <span class="hljs-meta">@PathVariable</span>(<span class="hljs-string">&quot;username&quot;</span>) String name,<br>                                      <span class="hljs-meta">@PathVariable</span> Map&lt;String, String&gt; pv,            <span class="hljs-meta">@RequestHeader</span>(<span class="hljs-string">&quot;User-Agent&quot;</span>) String userAgent,<br>                                      <span class="hljs-meta">@RequestHeader</span> Map&lt;String, String&gt; header,<br>                                      <span class="hljs-meta">@RequestParam</span>(<span class="hljs-string">&quot;age&quot;</span>) Integer age,<br>                                      <span class="hljs-meta">@RequestParam</span> List&lt;String&gt; inters,<br>                                      <span class="hljs-meta">@RequestParam</span> Map&lt;String, String&gt; params<br>                                      ) &#123;<br>        Map&lt;String, Object&gt; <span class="hljs-keyword">map</span> = new HashMap&lt;&gt;();<br>        <span class="hljs-keyword">map</span>.put(<span class="hljs-string">&quot;id&quot;</span>, id);<br>        <span class="hljs-keyword">map</span>.put(<span class="hljs-string">&quot;name&quot;</span>, name);<br>        <span class="hljs-keyword">map</span>.put(<span class="hljs-string">&quot;pv&quot;</span>, pv);<br>        <span class="hljs-keyword">map</span>.put(<span class="hljs-string">&quot;useragent&quot;</span>, userAgent);<br>        <span class="hljs-keyword">map</span>.put(<span class="hljs-string">&quot;header&quot;</span>, header);<br>        <span class="hljs-keyword">map</span>.put(<span class="hljs-string">&quot;age&quot;</span>, age);<br>        <span class="hljs-keyword">map</span>.put(<span class="hljs-string">&quot;list&quot;</span>, inters);<br>        <span class="hljs-keyword">map</span>.put(<span class="hljs-string">&quot;params&quot;</span>, params);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">map</span>;<br>    &#125;<br>    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">&quot;/save&quot;</span>)<br>    public Map postMethod(<span class="hljs-meta">@RequestBody</span> String context) &#123;<br>        Map&lt;String, Object&gt; <span class="hljs-keyword">map</span> = new HashMap&lt;&gt;();<br>        <span class="hljs-keyword">map</span>.put(<span class="hljs-string">&quot;context&quot;</span>, context);<br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-keyword">map</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">map</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>@RequestAttribute：请求域属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RequestController</span> &#123;<br>    <span class="hljs-meta">@GetMapping(&quot;/goto&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">goToPage</span><span class="hljs-params">(HttpServletRequest request)</span> &#123;<br>        request.setAttribute(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>);<br>        request.setAttribute(<span class="hljs-string">&quot;code&quot;</span>, <span class="hljs-string">&quot;200&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;forward:/success&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-meta">@GetMapping(&quot;/success&quot;)</span><br>    <span class="hljs-keyword">public</span> Map <span class="hljs-title function_">success</span><span class="hljs-params">(<span class="hljs-meta">@RequestAttribute(&quot;msg&quot;)</span> String msg, <span class="hljs-meta">@RequestAttribute(&quot;code&quot;)</span> Integer code, HttpServletRequest request)</span> &#123;<br>        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;anno_msg&quot;</span>, msg);<br>        map.put(<span class="hljs-string">&quot;code&quot;</span>, code);<br>        map.put(<span class="hljs-string">&quot;req_msg&quot;</span>, request.getAttribute(<span class="hljs-string">&quot;msg&quot;</span>));<br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>矩阵变量：使用分号区分，相当于给路径加了一个判断条件<ul><li>默认禁用</li></ul></li><li>Map、 Model中放参数，会相当于在请求域中加内容</li></ul><h3 id="响应当中的注解"><a href="#响应当中的注解" class="headerlink" title="响应当中的注解"></a>响应当中的注解</h3><ul><li>@ResponseBody：在方法上添加ResponseBody，就能返回JSON数据，数据直接响应出去，而不是返回页面</li></ul><h3 id="内容协商功能：让不同的端获取不同的返回数据类型"><a href="#内容协商功能：让不同的端获取不同的返回数据类型" class="headerlink" title="内容协商功能：让不同的端获取不同的返回数据类型"></a>内容协商功能：让不同的端获取不同的返回数据类型</h3><ul><li>根据客户端能力不同，自动的处理出数据（请求头不同）</li><li>请求头重的Accept来决定</li></ul><h3 id="浏览器内容协商"><a href="#浏览器内容协商" class="headerlink" title="浏览器内容协商"></a>浏览器内容协商</h3><p><img src="/../picture/image-20230817170637959.png" alt="image-20230817170637959"></p><ul><li>开启基于请求参数的内容协商<ul><li>&#x2F;user?format&#x3D;xml：返回xml数据</li><li>&#x2F;user?format&#x3D;json：返回json数据</li></ul></li><li>自定义协议数据</li></ul><h2 id="拦截请求"><a href="#拦截请求" class="headerlink" title="拦截请求"></a>拦截请求</h2><h3 id="HandlerInterceptor"><a href="#HandlerInterceptor" class="headerlink" title="HandlerInterceptor"></a>HandlerInterceptor</h3><p><img src="/../picture/image-20230824112524969.png" alt="image-20230824112524969"></p><ul><li>拦截器请求的时候一般先写一个拦截器的类，实现handlerInterceptor接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.milkboy.boot03webadmin.interceptor;<br><br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.ModelAndView;<br><br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpSession;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 登录检查</span><br><span class="hljs-comment">* */</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-comment">// 目标方法执行前</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">requestURI</span> <span class="hljs-operator">=</span> request.getRequestURI();<br>        log.info(<span class="hljs-string">&quot;拦截的路径是：&quot;</span> + requestURI);<br>        <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> request.getSession();<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">loginUser</span> <span class="hljs-operator">=</span> session.getAttribute(<span class="hljs-string">&quot;loginUser&quot;</span>);<br>        <span class="hljs-keyword">if</span>(loginUser != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        session.setAttribute(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;请先登录&quot;</span>);<br>        response.sendRedirect(<span class="hljs-string">&quot;/&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 目标方法执行完</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        HandlerInterceptor.<span class="hljs-built_in">super</span>.postHandle(request, response, handler, modelAndView);<br>    &#125;<br><br>    <span class="hljs-comment">// 页面渲染后</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        HandlerInterceptor.<span class="hljs-built_in">super</span>.afterCompletion(request, response, handler, ex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>然后再写一个配置类，将拦截器注入到容器中，实现WebMvcConfigurer中的addInterceptor方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.milkboy.boot03webadmin.config;<br><br><span class="hljs-keyword">import</span> com.milkboy.boot03webadmin.interceptor.LoginInterceptor;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Configurable;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AdminWebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginInterceptor</span>())<br>                .addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>)<br>                .excludePathPatterns(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-string">&quot;/login&quot;</span>,<span class="hljs-string">&quot;/css/**&quot;</span>, <span class="hljs-string">&quot;/images/**&quot;</span>, <span class="hljs-string">&quot;/js/**&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.milkboy.boot03webadmin.controller;<br><br><span class="hljs-keyword">import</span> com.sun.org.apache.xpath.internal.operations.Mult;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PostMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestParam;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestPart;<br><span class="hljs-keyword">import</span> org.springframework.web.multipart.MultipartFile;<br><br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FormTestController</span> &#123;<br>    <span class="hljs-meta">@GetMapping(&quot;/form_layouts&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">form_layouts</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;form/form_layouts&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@PostMapping(&quot;/upload&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">upload</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;email&quot;)</span> String email,</span><br><span class="hljs-params">                         <span class="hljs-meta">@RequestParam(&quot;username&quot;)</span> String username,</span><br><span class="hljs-params">                         <span class="hljs-meta">@RequestPart(&quot;headerImg&quot;)</span>MultipartFile headerImg,</span><br><span class="hljs-params">                         <span class="hljs-meta">@RequestPart(&quot;photos&quot;)</span>MultipartFile[] photos)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">if</span>(!headerImg.isEmpty()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">originalFilename</span> <span class="hljs-operator">=</span> headerImg.getOriginalFilename();<br>            headerImg.transferTo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/Users/milkboy/Desktop/images/&quot;</span> + originalFilename));<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(photos.length &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">for</span> (MultipartFile photo : photos) &#123;<br>                <span class="hljs-keyword">if</span>(!photo.isEmpty()) &#123;<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">originalFilename</span> <span class="hljs-operator">=</span> photo.getOriginalFilename();<br>                    photo.transferTo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/Users/milkboy/Desktop/images/&quot;</span> + originalFilename));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;main&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><ul><li>error文件夹下放4xx.html和5xx.html就可以了</li></ul><h2 id="Web原生引入"><a href="#Web原生引入" class="headerlink" title="Web原生引入"></a>Web原生引入</h2><h2 id="数据访问层的开发"><a href="#数据访问层的开发" class="headerlink" title="数据访问层的开发"></a>数据访问层的开发</h2><ul><li>导入jdbc场景</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>依赖注入数据源</li></ul><p>彭璐 北京计算机技术及应用研究所 100039</p><p>彭璐（1987-），北京人，主要研究领域为软件开发、企业信息化。<a href="mailto:&#x70;&#101;&#110;&#103;&#108;&#117;&#x31;&#57;&#x38;&#55;&#x30;&#50;&#64;&#49;&#50;&#54;&#x2e;&#99;&#x6f;&#x6d;">&#x70;&#101;&#110;&#103;&#108;&#117;&#x31;&#57;&#x38;&#55;&#x30;&#50;&#64;&#49;&#50;&#54;&#x2e;&#99;&#x6f;&#x6d;</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/07/28/AI%E5%A4%A7%E6%A8%A1%E5%9E%8B/"/>
    <url>/2023/07/28/AI%E5%A4%A7%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<ul><li>一是生成式人工智能服务，主要是辅助编辑、改写、润色，帮助用户撰写更优质的文章；</li><li>二是阅读理解和问答，基于已储备的语料做问答式交互，辅助阅读和知识检索；</li><li>三是人机交互，基于大语言模型技术做下一代基于自然语言的人机交互。</li></ul><p>题目</p><p>题目介绍：阐述介绍题目需求</p><p>其他</p><p>资源保障</p><ul><li><p>专家指导</p></li><li><p>技术支持</p></li><li><p>其他</p></li></ul><p>行业大模型在办公领域的应用</p><p>办公的应用场景</p><p>两三个</p><p>成果两三个</p><p>应用场景，应用原型</p><ul><li>可以为用户提供特定领域构建语料进行量身定制的训练服务，并提供可私有化部署的大语言模型。有效解决语料数据的领域局限性及保密性，在保证数据安全的情况下不断提升领域大语言模型的质量。</li><li>依托海势语料生成平台，构建高效、高质量的语料来源；在开源模型上进行增量训练、并根据业务需求进行指令微调，为用户量身定制大语言模型；定位于专业领域及行业应用，与业务需求结合构建基于大模型的应用场景；</li></ul><h2 id="AI大模型赋能智能办公系统优化与创新"><a href="#AI大模型赋能智能办公系统优化与创新" class="headerlink" title="AI大模型赋能智能办公系统优化与创新"></a>AI大模型赋能智能办公系统优化与创新</h2><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p>​在当今信息时代，人工智能技术的迅猛发展给各个领域带来了巨大的机遇和挑战。在人工智能的领域中，大模型技术作为一种强大的工具和方法，正在成为学术界和工业界关注的焦点。大模型技术的崛起和快速发展引发了广泛的兴趣和研究，为各行各业的创新和发展带来了新的可能性。在办公领域，AI大模型的应用正在为企业和组织带来前所未有的机遇。这些大模型如GPT-3、BERT等，在自然语言处理和文本生成方面表现出色，为办公系统带来智能化和高效化的新方案。本课题将探讨AI大模型在办公领域的应用与创新，聚焦于如何优化办公系统，推动企业的发展与创新。</p><h3 id="选题意义"><a href="#选题意义" class="headerlink" title="选题意义"></a>选题意义</h3><p>​AI大模型在办公系统领域的应用具有重要的意义，对企业和员工都带来了许多益处。首先，它能显著提高工作效率，通过自动化和智能化的方式处理诸如文档生成、邮件回复、日程管理等繁琐办公任务，从而减轻员工的负担，使他们能够更专注于更有创造性和战略性的工作，提高整体工作效率。其次，AI大模型可以为用户提供特定领域构建语料进行量身定制的训练服务，为用户提供可根据用户需求量身定制的专用大模型。AI大模型还在内容生成和创意激发方面有十分广阔的应用场景，为企业带来新颖的创意和灵感，推动企业的创新发展，增强市场竞争力。智能知识管理也得到提升，AI大模型帮助企业自动提取和整理大量信息和文档，为员工提供快速的知识检索和答疑服务，促进团队协作效率。AI大模型对出现，为办公领域提供了新的创新与发展。</p><h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>内容生成，</p><ul><li>​人机交互</li></ul><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><h3 id="拟解决问题和关键技术指标"><a href="#拟解决问题和关键技术指标" class="headerlink" title="拟解决问题和关键技术指标"></a>拟解决问题和关键技术指标</h3><ol><li><p>生成式人工智能服务：</p><p>利用大语言模型的指令执行能力及文字理解能力和表达能力，针对具体工作报告、文章等内容进行定制化的训练，实现根据用户的指令、要求生成相应的内容，例如帮助用户进行头脑风暴、写提纲、写会议议程、创作故事等，还可对已有内容进行续写、总结或结构优化调整等。</p><ul><li>文本生成准确性：确保模型生成的文本内容语法正确、流畅自然，减少错误信息。</li><li>任务覆盖范围：模型能够涵盖各种常见的办公任务，满足不同场景的需求。</li><li>文本生成速度：模型响应速度要快，以提高办公效率，减少等待时间。</li></ul></li><li><p>通用大模型与专用大模型结合：大模型以训练基础设施及底层技术构成的技术底座为基点，在海量通用数据上进行预训练，集成多样化的 AI 核心技术，又能够结合用户的垂直场景及应用行业需求进行模型微调和应用适配，为用户提供特定领域构建语料进行量身定制的训练服务，并支持可私有化部署的大语言模型。关键技术指标：</p><ul><li><p>模型微调和定制：支持用户根据自身业务场景，为用户提供针对用户专业领域的专用大模型。</p></li><li><p>私有化部署：支持针对特定用户应用场景模型的私有化部署，并适配国产操作系统。</p></li></ul></li><li><p>人机交互服务：利用大语言模型的文字理解能力和表达能力，结合向量数据库的高效检索能力，将本地文档库转化成知识库，为用户进行答疑解惑。</p></li><li><p>智能决策支持：AI大模型可以为企业的决策过程提供智能支持，分析数据、提供决策建议和预测。关键技术指标包括：</p><ul><li><p>数据分析准确性：模型能够准确分析和处理大量复杂数据，提供精准的数据分析结果。</p></li><li><p>决策建议准确性：模型提供的决策建议要准确，帮助企业做出明智的决策。</p></li><li><p>数据处理效率：模型处理数据的速度要快，以及时为决策提供支持。</p></li></ul></li><li><p>创意激发和创新：AI大模型可以在内容创作和创意激发方面提供帮助，为企业带来创新思路和灵感。关键技术指标包括：</p><ul><li><p>创意输出多样性：模型能够提供丰富多样的创意和内容，避免重复和单一性。</p></li><li><p>创意质量评估：模型输出的创意要具有一定的质量和实用性，能够符合实际需求。</p></li><li><p>创意生成速度：模型生成创意的速度要快，以满足企业对创意的快速需求。</p></li></ul></li><li><p>隐私保护和安全性：在应用AI大模型的过程中，确保用户数据的隐私保护和系统的安全性非常关键。关键技术指标包括：</p><ul><li><p>数据隐私保护：模型能够保障用户数据的安全，防止未经授权的数据泄露。</p></li><li><p>系统防护能力：确保办公系统具备足够的防护措施，防止恶意攻击和数据侵入。</p></li><li><p>模型可解释性：模型的决策过程和输出能够解释和理解，增加用户对模型应用的信任。</p></li></ul></li></ol><h3 id="GPT的使用面临几个问题："><a href="#GPT的使用面临几个问题：" class="headerlink" title="GPT的使用面临几个问题："></a>GPT的使用面临几个问题：</h3><ul><li>一、国产化条件面临算力、模型优化问题；</li><li>二、局域网使用面临的训练问题；</li><li>三、面临的涉密问题，跨网访问问题。</li></ul><h3 id="意义："><a href="#意义：" class="headerlink" title="意义："></a>意义：</h3><ul><li>一、院里应该也必须掌握大模型建立技术；</li><li>二、院里要跟上人工智能时代，应该也必须为用户提供技术和产品服务；</li><li>三、面向党、政、军、企市场，有很好的经济和社会效益。</li></ul><p>题目介绍里要通过问题引出需求，同时根据需求写出这个项目要干的事。</p><h2 id="AI大模型赋能党政军企信息化建设"><a href="#AI大模型赋能党政军企信息化建设" class="headerlink" title="AI大模型赋能党政军企信息化建设"></a>AI大模型赋能党政军企信息化建设</h2><p>题目</p><p>题目介绍：阐述介绍题目需求</p><h2 id="题目介绍-1"><a href="#题目介绍-1" class="headerlink" title="题目介绍"></a>题目介绍</h2><p>​在当今信息时代，人工智能技术的迅猛发展给各个领域带来了巨大的机遇和挑战。在人工智能的领域中，大模型技术作为一种强大的工具和方法，正在成为学术界和工业界关注的焦点。大模型技术的崛起和快速发展引发了广泛的兴趣和研究，为各行各业的创新和发展带来了新的可能性。然而，大模型高算力的刚需提高了行业进入门槛，同时也对生态环境造成了极大的影响，如何优化模型成为我们急需解决的问题。正如习总书记所说，当今世界正经历百年未有之大变局，大国竞争在很大程度上已经演变成信息竞争，在中美形式日益严峻的背景下，美国禁止了中国大陆和港澳用户对chatGPT的访问，训练自主安全可控的大模型迫在眉睫。在互联网高速发展的今天，数据泄露和信息丢失问题日益凸显，然而大模型的训练与应用过程会伴随着大量的个人数据和敏感信息，如何在内网环境下安全高效的训练和使用模型成为我们工作的重点，作为科技强国，航天报国的主力军的我们，肩负着民族复兴的伟大重任，持续加强解决在人工智能大背景下大模型产业链技术的“卡脖子”问题成为我们当下工作的重点。</p><h2 id="选题意义-1"><a href="#选题意义-1" class="headerlink" title="选题意义"></a>选题意义</h2><p>​伴随着OpenAI公司GPT-3的推出，大模型正式进入了爆发阶段，以百度、阿里、腾讯、华为为代表的中国互联网头部企业都开始训练自己的私有化模型，大模型技术在科学研究、医疗健康、办公生活、城市发展等方面发挥着不可替代的作用。4月25日，中电科下属的中电太极子集团发布了央企首个行业智能大模型，是生成式人工智能在党政军行业的收款落地产品。作为建设航天强国的主力军，我们应该紧跟时代步伐，研发针对党、政、军、企等不同应用场景下的通用大模型和专用大模型。随着信息技术的发展，大模型技术在党政军企等领域展现出了广阔的应用场景。在未来作战中，陆、海、空、天、电等多域作战空间所产生的信息洪流，对指挥员的决策提出了更高要求。大模型技术一方面可以依托其强大的语言分析能力，通过新闻报道等开源信息实时提取情报信息。另一方面，还可以将各类情报信息与战场态势进行快速整合，大模型技术超高速的信息处理与分析能力，可为指挥员实时决策提供有力支持。大模型技术在党政军企等领域有着广阔的应用场景和巨大的市场需求。加快推进数字化转型，是“十四五”时期建设网络强国、数字中国的重要战略任务。信息时代智能化办公的发展已经成为未来办公领域发展的大势所趋，将大模型技术融合于智能化办公领域极大的促进了智能化办公的发展，快速推动二院数字化转型的进程。</p><h3 id="拟解决的问题和关键技术指标："><a href="#拟解决的问题和关键技术指标：" class="headerlink" title="拟解决的问题和关键技术指标："></a>拟解决的问题和关键技术指标：</h3><ul><li>构建“通用智能模型大循环+行业智能模型小循环”的“双循环”人工智能研发应用新范式，探索更有效的算力利用方式，实现模型精度和参数规模的有效动态平衡。针对党政军企等业务场景进行针对性优化，提高模型在党政军企行业业务的正确率。</li><li>针对模型训练过程中的数据安全问题提供行之有效的解决方案，确保数据在存储、传输和处理过程中得到充分的保护。采用加密技术保护敏感数据，限制数据的访问权限，有效保证在内网环境下模型训练数据的安全存储与共享。</li><li>提供国产智能硬件算子适配优化、提升大模型针对具体行业的适配性和安全可控水平，具备高可信、专业化、私有部署、全国产化等优势。不仅拥有多轮对话、信息整编、文本摘要、代码生成等生成式人工智能的共性能力，还结合公文起草、要图标绘、法规咨询等党政军行业关键应用作了针对性优化。</li></ul><p>提交成果要求</p><p>其他</p><p>训练大型模型是一项复杂而庞大的任务，通常需要大量的计算资源和时间。以下是大模型训练的一般技术路线：</p><ol><li>数据收集和预处理：首先，收集并准备用于训练的大规模数据集。数据预处理是一个重要的步骤，可以包括文本清洗、标记化、分词、去除停用词等。确保数据集的质量和多样性对训练大模型至关重要。</li><li>分布式计算和并行训练：由于大模型通常需要大量参数，它们可能无法适应单台计算机的内存。因此，需要使用分布式计算框架（如TensorFlow、PyTorch等）和多台GPU或TPU来实现并行训练。这样可以将模型参数划分成多个部分，同时在多个设备上进行计算，加速训练过程。</li><li>梯度累积（Gradient Accumulation）：在内存有限的设备上训练大模型时，可以使用梯度累积技术。梯度累积允许您在多个小批量上计算梯度，并将这些梯度累积后再进行一次参数更新。这样可以减少每次更新时所需的内存量。</li><li>模型架构选择：根据任务的复杂性和需求，选择适当的大模型架构。常见的大型模型包括BERT、GPT、BERT、Transformer等。您可以根据任务的特点选择适合的预训练模型架构或者设计新的架构。</li><li>预训练和微调：对于大模型，通常采用两阶段训练：预训练和微调。预训练阶段在大规模数据上进行，目标是学习通用的语言表示。在预训练完成后，您可以将模型用于特定任务的微调，使用相对较小的数据集来优化模型。</li><li>学习率调度和正则化：对于大模型训练，合理设置学习率和正则化项非常重要。学习率调度可以帮助模型更好地收敛，而正则化可以控制模型的复杂度，防止过拟合。</li><li>多尺度训练：在训练大模型时，可以尝试使用多尺度训练技术。通过在不同尺度上训练模型，可以增加模型对输入数据的适应性，并提高模型的泛化能力。</li><li>提前终止和模型评估：大模型的训练可能需要数天甚至数周的时间。为了节省时间和计算资源，在训练过程中定期进行模型评估，并使用提前终止技术来避免在性能不再提升时继续训练。</li><li>模型集成：在某些情况下，可以通过模型集成的方式来提升大模型的性能。模型集成是将多个大模型的预测结果进行组合，通常可以获得更好的性能。</li></ol><p>请注意，大模型训练是一个资源密集型的过程，要确保您有足够的计算资源和时间来完成训练。此外，也要关注模型的存储和推理成本，确保部署大模型后仍能满足实际需求。</p><ol><li>数据收集和处理： a. 合法获取数据：确保数据来源合法，并遵守相关的数据保护法律法规。 b. 数据隐私和安全：对敏感数据进行脱敏处理，确保数据的隐私和安全。 c. 数据清洗和标注：确保数据质量，清洗噪声数据，并准确标注数据。</li><li>数据增强： a. 对数据进行增强处理，如旋转、翻转、缩放、添加噪声等，以扩充数据集。</li><li>模型架构选择： a. 选择适合党政军业务的任务的模型架构，可以考虑使用Transformer、BERT、GPT等预训练模型，并根据任务进行微调。 b. 如果任务要求实时响应，可以考虑使用轻量级模型，如MobileBERT、TinyBERT等。</li><li>分布式计算和并行训练： a. 由于大模型通常需要大量参数，可以使用分布式计算和多台GPU或TPU来实现并行训练，加速训练过程。</li><li>学习率调度和正则化： a. 设计合理的学习率调度策略，以帮助模型更好地收敛。 b. 添加合适的正则化项，以控制模型的复杂度，防止过拟合。</li><li>预训练和微调： a. 可以使用大规模数据对模型进行预训练，学习通用的语言表示。 b. 在预训练完成后，使用党政军业务的数据对模型进行微调，优化模型性能。</li><li>模型评估和测试： a. 使用验证集和测试集对模型进行评估，确保模型达到预期性能指标。</li><li>模型集成： a. 考虑使用模型集成技术，将多个模型的预测结果进行组合，提高模型的性能和鲁棒性。</li><li>持续优化和更新： a. 定期监测模型性能，并根据党政军业务的变化和需求进行模型更新和优化。</li></ol><p>请注意，在党政军业务领域，数据安全和隐私保护至关重要。在进行任何技术实践之前，务必遵守相关法律法规和政策，并与相关部门或法律顾问协商，以确保所有步骤都合法合规。同时，严格遵守数据使用规定，保护数据的隐私和安全。</p><p>针对党政军企等专业领域业务发展需要，可采取在开源预训练模型基础上进行微调的方式进行专业大模型训练。对少量专业领域数据进行数据预处理，确保数据的质量和准确性，同时可采用例如翻转、添加噪声等方式来扩充数据集。加载开源预训练模型，在预训练模型基础上采用专业数据进行模型微调，采用分布式框架和多态GPU进行模型训练，加快训练过程，使用验证集和测试集对模型进行评估，确保模型达到预期性能指标。</p><p>针对党政军企等专业领域业务发展需要，我们可以采用在开源预训练模型基础上进行微调的方式进行专业大模型训练。采用翻转、添加噪声等方式对少量数据进行扩充，将专业数据集在预训练模型基础上进行微调，使得模型能够更好地适应专业领域的需要，微调完成后，对模型进行验证和评估。</p><p>可采取在开源预训练模型基础上进行微调的方式进行专业大模型训练。对少量专业领域数据进行数据预处理，确保数据的质量和准确性，同时可采用例如翻转、添加噪声等方式来扩充数据集。加载开源预训练模型，在预训练模型基础上采用专业数据进行模型微调，采用分布式框架和多态GPU进行模型训练，加快训练过程，使用验证集和测试集对模型进行评估，确保模型达到预期性能指标。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/07/17/%E9%A1%B9%E7%9B%AE/"/>
    <url>/2023/07/17/%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><ul><li>图像分类：resnet图像分类</li><li>图像检测：yolo图像识别<ul><li>图片打标：根据图片内容给出物品的标签</li><li><img src="/../picture/image-20230717231439986.png" alt="image-20230717231439986"></li><li>物体识别：yolo物体识别（识别物体）</li><li><img src="/../picture/image-20230717231457092.png" alt="image-20230717231457092"></li></ul></li><li>OCR文字识别<ul><li><img src="/../picture/image-20230717231635887.png" alt="image-20230717231635887"></li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring框架学习</title>
    <link href="/2023/07/16/Spring/"/>
    <url>/2023/07/16/Spring/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="Spring框架常见问题学习"><a href="#Spring框架常见问题学习" class="headerlink" title="Spring框架常见问题学习"></a>Spring框架常见问题学习</h1><h2 id="Spring框架的特点"><a href="#Spring框架的特点" class="headerlink" title="Spring框架的特点"></a>Spring框架的特点</h2><ul><li>Spring是一个轻量级的控制反转（Ioc）和面向切面（Aop）的容器（框架）。</li></ul><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>优点：</p><ul><li>静态代理的好处</li><li>一个动态代理的类代理的是一个接口，一般代理的是一类业务</li><li>复用成本低</li><li>一个动态代理类可以代理多个类，只要是实现了同一个接口即可</li></ul><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p><img src="/../../../source/picture/image-20230723172952835.png" alt="image-20230723172952835"></p><p><img src="/../../../source/picture/image-20230724094833649.png" alt="image-20230724094833649"></p><p><img src="/../../../source/picture/image-20230724095615739.png" alt="image-20230724095615739"></p><p>动态代理代理的是接口，不是实现类</p><h3 id="使用API接口实现"><a href="#使用API接口实现" class="headerlink" title="使用API接口实现"></a>使用API接口实现</h3><ul><li>UserService</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.milkboy.service;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;增加一条用户数据&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;删除一条用户数据&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;更改一条用户数据&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">select</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;查询一条用户数据&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Log类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Log</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodBeforeAdvice</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">(Method method, Object[] objects, Object o)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(o.getClass().getName() + <span class="hljs-string">&quot;的&quot;</span> + method.getName() + <span class="hljs-string">&quot;被执行了&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>AfterLog类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AfterLog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AfterReturningAdvice</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterReturning</span><span class="hljs-params">(Object o, Method method, Object[] objects, Object o1)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(o1.getClass().getName() + <span class="hljs-string">&quot;的&quot;</span> + method.getName() + <span class="hljs-string">&quot;被调用了&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>applicationContext.xml</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">    http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">    http://www.springframework.org/schema/aop</span></span><br><span class="hljs-string"><span class="hljs-tag">    https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.milkboy.service.UserServiceImpl&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;beforeLog&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.milkboy.log.Log&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;afterLog&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.milkboy.log.AfterLog&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--配置AOP--&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--切入点--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pointcut&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.milkboy.service.UserServiceImpl.*(..))&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--执行环绕增加--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;beforeLog&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointcut&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;afterLog&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointcut&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>主启动类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.milkboy.service.UserService;<br><span class="hljs-keyword">import</span> com.milkboy.service.UserServiceImpl;<br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<br><span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">myTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> (UserService) context.getBean(<span class="hljs-string">&quot;userService&quot;</span>);<br>        userService.add();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="切面定义实现"><a href="#切面定义实现" class="headerlink" title="切面定义实现"></a>切面定义实现</h3><ul><li>diy类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.milkboy.diy;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Log</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;在类执行前执行&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">after</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;在类执行后执行&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>applicationContext.xml</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;diy&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pointcut&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.milkboy.service.UserServiceImpl.*(..))&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;before&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointcut&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:after</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;after&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointcut&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="使用注解实现"><a href="#使用注解实现" class="headerlink" title="使用注解实现"></a>使用注解实现</h3><ul><li>Annonation</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.milkboy.diy;<br><br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.After;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Before;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">// 标注一个类是切面</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Annonation</span> &#123;<br>    <span class="hljs-meta">@Before(&quot;execution(* com.milkboy.service.UserServiceImpl.*(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;注解方法执行前&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@After(&quot;execution(* com.milkboy.service.UserServiceImpl.*(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">after</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;注解方法执行后&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>application.xml</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.milkboy.diy&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h2 id="Spring继承Mybatis"><a href="#Spring继承Mybatis" class="headerlink" title="Spring继承Mybatis"></a>Spring继承Mybatis</h2>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>深度学习入门指北</title>
    <link href="/2023/06/02/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/"/>
    <url>/2023/06/02/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p>本文将把我的深度学习入门经历分享给你，希望能帮助到正在前进路上昂首前行的你。学习深度学习首先要学会熟练使用python的基本语法，在这里我默认你已经学完了python基本语法</p><span id="more"></span><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>工欲善其事，必现利其器。学习一门新技术的时候，首先要配置开发环境，首先我们要配置pytorch环境，因为我用的是mac m1开发，所以在这里我只介绍mac版本下的环境配置，如果你用的是windows或者ubuntu操作系统，请自行学习版本环境配置。</p><p>anaconda相当于配置一套单独的开发环境</p><ul><li>首先要安装anaconda环境<ul><li>conda create -n pytorch python&#x3D;3.8 创建新的conda环境</li><li>conda activate pytorch 切换到pytorch环境</li><li>pip list 查看安装的工具包</li></ul></li><li>python ide安装<ul><li>pycharm<ul><li>使用python console可以动态输出代码</li></ul></li><li>jupyter<ul><li>主要使用的工具包是ipykernel</li><li>conda install nb_conda</li><li>jupyter notebook 启动jupyter</li></ul></li><li>conda install –use-local name 安装python包</li></ul></li></ul><h2 id="工具箱"><a href="#工具箱" class="headerlink" title="工具箱"></a>工具箱</h2><p>dir：打开pytorch工具箱，看到里面的内容，类似于点一样，一直往下点</p><p>help：说明功能，类似于功能说明一样</p><p><img src="/../../../source/picture/image-20230619111716432.png" alt="image-20230619111716432"></p><h2 id="加载数据"><a href="#加载数据" class="headerlink" title="加载数据"></a>加载数据</h2><ul><li>dataset：提供一种获取数据和label的方式</li><li>dataloader：对数据打包之后一起加载到网络中，为网络提供不同的数据形式</li></ul><h2 id="tensorboard"><a href="#tensorboard" class="headerlink" title="tensorboard"></a>tensorboard</h2><ul><li>可以用来生成折线图，也可以用来显示图片</li><li>常用的方法有两种<ul><li>writer.add_scalar</li><li>writer.add_image</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch.utils.tensorboard <span class="hljs-keyword">import</span> SummaryWriter<br><br>writer = SummaryWriter(<span class="hljs-string">&quot;logs&quot;</span>)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    writer.add_scalar(<span class="hljs-string">&quot;y=2x&quot;</span>, i, <span class="hljs-number">2</span>*i)<br>writer.close()<br><br>writer = SummaryWriter(<span class="hljs-string">&quot;logs&quot;</span>)<br>img_path = <span class="hljs-string">&quot;dataset/train/ants_image/5650366_e22b7e1065.jpg&quot;</span><br>img = Image.<span class="hljs-built_in">open</span>(img_path)<br>img_array = np.array(img)<br>writer.add_image(<span class="hljs-string">&quot;test&quot;</span>, img_array, <span class="hljs-number">2</span>, dataformats=<span class="hljs-string">&quot;HWC&quot;</span>)<br><br>writer.close()<br></code></pre></td></tr></table></figure><h2 id="Transformers-处理图像"><a href="#Transformers-处理图像" class="headerlink" title="Transformers 处理图像"></a>Transformers 处理图像</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">from</span> torch.utils.tensorboard <span class="hljs-keyword">import</span> SummaryWriter<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> transforms<br><br>writer = SummaryWriter(<span class="hljs-string">&quot;logs&quot;</span>)<br>img_path = <span class="hljs-string">&quot;dataset/train/ants_image/0013035.jpg&quot;</span><br>img = Image.<span class="hljs-built_in">open</span>(img_path)<br><br><span class="hljs-comment"># ToTensor</span><br>trans_tensor = transforms.ToTensor()<br>tensor_img = trans_tensor(img)<br><br><span class="hljs-built_in">print</span>(tensor_img)<br>writer.add_image(<span class="hljs-string">&quot;ToTensor&quot;</span>, tensor_img, <span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># Normalize</span><br>trans_nor = transforms.Normalize([<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>], [<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>])<br>trans_nor_img = trans_nor(tensor_img)<br>writer.add_image(<span class="hljs-string">&quot;Normalize&quot;</span>, trans_nor_img, <span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># Resize</span><br>trans_resize = transforms.Resize((<span class="hljs-number">512</span>, <span class="hljs-number">512</span>))<br>trans_size_img = trans_resize(img)<br>trans_resize_img_totensor = trans_tensor(trans_size_img)<br>writer.add_image(<span class="hljs-string">&quot;trans_nor_resize&quot;</span>, trans_resize_img_totensor, <span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># Compose</span><br>trans_resize_2 = transforms.Resize((<span class="hljs-number">512</span>, <span class="hljs-number">512</span>))<br>trans_compose = transforms.Compose([trans_resize_2, trans_tensor])<br>img_resize_2 = trans_compose(img)<br>writer.add_image(<span class="hljs-string">&quot;Resize&quot;</span>, img_resize_2, <span class="hljs-number">2</span>)<br><br><br><span class="hljs-comment"># RandomCrop</span><br>trans_random = transforms.RandomCrop(<span class="hljs-number">512</span>)<br>trans_compose_2 = transforms.Compose([trans_random, trans_tensor])<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    img_random = trans_compose_2(img)<br>    writer.add_image(<span class="hljs-string">&quot;RandomCrop&quot;</span>, img_random, i)<br><br>writer.close()<br></code></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="dataset"><a href="#dataset" class="headerlink" title="dataset"></a>dataset</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">from</span> torch.utils.tensorboard <span class="hljs-keyword">import</span> SummaryWriter<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> transforms<br><br>dataset_transform = torchvision.transforms.Compose([<br>    transforms.ToTensor()<br>])<br>train_set = torchvision.datasets.CIFAR10(root=<span class="hljs-string">&quot;./datasets&quot;</span>, train=<span class="hljs-literal">True</span>, transform=dataset_transform, download=<span class="hljs-literal">True</span>)<br>test_set = torchvision.datasets.CIFAR10(root=<span class="hljs-string">&quot;./datasets&quot;</span>, train=<span class="hljs-literal">False</span>, transform=dataset_transform, download=<span class="hljs-literal">True</span>)<br><br>writer = SummaryWriter(<span class="hljs-string">&quot;logs2&quot;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5000</span>):<br>    img, target = train_set[i]<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(img))<br>    writer.add_image(<span class="hljs-string">&quot;test&quot;</span>, img, i)<br>writer.close()<br></code></pre></td></tr></table></figure><h2 id="dataloader"><a href="#dataloader" class="headerlink" title="dataloader"></a>dataloader</h2><ul><li>batch_size：判断每次读取几条数据打包成一个集合</li><li>dataset：输入的图片的集合</li><li>shuffle：多次加载顺序是否打乱</li><li>drop_last：最后的内容是否要删除</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br><span class="hljs-keyword">from</span> torch.utils.tensorboard <span class="hljs-keyword">import</span> SummaryWriter<br><br>test_data = torchvision.datasets.CIFAR10(<span class="hljs-string">&quot;./datasets&quot;</span>, train=<span class="hljs-literal">False</span>, transform=torchvision.transforms.ToTensor(), download=<span class="hljs-literal">True</span>)<br>test_loader = DataLoader(dataset=test_data, batch_size=<span class="hljs-number">64</span>, shuffle=<span class="hljs-literal">True</span>, num_workers=<span class="hljs-number">0</span>, drop_last=<span class="hljs-literal">False</span>)<br><br>writer = SummaryWriter(<span class="hljs-string">&quot;dataloader&quot;</span>)<br>step = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> test_loader:<br>    imgs, targets = data<br>    writer.add_images(<span class="hljs-string">&quot;test_data&quot;</span>, imgs, step)<br>    step += <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(imgs)<br>    <span class="hljs-built_in">print</span>(targets)<br><br>writer.close()<br></code></pre></td></tr></table></figure><h2 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h2><ul><li>卷积运算：矩阵相乘再相加</li></ul><p><img src="/../../../source/picture/image-20230630093705805.png" alt="image-20230630093705805"></p><h2 id="最大池化操作"><a href="#最大池化操作" class="headerlink" title="最大池化操作"></a>最大池化操作</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">from</span> torch.nn <span class="hljs-keyword">import</span> MaxPool2d<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br><span class="hljs-keyword">from</span> torch.utils.tensorboard <span class="hljs-keyword">import</span> SummaryWriter<br><br>dataset = torchvision.datasets.CIFAR10(<span class="hljs-string">&quot;./datasets&quot;</span>, transform=torchvision.transforms.ToTensor(), train=<span class="hljs-literal">False</span>, download=<span class="hljs-literal">True</span>)<br>dataloader = DataLoader(dataset, batch_size=<span class="hljs-number">64</span>)<br><br><span class="hljs-built_in">input</span> = torch.tensor([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span> ,<span class="hljs-number">1</span>],<br>                      [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>],<br>                      [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>                      [<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],<br>                      [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]], dtype=<span class="hljs-built_in">float</span>)<br><br><span class="hljs-built_in">input</span> = torch.reshape(<span class="hljs-built_in">input</span>, (-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">input</span>.shape)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tudui</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(Tudui, self).__init__()<br>        self.maxpool1 = MaxPool2d(kernel_size=<span class="hljs-number">3</span>, ceil_mode=<span class="hljs-literal">False</span>)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, <span class="hljs-built_in">input</span></span>):<br>        output = self.maxpool1(<span class="hljs-built_in">input</span>)<br>        <span class="hljs-keyword">return</span> output<br><br>tudui = Tudui()<br><br>output = tudui(<span class="hljs-built_in">input</span>)<br><span class="hljs-built_in">print</span>(output)<br><br>writer = SummaryWriter(<span class="hljs-string">&quot;logs_maxpool&quot;</span>)<br>step = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> dataloader:<br>    imgs, targets = data<br>    writer.add_images(<span class="hljs-string">&quot;input&quot;</span>, imgs, step)<br>    output = tudui(imgs)<br>    writer.add_images(<span class="hljs-string">&quot;output&quot;</span>, output, step)<br>    step += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="非线性激活"><a href="#非线性激活" class="headerlink" title="非线性激活"></a>非线性激活</h2><ul><li>小于0的数转化成0</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><span class="hljs-keyword">from</span> torch.nn <span class="hljs-keyword">import</span> ReLU<br><br><span class="hljs-built_in">input</span> = torch.tensor([[<span class="hljs-number">1</span>, -<span class="hljs-number">0.5</span>], [-<span class="hljs-number">1</span>, <span class="hljs-number">3</span>]])<br><br><span class="hljs-built_in">input</span> = torch.reshape(<span class="hljs-built_in">input</span>, (-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">input</span>.shape)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tudui</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(Tudui, self).__init__()<br>        self.relu1 = ReLU()<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, <span class="hljs-built_in">input</span></span>):<br>        output = self.relu1(<span class="hljs-built_in">input</span>)<br>        <span class="hljs-keyword">return</span> output<br><br>tudui = Tudui()<br>output = tudui(<span class="hljs-built_in">input</span>)<br><span class="hljs-built_in">print</span>(output)<br></code></pre></td></tr></table></figure><ul><li>非线性激活层</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torchvision.datasets<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><span class="hljs-keyword">from</span> torch.nn <span class="hljs-keyword">import</span> ReLU, Sigmoid<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br><span class="hljs-keyword">from</span> torch.utils.tensorboard <span class="hljs-keyword">import</span> SummaryWriter<br><br><span class="hljs-built_in">input</span> = torch.tensor([[<span class="hljs-number">1</span>, -<span class="hljs-number">0.5</span>], [-<span class="hljs-number">1</span>, <span class="hljs-number">3</span>]])<br><br><span class="hljs-built_in">input</span> = torch.reshape(<span class="hljs-built_in">input</span>, (-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">input</span>.shape)<br><br>dataset = torchvision.datasets.CIFAR10(<span class="hljs-string">&quot;./datasets&quot;</span>, train=<span class="hljs-literal">False</span>, transform=torchvision.transforms.ToTensor(), download=<span class="hljs-literal">True</span>)<br>dataloader = DataLoader(dataset, batch_size=<span class="hljs-number">64</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tudui</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(Tudui, self).__init__()<br>        self.relu1 = ReLU()<br>        self.sigmoid1 = Sigmoid()<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, <span class="hljs-built_in">input</span></span>):<br>        output = self.sigmoid1(<span class="hljs-built_in">input</span>)<br>        <span class="hljs-keyword">return</span> output<br><br>writer = SummaryWriter(<span class="hljs-string">&quot;nn_relu&quot;</span>)<br><br>tudui = Tudui()<br>step = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> dataloader:<br>    imgs, targets = data<br>    writer.add_images(<span class="hljs-string">&quot;input&quot;</span>, imgs, step)<br>    output = tudui(imgs)<br>    writer.add_images(<span class="hljs-string">&quot;output&quot;</span>, output, step)<br>    step += <span class="hljs-number">1</span><br><br>writer.close()<br><span class="hljs-built_in">print</span>(output)<br></code></pre></td></tr></table></figure><h2 id="线性层"><a href="#线性层" class="headerlink" title="线性层"></a>线性层</h2><p><img src="/../../../source/picture/image-20230703135911572.png" alt="image-20230703135911572"></p><ul><li>input_feature：4096</li><li>Output_feature：1000</li></ul><p>cmake <br>  -DCMAKE_SYSTEM_PROCESSOR&#x3D;arm64 <br>  -DCMAKE_OSX_ARCHITECTURES&#x3D;arm64 <br>  -DWITH_OPENJPEG&#x3D;OFF <br>  -DWITH_IPP&#x3D;OFF <br>  -DCMAKE_BUILD_TYPE&#x3D;RELEASE <br>  -DCMAKE_INSTALL_PREFIX&#x3D;&#x2F;usr&#x2F;local <br>  -DOPENCV_EXTRA_MODULES_PATH&#x3D;$HOME&#x2F;opencv_contrib-4..0&#x2F;modules <br>  -DPYTHON2_EXECUTABLE&#x3D;&#x2F;dev&#x2F;null <br>  -DPYTHON3_EXECUTABLE&#x3D;$HOME&#x2F;anaconda3&#x2F;bin&#x2F;python3 <br>  -DBUILD_opencv_python2&#x3D;OFF <br>  -DBUILD_opencv_python3&#x3D;ON <br>  -DINSTALL_PYTHON_EXAMPLES&#x3D;ON <br>  -DINSTALL_C_EXAMPLES&#x3D;OFF <br>  -DOPENCV_ENABLE_NONFREE&#x3D;ON <br>  -DBUILD_EXAMPLES&#x3D;ON ..</p><p><strong>视频智能编辑发布服务器</strong><br><strong>(1)提供2台用于支撑视频智能编辑和内容智能检测的高性能GPU服务器。每台服务器配置要求：满足国产化自主可控需求，标准2U机架式服务器，配置不少于2路自主可控CPU，每颗CPU≥64核，主频≥2.1GHz，配置不少于512GB DDR4内存，可通过加装内存条方式扩容至1TB，SSD硬盘裸容量不低于7.68T，机械硬盘裸容量不低于36T、转速不低于7.2K，Raid有SAS 2G缓存和RAID0、RAID1、RAID5等，GPU显卡不低于64G显存、不少于2块，配置双口万兆网卡（光纤接口）不少于1个，配置2个电源模块，支持热插拔，安装有授权国产自主可控操作系统。</strong></p><h1 id="环境搭建-1"><a href="#环境搭建-1" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>安装anaconda，包管理工具</p><p>安装pycharm</p><p>安装pytorch</p><p>配置jupyter</p><p>​</p><h1 id="数据加载"><a href="#数据加载" class="headerlink" title="数据加载"></a>数据加载</h1><ul><li><p>dataset</p></li><li><p>dataloader</p></li><li><p>模型数据加载操作</p></li><li><p>Tensorboard 模型数据操作</p><ul><li>绘制图形</li><li>导入图片</li></ul></li><li><p>transforms 对图片的格式进行处理</p></li><li><p>tensor</p></li><li><p><img src="/../../../source/picture/image-20230605154253340.png" alt="image-20230605154253340"></p></li></ul><p><img src="/../../../source/picture/image-20230605155157673.png" alt="image-20230605155157673"></p><p>Transforms.Normalize() 归一化处理</p><p>transforms 对图片进行处理</p><p>Torchvision</p><p>dataset：使用开源数据集</p><p>自定义数据集</p><ul><li>dataloader 加载数据集</li><li>Dataset：数据集</li><li>Batch_size：每次多少张牌</li><li>shuffle：牌的顺序</li></ul><p>torch.nn 神经网络</p><p>torch.nn.function</p><ul><li><p>卷积运算，主要是做矩阵的乘法然后再相加</p></li><li><p>stride：矩阵运算每次移动的位置</p></li><li><p>padding: 外层加一圈，默认数字是1</p></li></ul><p>神经网络</p><ul><li>卷积操作<ul><li>in_channels 输入图像的通道数</li><li>out_channels 输出通道数</li><li>Kernel_size 卷积和的尺寸大小</li><li>stride 卷积过程中的步径大小</li><li>Padding: 边缘是否需要填充</li><li>padding_mode：控制padding是以什么样的方式填充</li><li>dilation：卷积过程中和中间的距离</li><li>groups：1</li><li>bias：true， 加一个偏执</li></ul></li></ul><p>卷积层</p><p>池化层</p><p>最大池化技术 Maxpool2d</p><p>非线性激活</p><p>正则化层</p><p>Recurrent层 一种特定的网络结构</p><p>线性层</p><p>Dropout层 防止过拟合 自然语言处理中常用</p><p>Vgg16</p><p>sequential 对同一个神经网络进行多次不同的操作</p><p>损失函数和反向传播</p><p>loss function 损失函数 Loss越小越好，经过不断训练</p><p>使用pytorch提供的网络进行训练</p><p>优化器</p><p>选择对应的优化器算法，放入模型的参数，学习速率，需要设置的参数</p><p><img src="/../../../source/picture/image-20230612150651419.png" alt="image-20230612150651419"></p><p>* </p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录刷题指南</title>
    <link href="/2022/12/07/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/"/>
    <url>/2022/12/07/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>面试常见算法题刷题指南</p><span id="more"></span><h2 id="704-二分查找（二分查找算法）"><a href="#704-二分查找（二分查找算法）" class="headerlink" title="704 二分查找（二分查找算法）"></a>704 二分查找（二分查找算法）</h2><p><a href="https://leetcode.cn/problems/binary-search/">704. 二分查找 - 力扣（Leetcode）</a></p><ul><li>拿到题目以后，首先想到的是暴力解法，数的范围不大，直接暴力应该也能过，复杂度是O(n)复杂度，所以先试了一下暴力解法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]==target)<span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>y总的二分算法板子1，之前了解过二分的板子，所以这道题刷起来很快</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=nums.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span>l+r&gt;&gt;<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]&gt;=target)r=mid;<br>            <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(nums[l]==target)<span class="hljs-keyword">return</span> l;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>y总的二分算法板子二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=nums.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            <span class="hljs-type">int</span> mid=l+r+<span class="hljs-number">1</span>&gt;&gt;<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]&lt;=target)l=mid;<br>            <span class="hljs-keyword">else</span> r=mid-<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(nums[l]!=target)<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>卡哥<strong>左闭右闭</strong>区间注意事项，因为是左闭右闭区间l&lt;&#x3D;r，所以r能取到，所以r&#x3D;nums.length-1,还有一个注意事项就是如果nums[mid]&gt;target，因为能取到人r所以r&#x3D;mid-1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=nums.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l&lt;=r)&#123;<br>            <span class="hljs-type">int</span> mid=l+(r-l&gt;&gt;<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(nums[mid]&lt;target)l=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&gt;target)r=mid-<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>卡哥<strong>左闭右开</strong>区间的注意事项，因为是左闭右开区间l&lt;r，所以r取不到，所以r的范围应该是r&#x3D;nums.length，还有一个注意事项就是，如果nums[mid]&gt;target，r取不到，所以r&#x3D;mid即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=nums.length;<br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            <span class="hljs-type">int</span> mid=l+(r-l&gt;&gt;<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(nums[mid]&lt;target)l=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&gt;target)r=mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="27-移除元素（双指针，快慢指针）"><a href="#27-移除元素（双指针，快慢指针）" class="headerlink" title="27 移除元素（双指针，快慢指针）"></a>27 移除元素（双指针，快慢指针）</h2><p><a href="https://leetcode.cn/problems/remove-element/description/">27. 移除元素 - 力扣（Leetcode）</a></p><ul><li>这是一道删除数组中元素值的题目，我们都知道，在数组中，内存都是连续存储的，无法删除一整块儿内存，所以数组中常用到的方法就是覆盖，那么也是我们这道题最直观的解法，暴力覆盖</li><li>暴力解法：循环遍历整个数组，如果当前元素的值和目标值相同的话，让目标值之后的数都往前移动一位，整个过程就是移动之后的解法，这个过程需要注意的是，移动完之后，外层数组遍历的下标往前移动了一位，因此需要外层i–，每次移动之后，数组的长度减1，最终返回移动之后的数组长度就是本题的答案。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i ++) &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] == val) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; size; j ++) &#123;<br>                    nums[j - <span class="hljs-number">1</span>] = nums[j];<br>                &#125;<br>                i --;<br>                size --;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>快慢指针解法：这道题可以将两层循环优化成一层，使用一个快慢指针来遍历，快指针负责查找新数组需要存储的元素，慢指针则负责存储新数组并移动下标，最后慢指针返回的值就是本题的解。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement1</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">slowIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">fastIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; fastIndex &lt; nums.length; fastIndex ++ ) &#123;<br>            <span class="hljs-keyword">if</span>(nums[fastIndex] != val) &#123;<br>                nums[slowIndex ++ ] = nums[fastIndex];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slowIndex;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>双指针解法：第三种方法就是双指针解法，定义两个指针，i从前往后遍历，j从后往前遍历，如果i遍历的值不等于目标值，i++，如果j遍历的值等于目标值，j–，最后交换i和j对应的值，返回的下标i即是本题的解，双指针解法需要注意的是，while遍历的循环条件是i &lt;&#x3D; j。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i &lt;= j) &#123;<br>            <span class="hljs-keyword">while</span>(i &lt;= j &amp;&amp; nums[i] != val) i ++;<br>            <span class="hljs-keyword">while</span>(i &lt;= j &amp;&amp; nums[j] == val) j --;<br>            <span class="hljs-keyword">if</span>(i &lt; j) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> nums[i];<br>                nums[i] = nums[j];<br>                nums[j] = t;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="977-有序数的平方"><a href="#977-有序数的平方" class="headerlink" title="977 有序数的平方"></a>977 有序数的平方</h2><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/description/">977. 有序数组的平方 - 力扣（Leetcode）</a></p><ul><li><strong>暴力解法：</strong>拿到这道题以后，最直观的解法就是先求平方，然后再排序，排序之后的算法复杂度取决于排序的算法复杂度，如果用快速排序来解题的话，时间复杂度为O(nlogn)，不满足题意O(n)的一个时间复杂度的要求，但是意外发现也能过，所以这道题还应该使用别的方法来解。</li><li><strong>双指针解法：</strong>这道题我们可以观察到，两边的数取平方之后应该是最大的，所以我们可以使用双指针从大到小的取新数组的最大值，最终返回新数组。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] sortedSquares(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i &lt;= j) &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] * nums[i] &gt;= nums[j] * nums[j]) &#123;<br>                result[ k -- ] = nums[i] * nums[i];<br>                i ++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                result[ k -- ] = nums[j] * nums[j];<br>                j --;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="209-长度最小的子数组-双指针"><a href="#209-长度最小的子数组-双指针" class="headerlink" title="209 长度最小的子数组(双指针)"></a>209 长度最小的子数组(双指针)</h2><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">209. 长度最小的子数组 - 力扣（Leetcode）</a></p><ul><li>暴力解法：这道题的题目意思是求解大于等于目标值的连续数组的长度，拿到这道题以后最直观的想法就是两层for循环，把所有的可能出现的情况都考虑到，然后求解，不过直接用暴力方法过的话，会有样例超时，所以这时候我们就要选择新办法了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">100005</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i ++ ) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; nums.length; j ++ ) &#123;<br>                sum += nums[j];<br>                k ++;<br>                <span class="hljs-keyword">if</span> (sum &gt;= target) &#123;<br>                    <span class="hljs-keyword">if</span> (k &lt;= res)&#123;<br>                        res = k;<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125; <br>        &#125;<br>        <span class="hljs-keyword">if</span> (res == <span class="hljs-number">100005</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>双指针i移动：这种解法循环遍历前指针i，先找到满足大于target的j的最小值，然后i自增来缩小i的范围，当sum值变小的时候，j继续后移，移动到满足大于target的条件时，i继续自增来缩小范围。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">100005</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>, k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nums.length; i ++ ) &#123;<br>            <span class="hljs-keyword">while</span> (j &lt; nums.length &amp;&amp; sum &lt; target) &#123;<br>                sum += nums[j];<br>                j ++;<br>                k ++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(sum &gt;= target &amp;&amp; k &lt; res) &#123;<br>                res = k;<br>            &#125;<br>            k --;<br>            sum -= nums[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (res == <span class="hljs-number">100005</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>双指针解法前移：这种解法是指j指针后移，循环遍历的是j指针，sum从前往后加，如果sum的值大于等于target，j不动，从前往后缩小i的范围，求解最小步数，如果j的范围不够，j自动往后移动，最后返回最小步数即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums.length; j ++ ) &#123;<br>            sum += nums[j];<br>            <span class="hljs-keyword">while</span>(target &lt;= sum) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sub</span> <span class="hljs-operator">=</span> j - i + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(sub &lt; res) res = sub;<br>                sum -= nums[i];<br>                i ++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="螺旋矩阵II-循环不变量"><a href="#螺旋矩阵II-循环不变量" class="headerlink" title="螺旋矩阵II (循环不变量)"></a>螺旋矩阵II (循环不变量)</h2><ul><li>这道题是一道数组模拟题，需要考虑的点主要是循环不变量原则，将数组的遍历分成上下左右四个部分，每一个部分都采用左闭右开的区间格式，需要注意定义的几个变量，首先是startX,startY用来表示每一圈遍历完之后的起始位置，总共遍历n&#x2F;2圈，每一圈的最后一个位置应该是n - offset，offset每次遍历完一圈之后要加1，count用来表示数组中存的数，count从1开始，一直++就行了，按照上，右，下，左的顺序，依次模拟遍历就行了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] generateMatrix(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span>[][] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">startX</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, startY = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, offset = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> n / <span class="hljs-number">2</span>, mid = n / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span>(m -- &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startX;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> startY;<br>            <span class="hljs-keyword">for</span>(j = startY; j &lt; n - offset; j ++) &#123;<br>                nums[startX][j] = count ++;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(i = startX; i &lt; n - offset; i ++) &#123;<br>                nums[i][j] = count ++;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(; j &gt; startY; j --) &#123;<br>                nums[i][j] = count ++;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(; i &gt; startX; i --) &#123;<br>                nums[i][j] = count ++;<br>            &#125;<br>            startX ++;<br>            startY ++;<br>            offset ++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> ==<span class="hljs-number">1</span>) nums[mid][mid] = count;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="203移除链表"><a href="#203移除链表" class="headerlink" title="203移除链表"></a>203移除链表</h2><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素 - 力扣（Leetcode）</a></p><ul><li>这道题是一道移除链表中元素的题，给定一个固定值，如果链表中的元素值等于这个固定值，就把这个值给移除了，这道题主要有两种方法，第一种是虚拟头结点，因为头结点中的元素也可能是要删除的元素，所以使用虚拟头结点来做，就一种思路，判断当前元素的下一个元素是否等于val，如果等于，则当前元素的下一个元素等于下一个元素的下一个元素，如果不等于，则当前元素等于当前元素的下一个元素，需要注意的是，定义一个指针元素来移动链表，所以定义一个虚拟头结点dummy，dummy.next &#x3D; head，cur &#x3D; dummy，具体代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>       <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>       dummy.next = head;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>       <span class="hljs-keyword">while</span>(cur.next != <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">if</span>(cur.next.val == val)&#123;<br>               cur.next = cur.next.next;<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               cur = cur.next;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> dummy.next;<br>   &#125;<br></code></pre></td></tr></table></figure><ul><li>第二种方法是不使用虚拟头结点，这时候需要判断一下头结点中的元素，如果头结点中的元素等于val，则头结点一直向后移，head &#x3D; head.next，移动完以后，定义一个指针cur来移动链表，这就和上面的逻辑一样了，如果cur的下一个元素的值等于val，则cur.next &#x3D; cur.next.next，否则，cur一直向后移动，即cur &#x3D; cur.next，需要注意的是，在这个方法中，两次while循环都要判断一下head不为空，即head !&#x3D; null，具体代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>       <span class="hljs-keyword">while</span>(head != <span class="hljs-literal">null</span> &amp;&amp; head.val == val) &#123;<br>           head = head.next;<br>       &#125;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>       <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span> &amp;&amp; cur.next != <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">if</span>(cur.next.val == val)&#123;<br>               cur.next = cur.next.next;<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               cur = cur.next;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> head;<br>   &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>代码随想录</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing算法基础课刷题</title>
    <link href="/2022/09/18/AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"/>
    <url>/2022/09/18/AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/</url>
    
    <content type="html"><![CDATA[<p>本文讲述了北大闫学灿算法基础课学习笔记</p><span id="more"></span><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="快速排序（以j为划分条件）"><a href="#快速排序（以j为划分条件）" class="headerlink" title="快速排序（以j为划分条件）"></a>快速排序（以j为划分条件）</h3><ul><li>快速排序的主要思想是分治</li><li>步骤：<ul><li>找到分界点</li><li>使用双指针移动，把区间划分成两部分，左边的区间都小于等于x，右边的区间都大于等于x</li><li>递归处理左右两边</li></ul></li></ul><p><a href="https://www.acwing.com/solution/content/16777/">可行性分析和边界条件证明</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> q[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;=r)<span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br>    <span class="hljs-type">int</span> s=<span class="hljs-built_in">rand</span>()%(r-l)+l;<br>    <span class="hljs-type">int</span> x=q[s],i=l<span class="hljs-number">-1</span>,j=r+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;j)&#123;<br>        <span class="hljs-keyword">do</span> i++;<span class="hljs-keyword">while</span>(q[i]&lt;x);<br>        <span class="hljs-keyword">do</span> j--;<span class="hljs-keyword">while</span>(q[j]&gt;x);<br>        <span class="hljs-keyword">if</span>(i&lt;j)<span class="hljs-built_in">swap</span>(q[i],q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q,l,j);<br>    <span class="hljs-built_in">quick_sort</span>(q,j+<span class="hljs-number">1</span>,r);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q[i]);<br>    <span class="hljs-built_in">quick_sort</span>(q,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,q[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="归并排序（双指针算法）"><a href="#归并排序（双指针算法）" class="headerlink" title="归并排序（双指针算法）"></a>归并排序（双指针算法）</h3><ul><li><p>归并排序的思想也是分治</p></li><li><p>步骤</p><ul><li>归并排序的思想是从中间分开，所以先确定分界点mid&#x3D;l+r&gt;&gt;1;</li><li>递归处理左右两部分</li><li>使用双指针算法，用两个指针从左右两段分别开始遍历，按照从小到大的顺序放到新数组里</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> q[N],tmp[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[],<span class="hljs-type">int</span> l ,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;=r)<span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">merge_sort</span>(q,l,mid);<br>    <span class="hljs-built_in">merge_sort</span>(q,mid+<span class="hljs-number">1</span>,r);<br>    <span class="hljs-type">int</span> i=l,j=mid+<span class="hljs-number">1</span>,k=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)&#123;<br>        <span class="hljs-keyword">if</span>(q[i]&lt;q[j])tmp[k++]=q[i++];<br>        <span class="hljs-keyword">else</span> tmp[k++]=q[j++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i&lt;=mid)tmp[k++]=q[i++];<br>    <span class="hljs-keyword">while</span>(j&lt;=r)tmp[k++]=q[j++];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l,j=<span class="hljs-number">0</span>;i&lt;=r;i++,j++)&#123;<br>        q[i]=tmp[j];<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q[i]);<br>    <span class="hljs-built_in">merge_sort</span>(q,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,q[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><h3 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h3><ul><li><p>思想：二分的主要作用是找边界条件，二分和单调性没有关系，有单调性的题目一定可以用二分来做，但是没有单调性的题目，也可能会用二分来做，二分通常用来解决极值问题。</p></li><li><p>步骤：</p><ul><li>先把区间一分为二，通过判断mid是否在条件范围来判断来选择不同的模版<ul><li>找最大值：如果q[mid]&lt;&#x3D;x，l&#x3D;mid，否则r&#x3D;mid+1，这时候要注意mid&#x3D;l+r+1&gt;&gt;1</li><li>找最小值：如果q[mid]&gt;&#x3D;x，r&#x3D;mid，否则l&#x3D;mid</li></ul></li></ul></li><li><p><a href="https://www.acwing.com/problem/content/791/">题目</a></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> q[N],tmp[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[],<span class="hljs-type">int</span> l ,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;=r)<span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">merge_sort</span>(q,l,mid);<br>    <span class="hljs-built_in">merge_sort</span>(q,mid+<span class="hljs-number">1</span>,r);<br>    <span class="hljs-type">int</span> i=l,j=mid+<span class="hljs-number">1</span>,k=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)&#123;<br>        <span class="hljs-keyword">if</span>(q[i]&lt;q[j])tmp[k++]=q[i++];<br>        <span class="hljs-keyword">else</span> tmp[k++]=q[j++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i&lt;=mid)tmp[k++]=q[i++];<br>    <span class="hljs-keyword">while</span>(j&lt;=r)tmp[k++]=q[j++];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l,j=<span class="hljs-number">0</span>;i&lt;=r;i++,j++)&#123;<br>        q[i]=tmp[j];<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q[i]);<br>    <span class="hljs-built_in">merge_sort</span>(q,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,q[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h3><ul><li><p>浮点数二分要比整数二分简单很多，不需要考虑太多边界情况</p></li><li><p>步骤</p><ul><li>浮点数判断的话，很难精确到具体的数值范围，所以只能用粗略估计都方法，一般认为当r-l&lt;1e-8时，就l&#x3D;&#x3D;r</li><li>浮点数二分只有一种情况，就是当q[mid]&lt;&#x3D;x l&#x3D;mid，否则r&#x3D;mid</li></ul></li><li><p>题目：求一个数的平方根</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">double</span> x;<br>    cin&gt;&gt;x;<br>    <span class="hljs-type">double</span> l=<span class="hljs-number">0</span>,r=x;<br>    <span class="hljs-keyword">while</span>(r-l&gt;<span class="hljs-number">1e-8</span>)&#123;<br>        <span class="hljs-type">double</span> mid=(l+r)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(mid*mid&lt;=x)l=mid;<br>        <span class="hljs-keyword">else</span> r=mid;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.6lf\n&quot;</span>,l);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高精度运算"><a href="#高精度运算" class="headerlink" title="高精度运算"></a>高精度运算</h2><h3 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h3><ul><li>思想：高精度的思想是把大整数用字符串来存储，</li><li>步骤：<ul><li>首先用字符串输入两个大整数a,b，将字符串数组的每一位存储到一个vector里，为了方便计算，存储到时候要倒序存储</li><li>定义一个整数t用来存储每一位相加之后的结果，如果当前位数小于第一个整数的长度，则t+&#x3D;A[i]，如果当前位数小于第二个整数，则t+&#x3D;B[i]，将t取余10的余数存到新的数组C里，表示相加之后的结果，t&#x2F;&#x3D;10;</li><li>如果计算完之后t还不为0，说明t还有剩余，最高位进1，数组C里再插入一个1</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">add</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp;A,vector&lt;<span class="hljs-type">int</span>&gt;&amp;B)&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;C;<br>    <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;A.<span class="hljs-built_in">size</span>()||i&lt;B.<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-keyword">if</span>(i&lt;A.<span class="hljs-built_in">size</span>())t+=A[i];<br>        <span class="hljs-keyword">if</span>(i&lt;B.<span class="hljs-built_in">size</span>())t+=B[i];<br>        C.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<br>        t/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(t)C.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string a,b;<br>    vector&lt;<span class="hljs-type">int</span>&gt;A,B;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=b.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)B.<span class="hljs-built_in">push_back</span>(b[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">auto</span> c=<span class="hljs-built_in">add</span>(A,B);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=c.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,c[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h3><ul><li>思想：高精度减法和高精度加法思想一致，都是把大整数转化成字符串进行运算</li><li>步骤：<ul><li>首先用字符串输入两个大正整数a,b，将字符串数组的每一位存储到一个vector里，为了方便计算，存储到时候要倒序存储</li><li>高精度减法首先需要判断两个数的大小，如果A&gt;B，则sub(A,B)，如果A&lt;B，则sub(B,A)，输出之前先输出一个负号，所以要手写一个比较函数cmp，比较两个数的大小，比较两个数大小的时候首先是比较位数，如果A的位数大于B的位数，则A&gt;B，如果位数相等，则从最高位依次比较A的每一位和B的每一位的大小，如果A的高位大于B的高位，则A&gt;B</li><li>减法运算首先定义一个r，用来表示相减之后的结果，刚开始r&#x3D;0，r&#x3D;A[i]-r，如果B的当前位数还有数，则用r-B[i]，用一个数组C来计算存储之后的结果，C.push_back((r+10)%10)，这个数不论正负，这样都能存储相减之后的正确结果，如果r&lt;0，则向上一位借一个1，r&#x3D;1，否则r&#x3D;0;</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;A,vector&lt;<span class="hljs-type">int</span>&gt;B)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(A.<span class="hljs-built_in">size</span>()!=B.<span class="hljs-built_in">size</span>())<span class="hljs-keyword">return</span> A.<span class="hljs-built_in">size</span>()&gt;B.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=A.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<span class="hljs-keyword">if</span>(A[i]!=B[i])<span class="hljs-keyword">return</span> A[i]&gt;B[i];<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">sub</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp;A,vector&lt;<span class="hljs-type">int</span>&gt;&amp;B)&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;C;<br>    <span class="hljs-type">int</span> r;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,r=<span class="hljs-number">0</span>;i&lt;A.<span class="hljs-built_in">size</span>();i++)&#123;<br>        r=A[i]-r;<br>        <span class="hljs-keyword">if</span>(i&lt;B.<span class="hljs-built_in">size</span>())r-=B[i];<br>        C.<span class="hljs-built_in">push_back</span>((r+<span class="hljs-number">10</span>)%<span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">if</span>(r&lt;<span class="hljs-number">0</span>)r=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> r=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;C.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>)C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string a,b;<br>    vector&lt;<span class="hljs-type">int</span>&gt;A,B;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=b.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)B.<span class="hljs-built_in">push_back</span>(b[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">auto</span> c=<span class="hljs-built_in">sub</span>(A,B);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cmp</span>(A,B))&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=c.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,c[i]);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-&quot;</span>);<br>        c=<span class="hljs-built_in">sub</span>(B,A);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=c.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,c[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h3><ul><li>思想：一个大整数乘一个整数，思想也是把大整数转换成字符串，用一个变量t来表示进位，大整数的每一位与另一个数相乘，余数存到数组c里，进位加到下一位运算里</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">mul</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp;A,<span class="hljs-type">int</span> b)&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;C;<br>    <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;A.<span class="hljs-built_in">size</span>();i++)&#123;<br>        t+=A[i]*b;<br>        C.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<br>        t/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(t)C.<span class="hljs-built_in">push_back</span>(t);<br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;C.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>)C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string a;<br>    vector&lt;<span class="hljs-type">int</span>&gt;A;<br>    <span class="hljs-type">int</span> b;<br>    cin &gt;&gt;a&gt;&gt;b;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">auto</span> c = <span class="hljs-built_in">mul</span>(A,b);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=c.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,c[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h3><ul><li>思想：高精度除法是用一个大整数A除以一个整数b，余数为r，思想也是把大整数转化成字符串，用r来表示余数，余数初始化为0，每次用余数*10+大整数A的每一位，表示当前的除数，将除完以后的结果存储到c中，将余数赋值给r，为了保持和前面的模版输入输出一致，数组c要进行反转</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">div</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp;A,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> &amp;r)&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;C;<br>    r=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=A.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        r=A[i]+r*<span class="hljs-number">10</span>;<br>        C.<span class="hljs-built_in">push_back</span>(r/b);<br>        r%=b;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(),C.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;C.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>)C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string a;<br>    vector&lt;<span class="hljs-type">int</span>&gt;A;<br>    <span class="hljs-type">int</span> b;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-type">int</span> r;<br>    <span class="hljs-keyword">auto</span> c=<span class="hljs-built_in">div</span>(A,b,r);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=c.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,c[i]);<br>    cout&lt;&lt;endl&lt;&lt;r&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>前缀和：</p><ul><li>怎么求</li><li>作用：算一段区间内一段数的和</li><li>前缀和的初始化：s[i]&#x3D;s[i-1]+a[i]，注意i从1开始</li><li>区间和的求和公式  ：l~r的和等于s[r]-s[l-1];</li></ul><p>二维：按照面积算</p><p><img src="/../picture/image-20221102215603513.png" alt="image-20221102215603513"></p><p>前缀和的初始化：s[i] [j]&#x3D;s[i-1] [j]+s[i] [j-1]-s[i-1] [j-1]+a[i] [j] </p><p>子矩阵求和公式：[x1,y1]到[x2,y2]的区间和为s[x2] [y2]-s[x1-1] [y2]-s[x2] [y1-1]+s[x1-1] [y1-1]</p><p>前缀和和差分是逆运算</p><h2 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h2><p>a数组是b数组的前缀和，b数组就是a数组的差分</p><p>O(n):B—&gt;A</p><p>O(1)时间操作原数组</p><p>b[l]+c，b[r+1]-c</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解读程序是怎样跑起来的</title>
    <link href="/2022/07/28/%E8%A7%A3%E8%AF%BB%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/"/>
    <url>/2022/07/28/%E8%A7%A3%E8%AF%BB%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<p>本文解读图灵系列丛书程序是怎样跑起来的</p><span id="more"></span><h2 id="什么是CPU？"><a href="#什么是CPU？" class="headerlink" title="什么是CPU？"></a>什么是CPU？</h2><p>​对于学计算机的我们来说，首次听到CPU的时候应该是一个非常高级的概念，并不了解到底什么事CPU，也不了解CPU内部都干了些什么事儿，这一部分，我带着大家慢慢来理解。</p><p>​众所周知，CPU内部是数百万至数亿个晶体管构成的，在CPU的内部，是由<strong>寄存器</strong>、<strong>控制器</strong>、<strong>运算器</strong>、<strong>时钟</strong>四部分构成的</p><p><img src="/../picture/image-20220730181208538.png" alt="CPU的内部构造"></p><ul><li>寄存器：用来暂存数据和指令</li><li>控制器：把内存上的指令和数据，读入寄存器中，并根据指令的执行结果来控制整个计算机</li><li>运算器：运算从内存中读入到寄存器中的数据</li><li>时钟：发出CPU开始计时的时钟信号</li></ul><p>​大家是否对CPU有了一定的认识和了解，那么接下来我们来了解一下什么是内存，内存就是我们常说的主存，用来存储指令和数据，内存当中的每一个字节都有一个地址编号，CPU通过这个地址来读取内存当中的指令和数据，存储在硬盘上的应用程序需要传输到内存上才能运行，当计算机关机之后，内存上的数据也自动清除。</p><h3 id="CPU是寄存器的集合体"><a href="#CPU是寄存器的集合体" class="headerlink" title="CPU是寄存器的集合体"></a>CPU是寄存器的集合体</h3><p>​其实对于计算机来说，识别不了我们日常编写的C语言、C++、Java等高级编程语言，计算机只能识别机器语言，机器语言就是一些计算机能识别的01代码串，机器语言级别的程序主要是通过寄存器来处理的,计算机底层语言汇编语言与机器语言的指令基本上是一一对应的，将汇编语言转化为机器语言这一过程称为汇编，反之则称为反汇编。</p><p><img src="/../picture/image-20220730182853527.png" alt="CPU中寄存器的种类和功能"></p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>​程序计数器想必大家都没听过，程序计数器存储了下一条指令所在的内存地址，所以程序计数器主要是决定程序执行的流程。</p><p><img src="/../picture/image-20220730183617885.png" alt="程序计数器的作用"></p><p>​那么我们知道了程序计数器用来控制程序的执行顺序，想一下，分支和循环语句是怎么控制的了？</p><p>​对于顺序执行的语句来说，每执行一个指令，程序计数器的值就自动加1，对于循环和分支来说，程序计数器的值肯定不是按顺序增加的了，接下来我们看一个用于输出一个数的绝对值的出鞥许计数器控制的例子</p><p><img src="/../picture/image-20220730184000119.png" alt="程序计数器控制分支语句"></p><p>​由上图可知，对于循环和分支语句，使用跳转指令来判断是否跳转,机器怎样判断是否跳转，这里就用到了标志寄存器，标志寄存器会保存累加计算之后的结果，标志寄存器的的第一个字节位、第二个字节位、第三个字节位运算结果分别表示正数、零和负数，CPU内部的比较其实是做减法运算的，通过减法运算之后的值表示大小。</p><h3 id="函数调用机制"><a href="#函数调用机制" class="headerlink" title="函数调用机制"></a>函数调用机制</h3><p>​通过上一小节的内容我们知道，分支和循环是由程序计数器和标志寄存器控制的，那么函数调用时怎么控制的了，我们想一下，函数的调用和分支循环语句是否一样？在函数调用结束以后，还要回到调用函数的下一行指令，那么这一步操作，就要比分支和循环复杂，这一操作基本没有办法实现，机器语言用到了call被return指令来解决这一问题，函数调用的时候使用call指令，不使用跳转指令，call指令会把调用函数之后要执行的指令放在栈中，在函数处理完之后，在函数的出口直行return指令，return指令就会把保存在栈中的地址返回到程序计数器中。</p><h3 id="数组内部是怎么调用的"><a href="#数组内部是怎么调用的" class="headerlink" title="数组内部是怎么调用的"></a>数组内部是怎么调用的</h3><p>​在上图CPU寄存器的种类中我们看到了基址寄存器和变址寄存器，通过这两个寄存器，对内存的地址进行了划分，对于一个数组，数组中元素的实际地址我们使用基址寄存器的值+变址寄存器的值来表示实际地址。基址寄存器相当于数组的首地址，变址寄存器相当于索引。</p><p><img src="/../picture/image-20220731085758742.png" alt="数组内部地址的表示"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>​通过上述内容的讲解，相信大家对CPU都有一定的认识和理解，其实CPU处理的功能都很简单，其实CPU能处理的功能如下表所示：</p><p><img src="/../picture/image-20220731090400768.png" alt="机器语言指令的主要类型和功能"></p><h2 id="数据的二进制表示"><a href="#数据的二进制表示" class="headerlink" title="数据的二进制表示"></a>数据的二进制表示</h2>]]></content>
    
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
