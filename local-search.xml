<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>安全多方计算</title>
    <link href="/2022/07/07/%E5%AE%89%E5%85%A8%E5%A4%9A%E6%96%B9%E8%AE%A1%E7%AE%97/"/>
    <url>/2022/07/07/%E5%AE%89%E5%85%A8%E5%A4%9A%E6%96%B9%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<p>本文是学习安全多方计算过程中的一些笔记和心得，欢迎大家留言讨论</p><span id="more"></span><h2 id="安全多方计算（保护协议参与方的隐私输入）"><a href="#安全多方计算（保护协议参与方的隐私输入）" class="headerlink" title="安全多方计算（保护协议参与方的隐私输入）"></a>安全多方计算（保护协议参与方的隐私输入）</h2><ul><li>优势：有效的保i护了协议参与方的隐私输入</li><li>劣势：</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>论文</tag>
      
      <tag>安全多方计算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>现代密码学学习笔记</title>
    <link href="/2022/07/06/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/07/06/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>本文主要是北京邮电大学网络空间安全学院谷利泽老师的现代密码学课堂学习笔记</p><span id="more"></span><h2 id="第一讲-绪论"><a href="#第一讲-绪论" class="headerlink" title="第一讲 绪论"></a>第一讲 绪论</h2><p>​    密码学中用到的密码和我们平时生活中接触到的密码有很大的区别，我们平时用到的例如qq、微信等密码不能称作是密码，只是简单的口令而已，口令只是身份验证的凭据。</p><p>现代密码学的主要功能：</p><ul><li>机密性</li><li>完整性</li><li>认证性</li><li>不可否认性</li></ul><p><img src="/../picture/image-20220706095935765.png" alt="image-20220706095935765"></p><h2 id="第二章-传统密码技术"><a href="#第二章-传统密码技术" class="headerlink" title="第二章 传统密码技术"></a>第二章 传统密码技术</h2><ul><li>置换算法<ul><li>行置换</li><li>周期置换</li></ul></li><li>代换算法</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>现代密码学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++类、指针和引用</title>
    <link href="/2022/07/03/C++%E7%B1%BB%E3%80%81%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8/"/>
    <url>/2022/07/03/C++%E7%B1%BB%E3%80%81%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>本文介绍了刷题中常用到的类和结构体的用法</p><span id="more"></span><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h3 id="C-中的类"><a href="#C-中的类" class="headerlink" title="C++中的类"></a>C++中的类</h3><p>​      对于程序来说，类可以将变量、数组、函数完美的打包在一起，这就是类的最基本的用法。</p><p>对于类来说，常用到的类的属性有public和private两种</p><ul><li>private:里面的内容只能在类里面调用，如果想要访问私有变量的话，可以在public里写一个函数让外部调用</li><li>public:里面的内容可以在类的外部访问</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> age,height;<br>    <span class="hljs-type">double</span> money;<br>    string books[<span class="hljs-number">100</span>];<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_money</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> money;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    string name;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">say</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;I&#x27;m&quot;</span>&lt;&lt;name&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_age</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_money</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span></span>&#123;<br>        money+=x;<br>    &#125;<br>    <span class="hljs-function">string <span class="hljs-title">get_name</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;c;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//    Person c;</span><br>    c.name=<span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-comment">//    c.age = 18;</span><br>    c.<span class="hljs-built_in">add_money</span>(<span class="hljs-number">1000</span>);<br>    cout&lt;&lt;c.<span class="hljs-built_in">get_name</span>()&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>类中的变量和函数统一被称为类的成员变量</p></blockquote><p>结构体和类的作用是基本是一样的，类中默认是private，结构体中默认是<a href="">public</a></p><p><strong>构造函数：</strong></p><ul><li>构造函数没有类型，函数名称和结构体名称一样</li><li>构造函数必须写到public里</li></ul><p><strong>结构体：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-type">int</span> age,height;<br>    <span class="hljs-type">double</span> money;<br>    <span class="hljs-built_in">Person</span>()&#123;&#125;;<br>    <span class="hljs-built_in">Person</span> (<span class="hljs-type">int</span> _age,<span class="hljs-type">int</span> _height)&#123;<br>        age=_age;<br>        height=_height;<br>    &#125;<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> _age,<span class="hljs-type">int</span> _height,<span class="hljs-type">double</span> _money):<span class="hljs-built_in">age</span>(_age),<span class="hljs-built_in">height</span>(_height),<span class="hljs-built_in">money</span>(_money)&#123;&#125;;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Person p;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">23</span>,<span class="hljs-number">180</span>,<span class="hljs-number">100.0</span>)</span></span>;<br>    Person p2 = &#123;<span class="hljs-number">18</span>,<span class="hljs-number">180</span>&#125;;<br>    cout&lt;&lt;p1.money&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>类和结构体的初始化</strong></p><ul><li>初始化的时候可以直接用构造函数来初始化，比如说：Person p(age,height);</li><li>也可以在结构体定义的时候初始化</li><li>也可以使用指针来初始化，例如：Person *p&#x3D;new Person(age,height);</li></ul><h3 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h3><p>​内存就好像是一个很大的存储数组，每一个存储在数组中的元素都有一个对应的地址来表示，定义指针的时候用*来定义，例如<code>int *p=&amp;a</code>，输出p就是输出了a的地址，输出*p就是输出了a的值，p就存放了a的地址，通过p就可以修改和表示a</p><p>​p的地址也可以用指针来存储，可以定义成<code>int **q=&amp;p</code>，q表示p的地址，*q表示a的地址，**q表示的是a的值，这种写法就类似于套娃，指针可以套指针</p><ul><li>局部变量开到栈空间里，全局变量开到堆空间里</li><li>栈和堆的新增数值方向是不同的</li></ul><p><img src="/../picture/memoharachy.jpeg" alt="img"></p><p>​数组本身就是一个指针，存的数组开始的地方，数组名就是数组第一个元素的首地址，输出<code>a</code>就能输出数组第一个元素的首地址，输出<code>*a</code>就是数组第一个元素的值，可以通过输出<code>*(a+n)</code>的值来表示后面的元素</p><ul><li>数组的名字就是指针，是数组第一个元素的地址</li><li>数组的地址是连续的一段，相邻两个元素相差的地址根据元素的类型决定</li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>​    引用和指针类似，相当于给变量起了一个别名，通过另一个名字来改变原来变量的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br>  <span class="hljs-type">int</span> *p=&amp;a;  <span class="hljs-comment">//指针</span><br>  <span class="hljs-type">int</span> &amp;p=a; <span class="hljs-comment">//引用或者别名 p和a存在统一个地址上了 </span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>​链表是数据结构当中的一种结构，一般使用结构体来定义，链表相当于用一串链子把数据连接起来了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//链表的声明</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">NodeList</span>&#123;<br>    <span class="hljs-type">int</span> val;<br>    NodeList* next;<br>    <span class="hljs-built_in">NodeList</span>(<span class="hljs-type">int</span> _val):<span class="hljs-built_in">val</span>(_val),<span class="hljs-built_in">next</span>(<span class="hljs-literal">NULL</span>)&#123;&#125;<br>&#125;;<br><span class="hljs-comment">//链表的初始化及遍历</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">auto</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">NodeList</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">auto</span> q = <span class="hljs-keyword">new</span> <span class="hljs-built_in">NodeList</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">auto</span> o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">NodeList</span>(<span class="hljs-number">3</span>);<br>    p-&gt;next =q;<br>    q-&gt;next=o;<br>    <span class="hljs-keyword">auto</span> head = p;<br>    <span class="hljs-keyword">for</span>(NodeList* i=head;i;i=i-&gt;next)&#123;<br>        cout&lt;&lt;i-&gt;val&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>注：调用的成员变量是一个变量的话用p.val和p.next</p><p>​      如果调用的成员变量是一个指针的话用p-&gt;val和p-&gt;next</p></blockquote><p><img src="/../picture/image-20220706221311294.png" alt="image-20220706221311294"></p><ul><li><p>头结点一般存在head里，head存的是头结点的地址】</p></li><li><p>头结点一般说的是第一个结点的地址，而不是值</p></li><li><p>链表的删除不是真正的删除</p></li><li><p>c++字符串切割<code>s.substr(0,n);</code> </p></li><li><p>c++字符串转化成整数 <code>stoi(str);</code></p></li><li><p>c++字符串长度获取<code>str.size();</code></p></li><li><p>c++三种空节点的表示形式</p><ul><li>0</li><li>NULL</li><li>nullptr</li></ul></li></ul><p><img src="/../picture/image-20220711100219197.png" alt="image-20220711100219197"></p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言入门</title>
    <link href="/2022/06/30/Go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/"/>
    <url>/2022/06/30/Go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p>开始愉快的Go语言学习之旅吧</p><span id="more"></span><h2 id="Go语言学习"><a href="#Go语言学习" class="headerlink" title="Go语言学习"></a>Go语言学习</h2><ul><li>Go语言支持跨平台编译</li><li>学习Go modules包管理工具</li><li>在终端输入指令go fmt 文件名 可以自动格式化go语言代码</li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="变量的申明"><a href="#变量的申明" class="headerlink" title="变量的申明"></a>变量的申明</h4><ul><li>标准声明</li><li>批量声明</li><li>申明同时指定初始值</li><li>类型推导</li><li>短变量声明</li><li>匿名变量 _</li></ul><p>函数外面的语句必须以关键字开始</p><p>:&#x3D;不能再函数外面表示</p><p>_多用于占位，表示忽略值</p><p>常量声明的时候必须赋值，整个程序运行期间不允许改变</p><p>iota常量计数器，只能用在常量里</p><p>iota可以实现枚举</p><p>iota每新增一行，iota+1，遇到const，iota清零</p><p>常量声明中，如果第二行没有赋值，那么就默认值和第一行的值相同</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>输出二进制：fmt.Printf(“%b\n”,n);</li><li>输出十进制：fmt.Printf(“%d\n”,n);</li><li>输出八进制：fmt.Printf(“%o\n”,n);</li><li>输出十六进制：fmt.Printf(“%x\n”,n);</li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul><li>位运算符</li><li></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
