<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>人工智能安全标准化白皮书解读</title>
    <link href="/2023/06/03/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AE%89%E5%85%A8%E6%A0%87%E5%87%86%E5%8C%96%E7%99%BD%E7%9A%AE%E4%B9%A6/"/>
    <url>/2023/06/03/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AE%89%E5%85%A8%E6%A0%87%E5%87%86%E5%8C%96%E7%99%BD%E7%9A%AE%E4%B9%A6/</url>
    
    <content type="html"><![CDATA[<span id="more"></span>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>深度学习入门指北</title>
    <link href="/2023/06/02/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/"/>
    <url>/2023/06/02/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p>本文将把我的深度学习入门经历分享给你，希望能帮助到正在前进路上昂首前行的你</p><span id="more"></span><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>俗话说，工欲善其事，必先利其器</p><p>安装anaconda，包管理工具</p><p>安装pycharm</p><p>安装pytorch</p><p>配置jupyter</p><p>​</p><h1 id="数据加载"><a href="#数据加载" class="headerlink" title="数据加载"></a>数据加载</h1><ul><li>dataset</li><li>dataloader</li></ul>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录刷题指南</title>
    <link href="/2022/12/07/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/"/>
    <url>/2022/12/07/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>面试常见算法题刷题指南</p><span id="more"></span><h2 id="704-二分查找（二分查找算法）"><a href="#704-二分查找（二分查找算法）" class="headerlink" title="704 二分查找（二分查找算法）"></a>704 二分查找（二分查找算法）</h2><p><a href="https://leetcode.cn/problems/binary-search/">704. 二分查找 - 力扣（Leetcode）</a></p><ul><li>拿到题目以后，首先想到的是暴力解法，数的范围不大，直接暴力应该也能过，复杂度是O(n)复杂度，所以先试了一下暴力解法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]==target)<span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>y总的二分算法板子1，之前了解过二分的板子，所以这道题刷起来很快</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=nums.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span>l+r&gt;&gt;<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]&gt;=target)r=mid;<br>            <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(nums[l]==target)<span class="hljs-keyword">return</span> l;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>y总的二分算法板子二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=nums.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            <span class="hljs-type">int</span> mid=l+r+<span class="hljs-number">1</span>&gt;&gt;<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]&lt;=target)l=mid;<br>            <span class="hljs-keyword">else</span> r=mid-<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(nums[l]!=target)<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>卡哥<strong>左闭右闭</strong>区间注意事项，因为是左闭右闭区间l&lt;&#x3D;r，所以r能取到，所以r&#x3D;nums.length-1,还有一个注意事项就是如果nums[mid]&gt;target，因为能取到人r所以r&#x3D;mid-1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=nums.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l&lt;=r)&#123;<br>            <span class="hljs-type">int</span> mid=l+(r-l&gt;&gt;<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(nums[mid]&lt;target)l=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&gt;target)r=mid-<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>卡哥<strong>左闭右开</strong>区间的注意事项，因为是左闭右开区间l&lt;r，所以r取不到，所以r的范围应该是r&#x3D;nums.length，还有一个注意事项就是，如果nums[mid]&gt;target，r取不到，所以r&#x3D;mid即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=nums.length;<br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            <span class="hljs-type">int</span> mid=l+(r-l&gt;&gt;<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(nums[mid]&lt;target)l=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&gt;target)r=mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="27-移除元素（双指针，快慢指针）"><a href="#27-移除元素（双指针，快慢指针）" class="headerlink" title="27 移除元素（双指针，快慢指针）"></a>27 移除元素（双指针，快慢指针）</h2><p><a href="https://leetcode.cn/problems/remove-element/description/">27. 移除元素 - 力扣（Leetcode）</a></p><ul><li>这是一道删除数组中元素值的题目，我们都知道，在数组中，内存都是连续存储的，无法删除一整块儿内存，所以数组中常用到的方法就是覆盖，那么也是我们这道题最直观的解法，暴力覆盖</li><li>暴力解法：循环遍历整个数组，如果当前元素的值和目标值相同的话，让目标值之后的数都往前移动一位，整个过程就是移动之后的解法，这个过程需要注意的是，移动完之后，外层数组遍历的下标往前移动了一位，因此需要外层i–，每次移动之后，数组的长度减1，最终返回移动之后的数组长度就是本题的答案。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i ++) &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] == val) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; size; j ++) &#123;<br>                    nums[j - <span class="hljs-number">1</span>] = nums[j];<br>                &#125;<br>                i --;<br>                size --;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>快慢指针解法：这道题可以将两层循环优化成一层，使用一个快慢指针来遍历，快指针负责查找新数组需要存储的元素，慢指针则负责存储新数组并移动下标，最后慢指针返回的值就是本题的解。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement1</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">slowIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">fastIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; fastIndex &lt; nums.length; fastIndex ++ ) &#123;<br>            <span class="hljs-keyword">if</span>(nums[fastIndex] != val) &#123;<br>                nums[slowIndex ++ ] = nums[fastIndex];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slowIndex;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>双指针解法：第三种方法就是双指针解法，定义两个指针，i从前往后遍历，j从后往前遍历，如果i遍历的值不等于目标值，i++，如果j遍历的值等于目标值，j–，最后交换i和j对应的值，返回的下标i即是本题的解，双指针解法需要注意的是，while遍历的循环条件是i &lt;&#x3D; j。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i &lt;= j) &#123;<br>            <span class="hljs-keyword">while</span>(i &lt;= j &amp;&amp; nums[i] != val) i ++;<br>            <span class="hljs-keyword">while</span>(i &lt;= j &amp;&amp; nums[j] == val) j --;<br>            <span class="hljs-keyword">if</span>(i &lt; j) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> nums[i];<br>                nums[i] = nums[j];<br>                nums[j] = t;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="977-有序数的平方"><a href="#977-有序数的平方" class="headerlink" title="977 有序数的平方"></a>977 有序数的平方</h2><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/description/">977. 有序数组的平方 - 力扣（Leetcode）</a></p><ul><li><strong>暴力解法：</strong>拿到这道题以后，最直观的解法就是先求平方，然后再排序，排序之后的算法复杂度取决于排序的算法复杂度，如果用快速排序来解题的话，时间复杂度为O(nlogn)，不满足题意O(n)的一个时间复杂度的要求，但是意外发现也能过，所以这道题还应该使用别的方法来解。</li><li><strong>双指针解法：</strong>这道题我们可以观察到，两边的数取平方之后应该是最大的，所以我们可以使用双指针从大到小的取新数组的最大值，最终返回新数组。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] sortedSquares(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i &lt;= j) &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] * nums[i] &gt;= nums[j] * nums[j]) &#123;<br>                result[ k -- ] = nums[i] * nums[i];<br>                i ++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                result[ k -- ] = nums[j] * nums[j];<br>                j --;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="209-长度最小的子数组-双指针"><a href="#209-长度最小的子数组-双指针" class="headerlink" title="209 长度最小的子数组(双指针)"></a>209 长度最小的子数组(双指针)</h2><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">209. 长度最小的子数组 - 力扣（Leetcode）</a></p><ul><li>暴力解法：这道题的题目意思是求解大于等于目标值的连续数组的长度，拿到这道题以后最直观的想法就是两层for循环，把所有的可能出现的情况都考虑到，然后求解，不过直接用暴力方法过的话，会有样例超时，所以这时候我们就要选择新办法了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">100005</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i ++ ) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; nums.length; j ++ ) &#123;<br>                sum += nums[j];<br>                k ++;<br>                <span class="hljs-keyword">if</span> (sum &gt;= target) &#123;<br>                    <span class="hljs-keyword">if</span> (k &lt;= res)&#123;<br>                        res = k;<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125; <br>        &#125;<br>        <span class="hljs-keyword">if</span> (res == <span class="hljs-number">100005</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>双指针i移动：这种解法循环遍历前指针i，先找到满足大于target的j的最小值，然后i自增来缩小i的范围，当sum值变小的时候，j继续后移，移动到满足大于target的条件时，i继续自增来缩小范围。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">100005</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>, k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nums.length; i ++ ) &#123;<br>            <span class="hljs-keyword">while</span> (j &lt; nums.length &amp;&amp; sum &lt; target) &#123;<br>                sum += nums[j];<br>                j ++;<br>                k ++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(sum &gt;= target &amp;&amp; k &lt; res) &#123;<br>                res = k;<br>            &#125;<br>            k --;<br>            sum -= nums[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (res == <span class="hljs-number">100005</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>双指针解法前移：这种解法是指j指针后移，循环遍历的是j指针，sum从前往后加，如果sum的值大于等于target，j不动，从前往后缩小i的范围，求解最小步数，如果j的范围不够，j自动往后移动，最后返回最小步数即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums.length; j ++ ) &#123;<br>            sum += nums[j];<br>            <span class="hljs-keyword">while</span>(target &lt;= sum) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sub</span> <span class="hljs-operator">=</span> j - i + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(sub &lt; res) res = sub;<br>                sum -= nums[i];<br>                i ++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="螺旋矩阵II-循环不变量"><a href="#螺旋矩阵II-循环不变量" class="headerlink" title="螺旋矩阵II (循环不变量)"></a>螺旋矩阵II (循环不变量)</h2><ul><li>这道题是一道数组模拟题，需要考虑的点主要是循环不变量原则，将数组的遍历分成上下左右四个部分，每一个部分都采用左闭右开的区间格式，需要注意定义的几个变量，首先是startX,startY用来表示每一圈遍历完之后的起始位置，总共遍历n&#x2F;2圈，每一圈的最后一个位置应该是n - offset，offset每次遍历完一圈之后要加1，count用来表示数组中存的数，count从1开始，一直++就行了，按照上，右，下，左的顺序，依次模拟遍历就行了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] generateMatrix(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span>[][] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">startX</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, startY = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, offset = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> n / <span class="hljs-number">2</span>, mid = n / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span>(m -- &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startX;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> startY;<br>            <span class="hljs-keyword">for</span>(j = startY; j &lt; n - offset; j ++) &#123;<br>                nums[startX][j] = count ++;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(i = startX; i &lt; n - offset; i ++) &#123;<br>                nums[i][j] = count ++;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(; j &gt; startY; j --) &#123;<br>                nums[i][j] = count ++;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(; i &gt; startX; i --) &#123;<br>                nums[i][j] = count ++;<br>            &#125;<br>            startX ++;<br>            startY ++;<br>            offset ++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> ==<span class="hljs-number">1</span>) nums[mid][mid] = count;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="203移除链表"><a href="#203移除链表" class="headerlink" title="203移除链表"></a>203移除链表</h2><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素 - 力扣（Leetcode）</a></p><ul><li>这道题是一道移除链表中元素的题，给定一个固定值，如果链表中的元素值等于这个固定值，就把这个值给移除了，这道题主要有两种方法，第一种是虚拟头结点，因为头结点中的元素也可能是要删除的元素，所以使用虚拟头结点来做，就一种思路，判断当前元素的下一个元素是否等于val，如果等于，则当前元素的下一个元素等于下一个元素的下一个元素，如果不等于，则当前元素等于当前元素的下一个元素，需要注意的是，定义一个指针元素来移动链表，所以定义一个虚拟头结点dummy，dummy.next &#x3D; head，cur &#x3D; dummy，具体代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>       <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>       dummy.next = head;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>       <span class="hljs-keyword">while</span>(cur.next != <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">if</span>(cur.next.val == val)&#123;<br>               cur.next = cur.next.next;<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               cur = cur.next;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> dummy.next;<br>   &#125;<br></code></pre></td></tr></table></figure><ul><li>第二种方法是不使用虚拟头结点，这时候需要判断一下头结点中的元素，如果头结点中的元素等于val，则头结点一直向后移，head &#x3D; head.next，移动完以后，定义一个指针cur来移动链表，这就和上面的逻辑一样了，如果cur的下一个元素的值等于val，则cur.next &#x3D; cur.next.next，否则，cur一直向后移动，即cur &#x3D; cur.next，需要注意的是，在这个方法中，两次while循环都要判断一下head不为空，即head !&#x3D; null，具体代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>       <span class="hljs-keyword">while</span>(head != <span class="hljs-literal">null</span> &amp;&amp; head.val == val) &#123;<br>           head = head.next;<br>       &#125;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>       <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span> &amp;&amp; cur.next != <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">if</span>(cur.next.val == val)&#123;<br>               cur.next = cur.next.next;<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               cur = cur.next;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> head;<br>   &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>代码随想录</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing算法基础课刷题</title>
    <link href="/2022/09/18/AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"/>
    <url>/2022/09/18/AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/</url>
    
    <content type="html"><![CDATA[<p>本文讲述了北大闫学灿算法基础课学习笔记</p><span id="more"></span><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="快速排序（以j为划分条件）"><a href="#快速排序（以j为划分条件）" class="headerlink" title="快速排序（以j为划分条件）"></a>快速排序（以j为划分条件）</h3><ul><li>快速排序的主要思想是分治</li><li>步骤：<ul><li>找到分界点</li><li>使用双指针移动，把区间划分成两部分，左边的区间都小于等于x，右边的区间都大于等于x</li><li>递归处理左右两边</li></ul></li></ul><p><a href="https://www.acwing.com/solution/content/16777/">可行性分析和边界条件证明</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> q[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;=r)<span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br>    <span class="hljs-type">int</span> s=<span class="hljs-built_in">rand</span>()%(r-l)+l;<br>    <span class="hljs-type">int</span> x=q[s],i=l<span class="hljs-number">-1</span>,j=r+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;j)&#123;<br>        <span class="hljs-keyword">do</span> i++;<span class="hljs-keyword">while</span>(q[i]&lt;x);<br>        <span class="hljs-keyword">do</span> j--;<span class="hljs-keyword">while</span>(q[j]&gt;x);<br>        <span class="hljs-keyword">if</span>(i&lt;j)<span class="hljs-built_in">swap</span>(q[i],q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q,l,j);<br>    <span class="hljs-built_in">quick_sort</span>(q,j+<span class="hljs-number">1</span>,r);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q[i]);<br>    <span class="hljs-built_in">quick_sort</span>(q,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,q[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="归并排序（双指针算法）"><a href="#归并排序（双指针算法）" class="headerlink" title="归并排序（双指针算法）"></a>归并排序（双指针算法）</h3><ul><li><p>归并排序的思想也是分治</p></li><li><p>步骤</p><ul><li>归并排序的思想是从中间分开，所以先确定分界点mid&#x3D;l+r&gt;&gt;1;</li><li>递归处理左右两部分</li><li>使用双指针算法，用两个指针从左右两段分别开始遍历，按照从小到大的顺序放到新数组里</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> q[N],tmp[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[],<span class="hljs-type">int</span> l ,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;=r)<span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">merge_sort</span>(q,l,mid);<br>    <span class="hljs-built_in">merge_sort</span>(q,mid+<span class="hljs-number">1</span>,r);<br>    <span class="hljs-type">int</span> i=l,j=mid+<span class="hljs-number">1</span>,k=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)&#123;<br>        <span class="hljs-keyword">if</span>(q[i]&lt;q[j])tmp[k++]=q[i++];<br>        <span class="hljs-keyword">else</span> tmp[k++]=q[j++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i&lt;=mid)tmp[k++]=q[i++];<br>    <span class="hljs-keyword">while</span>(j&lt;=r)tmp[k++]=q[j++];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l,j=<span class="hljs-number">0</span>;i&lt;=r;i++,j++)&#123;<br>        q[i]=tmp[j];<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q[i]);<br>    <span class="hljs-built_in">merge_sort</span>(q,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,q[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><h3 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h3><ul><li><p>思想：二分的主要作用是找边界条件，二分和单调性没有关系，有单调性的题目一定可以用二分来做，但是没有单调性的题目，也可能会用二分来做，二分通常用来解决极值问题。</p></li><li><p>步骤：</p><ul><li>先把区间一分为二，通过判断mid是否在条件范围来判断来选择不同的模版<ul><li>找最大值：如果q[mid]&lt;&#x3D;x，l&#x3D;mid，否则r&#x3D;mid+1，这时候要注意mid&#x3D;l+r+1&gt;&gt;1</li><li>找最小值：如果q[mid]&gt;&#x3D;x，r&#x3D;mid，否则l&#x3D;mid</li></ul></li></ul></li><li><p><a href="https://www.acwing.com/problem/content/791/">题目</a></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> q[N],tmp[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[],<span class="hljs-type">int</span> l ,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;=r)<span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">merge_sort</span>(q,l,mid);<br>    <span class="hljs-built_in">merge_sort</span>(q,mid+<span class="hljs-number">1</span>,r);<br>    <span class="hljs-type">int</span> i=l,j=mid+<span class="hljs-number">1</span>,k=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)&#123;<br>        <span class="hljs-keyword">if</span>(q[i]&lt;q[j])tmp[k++]=q[i++];<br>        <span class="hljs-keyword">else</span> tmp[k++]=q[j++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i&lt;=mid)tmp[k++]=q[i++];<br>    <span class="hljs-keyword">while</span>(j&lt;=r)tmp[k++]=q[j++];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l,j=<span class="hljs-number">0</span>;i&lt;=r;i++,j++)&#123;<br>        q[i]=tmp[j];<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q[i]);<br>    <span class="hljs-built_in">merge_sort</span>(q,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,q[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h3><ul><li><p>浮点数二分要比整数二分简单很多，不需要考虑太多边界情况</p></li><li><p>步骤</p><ul><li>浮点数判断的话，很难精确到具体的数值范围，所以只能用粗略估计都方法，一般认为当r-l&lt;1e-8时，就l&#x3D;&#x3D;r</li><li>浮点数二分只有一种情况，就是当q[mid]&lt;&#x3D;x l&#x3D;mid，否则r&#x3D;mid</li></ul></li><li><p>题目：求一个数的平方根</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">double</span> x;<br>    cin&gt;&gt;x;<br>    <span class="hljs-type">double</span> l=<span class="hljs-number">0</span>,r=x;<br>    <span class="hljs-keyword">while</span>(r-l&gt;<span class="hljs-number">1e-8</span>)&#123;<br>        <span class="hljs-type">double</span> mid=(l+r)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(mid*mid&lt;=x)l=mid;<br>        <span class="hljs-keyword">else</span> r=mid;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.6lf\n&quot;</span>,l);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高精度运算"><a href="#高精度运算" class="headerlink" title="高精度运算"></a>高精度运算</h2><h3 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h3><ul><li>思想：高精度的思想是把大整数用字符串来存储，</li><li>步骤：<ul><li>首先用字符串输入两个大整数a,b，将字符串数组的每一位存储到一个vector里，为了方便计算，存储到时候要倒序存储</li><li>定义一个整数t用来存储每一位相加之后的结果，如果当前位数小于第一个整数的长度，则t+&#x3D;A[i]，如果当前位数小于第二个整数，则t+&#x3D;B[i]，将t取余10的余数存到新的数组C里，表示相加之后的结果，t&#x2F;&#x3D;10;</li><li>如果计算完之后t还不为0，说明t还有剩余，最高位进1，数组C里再插入一个1</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">add</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp;A,vector&lt;<span class="hljs-type">int</span>&gt;&amp;B)&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;C;<br>    <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;A.<span class="hljs-built_in">size</span>()||i&lt;B.<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-keyword">if</span>(i&lt;A.<span class="hljs-built_in">size</span>())t+=A[i];<br>        <span class="hljs-keyword">if</span>(i&lt;B.<span class="hljs-built_in">size</span>())t+=B[i];<br>        C.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<br>        t/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(t)C.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string a,b;<br>    vector&lt;<span class="hljs-type">int</span>&gt;A,B;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=b.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)B.<span class="hljs-built_in">push_back</span>(b[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">auto</span> c=<span class="hljs-built_in">add</span>(A,B);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=c.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,c[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h3><ul><li>思想：高精度减法和高精度加法思想一致，都是把大整数转化成字符串进行运算</li><li>步骤：<ul><li>首先用字符串输入两个大正整数a,b，将字符串数组的每一位存储到一个vector里，为了方便计算，存储到时候要倒序存储</li><li>高精度减法首先需要判断两个数的大小，如果A&gt;B，则sub(A,B)，如果A&lt;B，则sub(B,A)，输出之前先输出一个负号，所以要手写一个比较函数cmp，比较两个数的大小，比较两个数大小的时候首先是比较位数，如果A的位数大于B的位数，则A&gt;B，如果位数相等，则从最高位依次比较A的每一位和B的每一位的大小，如果A的高位大于B的高位，则A&gt;B</li><li>减法运算首先定义一个r，用来表示相减之后的结果，刚开始r&#x3D;0，r&#x3D;A[i]-r，如果B的当前位数还有数，则用r-B[i]，用一个数组C来计算存储之后的结果，C.push_back((r+10)%10)，这个数不论正负，这样都能存储相减之后的正确结果，如果r&lt;0，则向上一位借一个1，r&#x3D;1，否则r&#x3D;0;</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;A,vector&lt;<span class="hljs-type">int</span>&gt;B)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(A.<span class="hljs-built_in">size</span>()!=B.<span class="hljs-built_in">size</span>())<span class="hljs-keyword">return</span> A.<span class="hljs-built_in">size</span>()&gt;B.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=A.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<span class="hljs-keyword">if</span>(A[i]!=B[i])<span class="hljs-keyword">return</span> A[i]&gt;B[i];<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">sub</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp;A,vector&lt;<span class="hljs-type">int</span>&gt;&amp;B)&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;C;<br>    <span class="hljs-type">int</span> r;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,r=<span class="hljs-number">0</span>;i&lt;A.<span class="hljs-built_in">size</span>();i++)&#123;<br>        r=A[i]-r;<br>        <span class="hljs-keyword">if</span>(i&lt;B.<span class="hljs-built_in">size</span>())r-=B[i];<br>        C.<span class="hljs-built_in">push_back</span>((r+<span class="hljs-number">10</span>)%<span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">if</span>(r&lt;<span class="hljs-number">0</span>)r=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> r=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;C.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>)C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string a,b;<br>    vector&lt;<span class="hljs-type">int</span>&gt;A,B;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=b.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)B.<span class="hljs-built_in">push_back</span>(b[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">auto</span> c=<span class="hljs-built_in">sub</span>(A,B);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cmp</span>(A,B))&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=c.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,c[i]);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-&quot;</span>);<br>        c=<span class="hljs-built_in">sub</span>(B,A);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=c.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,c[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h3><ul><li>思想：一个大整数乘一个整数，思想也是把大整数转换成字符串，用一个变量t来表示进位，大整数的每一位与另一个数相乘，余数存到数组c里，进位加到下一位运算里</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">mul</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp;A,<span class="hljs-type">int</span> b)&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;C;<br>    <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;A.<span class="hljs-built_in">size</span>();i++)&#123;<br>        t+=A[i]*b;<br>        C.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<br>        t/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(t)C.<span class="hljs-built_in">push_back</span>(t);<br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;C.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>)C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string a;<br>    vector&lt;<span class="hljs-type">int</span>&gt;A;<br>    <span class="hljs-type">int</span> b;<br>    cin &gt;&gt;a&gt;&gt;b;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">auto</span> c = <span class="hljs-built_in">mul</span>(A,b);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=c.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,c[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h3><ul><li>思想：高精度除法是用一个大整数A除以一个整数b，余数为r，思想也是把大整数转化成字符串，用r来表示余数，余数初始化为0，每次用余数*10+大整数A的每一位，表示当前的除数，将除完以后的结果存储到c中，将余数赋值给r，为了保持和前面的模版输入输出一致，数组c要进行反转</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">div</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp;A,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> &amp;r)&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;C;<br>    r=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=A.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        r=A[i]+r*<span class="hljs-number">10</span>;<br>        C.<span class="hljs-built_in">push_back</span>(r/b);<br>        r%=b;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(),C.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;C.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>)C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string a;<br>    vector&lt;<span class="hljs-type">int</span>&gt;A;<br>    <span class="hljs-type">int</span> b;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-type">int</span> r;<br>    <span class="hljs-keyword">auto</span> c=<span class="hljs-built_in">div</span>(A,b,r);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=c.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,c[i]);<br>    cout&lt;&lt;endl&lt;&lt;r&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>前缀和：</p><ul><li>怎么求</li><li>作用：算一段区间内一段数的和</li><li>前缀和的初始化：s[i]&#x3D;s[i-1]+a[i]，注意i从1开始</li><li>区间和的求和公式  ：l~r的和等于s[r]-s[l-1];</li></ul><p>二维：按照面积算</p><p><img src="/../picture/image-20221102215603513.png" alt="image-20221102215603513"></p><p>前缀和的初始化：s[i] [j]&#x3D;s[i-1] [j]+s[i] [j-1]-s[i-1] [j-1]+a[i] [j] </p><p>子矩阵求和公式：[x1,y1]到[x2,y2]的区间和为s[x2] [y2]-s[x1-1] [y2]-s[x2] [y1-1]+s[x1-1] [y1-1]</p><p>前缀和和差分是逆运算</p><h2 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h2><p>a数组是b数组的前缀和，b数组就是a数组的差分</p><p>O(n):B—&gt;A</p><p>O(1)时间操作原数组</p><p>b[l]+c，b[r+1]-c</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解读程序是怎样跑起来的</title>
    <link href="/2022/07/28/%E8%A7%A3%E8%AF%BB%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/"/>
    <url>/2022/07/28/%E8%A7%A3%E8%AF%BB%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<p>本文解读图灵系列丛书程序是怎样跑起来的</p><span id="more"></span><h2 id="什么是CPU？"><a href="#什么是CPU？" class="headerlink" title="什么是CPU？"></a>什么是CPU？</h2><p>​对于学计算机的我们来说，首次听到CPU的时候应该是一个非常高级的概念，并不了解到底什么事CPU，也不了解CPU内部都干了些什么事儿，这一部分，我带着大家慢慢来理解。</p><p>​众所周知，CPU内部是数百万至数亿个晶体管构成的，在CPU的内部，是由<strong>寄存器</strong>、<strong>控制器</strong>、<strong>运算器</strong>、<strong>时钟</strong>四部分构成的</p><p><img src="/../picture/image-20220730181208538.png" alt="CPU的内部构造"></p><ul><li>寄存器：用来暂存数据和指令</li><li>控制器：把内存上的指令和数据，读入寄存器中，并根据指令的执行结果来控制整个计算机</li><li>运算器：运算从内存中读入到寄存器中的数据</li><li>时钟：发出CPU开始计时的时钟信号</li></ul><p>​大家是否对CPU有了一定的认识和了解，那么接下来我们来了解一下什么是内存，内存就是我们常说的主存，用来存储指令和数据，内存当中的每一个字节都有一个地址编号，CPU通过这个地址来读取内存当中的指令和数据，存储在硬盘上的应用程序需要传输到内存上才能运行，当计算机关机之后，内存上的数据也自动清除。</p><h3 id="CPU是寄存器的集合体"><a href="#CPU是寄存器的集合体" class="headerlink" title="CPU是寄存器的集合体"></a>CPU是寄存器的集合体</h3><p>​其实对于计算机来说，识别不了我们日常编写的C语言、C++、Java等高级编程语言，计算机只能识别机器语言，机器语言就是一些计算机能识别的01代码串，机器语言级别的程序主要是通过寄存器来处理的,计算机底层语言汇编语言与机器语言的指令基本上是一一对应的，将汇编语言转化为机器语言这一过程称为汇编，反之则称为反汇编。</p><p><img src="/../picture/image-20220730182853527.png" alt="CPU中寄存器的种类和功能"></p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>​程序计数器想必大家都没听过，程序计数器存储了下一条指令所在的内存地址，所以程序计数器主要是决定程序执行的流程。</p><p><img src="/../picture/image-20220730183617885.png" alt="程序计数器的作用"></p><p>​那么我们知道了程序计数器用来控制程序的执行顺序，想一下，分支和循环语句是怎么控制的了？</p><p>​对于顺序执行的语句来说，每执行一个指令，程序计数器的值就自动加1，对于循环和分支来说，程序计数器的值肯定不是按顺序增加的了，接下来我们看一个用于输出一个数的绝对值的出鞥许计数器控制的例子</p><p><img src="/../picture/image-20220730184000119.png" alt="程序计数器控制分支语句"></p><p>​由上图可知，对于循环和分支语句，使用跳转指令来判断是否跳转,机器怎样判断是否跳转，这里就用到了标志寄存器，标志寄存器会保存累加计算之后的结果，标志寄存器的的第一个字节位、第二个字节位、第三个字节位运算结果分别表示正数、零和负数，CPU内部的比较其实是做减法运算的，通过减法运算之后的值表示大小。</p><h3 id="函数调用机制"><a href="#函数调用机制" class="headerlink" title="函数调用机制"></a>函数调用机制</h3><p>​通过上一小节的内容我们知道，分支和循环是由程序计数器和标志寄存器控制的，那么函数调用时怎么控制的了，我们想一下，函数的调用和分支循环语句是否一样？在函数调用结束以后，还要回到调用函数的下一行指令，那么这一步操作，就要比分支和循环复杂，这一操作基本没有办法实现，机器语言用到了call被return指令来解决这一问题，函数调用的时候使用call指令，不使用跳转指令，call指令会把调用函数之后要执行的指令放在栈中，在函数处理完之后，在函数的出口直行return指令，return指令就会把保存在栈中的地址返回到程序计数器中。</p><h3 id="数组内部是怎么调用的"><a href="#数组内部是怎么调用的" class="headerlink" title="数组内部是怎么调用的"></a>数组内部是怎么调用的</h3><p>​在上图CPU寄存器的种类中我们看到了基址寄存器和变址寄存器，通过这两个寄存器，对内存的地址进行了划分，对于一个数组，数组中元素的实际地址我们使用基址寄存器的值+变址寄存器的值来表示实际地址。基址寄存器相当于数组的首地址，变址寄存器相当于索引。</p><p><img src="/../picture/image-20220731085758742.png" alt="数组内部地址的表示"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>​通过上述内容的讲解，相信大家对CPU都有一定的认识和理解，其实CPU处理的功能都很简单，其实CPU能处理的功能如下表所示：</p><p><img src="/../picture/image-20220731090400768.png" alt="机器语言指令的主要类型和功能"></p><h2 id="数据的二进制表示"><a href="#数据的二进制表示" class="headerlink" title="数据的二进制表示"></a>数据的二进制表示</h2>]]></content>
    
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
