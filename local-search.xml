<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>剑指offer刷题</title>
    <link href="/2022/08/26/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98/"/>
    <url>/2022/08/26/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>LeetCode刷题</p><span id="more"></span><h2 id="剑指-Offer-50-第一个只出现一次的字符"><a href="#剑指-Offer-50-第一个只出现一次的字符" class="headerlink" title="剑指 Offer 50. 第一个只出现一次的字符"></a><a href="https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">剑指 Offer 50. 第一个只出现一次的字符</a></h2><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p><p><strong>示例 1:</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;abaccdeff&quot;</span><br>输出：&#x27;b&#x27;<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;&quot;</span> <br>输出：&#x27; &#x27;<br></code></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>&lt;= s 的长度 &lt;= <span class="hljs-number">50000</span><br></code></pre></td></tr></table></figure><p><strong>思路一</strong></p><p>首先理解一下题目，要找到一个字符，这个字符有两个特点，首先是只出现一次，其次是字符串的第一个，这时候首先想到的思路是用map存储每一个元素出现的次数，然后循环遍历map，找到第一个次数是1的元素，返回即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">byte</span> &#123;<br>    worldCount:=<span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">rune</span>]<span class="hljs-type">int</span>,<span class="hljs-number">8</span>)<br>    <span class="hljs-keyword">for</span> _,v:=<span class="hljs-keyword">range</span> s&#123;<br>        value,ok:=worldCount[v]<br>        <span class="hljs-keyword">if</span> ok&#123;<br>            worldCount[v]=value+<span class="hljs-number">1</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            worldCount[v]=<span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> _,v:=<span class="hljs-keyword">range</span> s&#123;<br>        <span class="hljs-keyword">if</span> worldCount[v]==<span class="hljs-number">1</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-type">byte</span>(v)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++">```<br><br><br><br>**思路<span class="hljs-number">2</span>**<br><br>每一个字符都对应一个ascii码，可以使用一维数组来存，直接使用数组的ascii码来存<br><br>```<span class="hljs-function">go</span><br><span class="hljs-function">func <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(s string)</span> byte </span>&#123;<br>    var words [<span class="hljs-number">26</span>]<span class="hljs-type">int</span><br>    <span class="hljs-keyword">for</span> index,_:=range s&#123;<br>        words[s[index]-<span class="hljs-string">&#x27;a&#x27;</span>]+=<span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> index,_:=range s&#123;<br>        <span class="hljs-keyword">if</span> words[s[index]-<span class="hljs-string">&#x27;a&#x27;</span>]==<span class="hljs-number">1</span>&#123;<br>            <span class="hljs-keyword">return</span> s[index]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> cnt[<span class="hljs-number">26</span>];<br>    <span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            cnt[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>]+=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(cnt[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>]==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> s[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode刷题</title>
    <link href="/2022/08/26/LeetCode%E5%88%B7%E9%A2%98/"/>
    <url>/2022/08/26/LeetCode%E5%88%B7%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>LeetCode刷题</p><span id="more"></span>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《图解密码技术》学习笔记</title>
    <link href="/2022/08/21/%E3%80%8A%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/08/21/%E3%80%8A%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>本文讲述了《图解密码技术》一书的学习笔记</p><span id="more"></span><p><img src="/../picture/image-20220823095618150.png" alt="image-20220823095618150"></p><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p><img src="/../picture/image-20220823101826921.png" alt="书中出现的角色名称"></p><p>公钥密码&#x3D;非对称密码</p><p><img src="/../picture/image-20220823104747797.png" alt="信息安全面临的威胁与应对技术"></p>]]></content>
    
    
    
    <tags>
      
      <tag>密码学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解读程序是怎样跑起来的</title>
    <link href="/2022/07/28/%E8%A7%A3%E8%AF%BB%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/"/>
    <url>/2022/07/28/%E8%A7%A3%E8%AF%BB%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<p>本文解读图灵系列丛书程序是怎样跑起来的</p><span id="more"></span><h2 id="什么是CPU？"><a href="#什么是CPU？" class="headerlink" title="什么是CPU？"></a>什么是CPU？</h2><p>​对于学计算机的我们来说，首次听到CPU的时候应该是一个非常高级的概念，并不了解到底什么事CPU，也不了解CPU内部都干了些什么事儿，这一部分，我带着大家慢慢来理解。</p><p>​众所周知，CPU内部是数百万至数亿个晶体管构成的，在CPU的内部，是由<strong>寄存器</strong>、<strong>控制器</strong>、<strong>运算器</strong>、<strong>时钟</strong>四部分构成的</p><p><img src="/../picture/image-20220730181208538.png" alt="CPU的内部构造"></p><ul><li>寄存器：用来暂存数据和指令</li><li>控制器：把内存上的指令和数据，读入寄存器中，并根据指令的执行结果来控制整个计算机</li><li>运算器：运算从内存中读入到寄存器中的数据</li><li>时钟：发出CPU开始计时的时钟信号</li></ul><p>​大家是否对CPU有了一定的认识和了解，那么接下来我们来了解一下什么是内存，内存就是我们常说的主存，用来存储指令和数据，内存当中的每一个字节都有一个地址编号，CPU通过这个地址来读取内存当中的指令和数据，存储在硬盘上的应用程序需要传输到内存上才能运行，当计算机关机之后，内存上的数据也自动清除。</p><h3 id="CPU是寄存器的集合体"><a href="#CPU是寄存器的集合体" class="headerlink" title="CPU是寄存器的集合体"></a>CPU是寄存器的集合体</h3><p>​其实对于计算机来说，识别不了我们日常编写的C语言、C++、Java等高级编程语言，计算机只能识别机器语言，机器语言就是一些计算机能识别的01代码串，机器语言级别的程序主要是通过寄存器来处理的,计算机底层语言汇编语言与机器语言的指令基本上是一一对应的，将汇编语言转化为机器语言这一过程称为汇编，反之则称为反汇编。</p><p><img src="/../picture/image-20220730182853527.png" alt="CPU中寄存器的种类和功能"></p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>​程序计数器想必大家都没听过，程序计数器存储了下一条指令所在的内存地址，所以程序计数器主要是决定程序执行的流程。</p><p><img src="/../picture/image-20220730183617885.png" alt="程序计数器的作用"></p><p>​那么我们知道了程序计数器用来控制程序的执行顺序，想一下，分支和循环语句是怎么控制的了？</p><p>​对于顺序执行的语句来说，每执行一个指令，程序计数器的值就自动加1，对于循环和分支来说，程序计数器的值肯定不是按顺序增加的了，接下来我们看一个用于输出一个数的绝对值的出鞥许计数器控制的例子</p><p><img src="/../picture/image-20220730184000119.png" alt="程序计数器控制分支语句"></p><p>​由上图可知，对于循环和分支语句，使用跳转指令来判断是否跳转,机器怎样判断是否跳转，这里就用到了标志寄存器，标志寄存器会保存累加计算之后的结果，标志寄存器的的第一个字节位、第二个字节位、第三个字节位运算结果分别表示正数、零和负数，CPU内部的比较其实是做减法运算的，通过减法运算之后的值表示大小。</p><h3 id="函数调用机制"><a href="#函数调用机制" class="headerlink" title="函数调用机制"></a>函数调用机制</h3><p>​通过上一小节的内容我们知道，分支和循环是由程序计数器和标志寄存器控制的，那么函数调用时怎么控制的了，我们想一下，函数的调用和分支循环语句是否一样？在函数调用结束以后，还要回到调用函数的下一行指令，那么这一步操作，就要比分支和循环复杂，这一操作基本没有办法实现，机器语言用到了call被return指令来解决这一问题，函数调用的时候使用call指令，不使用跳转指令，call指令会把调用函数之后要执行的指令放在栈中，在函数处理完之后，在函数的出口直行return指令，return指令就会把保存在栈中的地址返回到程序计数器中。</p><h3 id="数组内部是怎么调用的"><a href="#数组内部是怎么调用的" class="headerlink" title="数组内部是怎么调用的"></a>数组内部是怎么调用的</h3><p>​在上图CPU寄存器的种类中我们看到了基址寄存器和变址寄存器，通过这两个寄存器，对内存的地址进行了划分，对于一个数组，数组中元素的实际地址我们使用基址寄存器的值+变址寄存器的值来表示实际地址。基址寄存器相当于数组的首地址，变址寄存器相当于索引。</p><p><img src="/../picture/image-20220731085758742.png" alt="数组内部地址的表示"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>​通过上述内容的讲解，相信大家对CPU都有一定的认识和理解，其实CPU处理的功能都很简单，其实CPU能处理的功能如下表所示：</p><p><img src="/../picture/image-20220731090400768.png" alt="机器语言指令的主要类型和功能"></p><h2 id="数据的二进制表示"><a href="#数据的二进制表示" class="headerlink" title="数据的二进制表示"></a>数据的二进制表示</h2>]]></content>
    
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ STL</title>
    <link href="/2022/07/12/C++%20STL/"/>
    <url>/2022/07/12/C++%20STL/</url>
    
    <content type="html"><![CDATA[<p>本文介绍了一些C++常用的STL，容器</p><span id="more"></span><p>a.size() 获取数组长度</p><p>a.empty()  获取数组是否为空</p><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p>vector是一个变长数组</p><p>迭代器就是一个指针</p><p>迭代器一般和a.begin()和a.end()一起使用，区间是左闭右开</p><p>数组<code>vector&lt;int&gt;&#123;1,2,3,4,5&#125;</code></p><p><code>a[0]=a.front()=*a.begin()</code></p><p><code>a.back()=a[a.size()-1]</code> 获取到数组的最后一个元素</p><p>a.push_back(6) &#x2F;&#x2F;时间复杂度是o1</p><p>a.pop_back()删除最后一个元素</p><p>vector要比普通数组速度慢，vector涉及到拷贝的问题</p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>先进先出，队首出队，队尾入队</p><p>优先队列：每次往外弹出的时候，默认弹出所有数的最大值</p><p>如果自己定义结构体优先队列的话，如果是大根堆，需要重载小于号，如果是小根堆，需要重载大于号</p><p>普通队列是一个循环队列</p><p>栈、队列、优先队列没有clear函数，其他STL容器都有clear函数</p><p>如果没有clear函数，怎样初始化q&#x3D;queue<int>();</p><h2 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈 stack"></a>栈 stack</h2><h2 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h2><h2 id="位运算和常用库函数"><a href="#位运算和常用库函数" class="headerlink" title="位运算和常用库函数"></a>位运算和常用库函数</h2><p>a&gt;&gt;k&amp;1，取出k位数字 </p><p>a&amp;(~a+1) 取出最后一位1</p><p>(~a+1)&#x3D;-a</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串就是字符数组+’\0’ </p><p>数组本身就是一个指针 </p><p>字符数组的输入遇到空格、换行等都会中断，读入一行数据可以使用fgets(s,100,stdin); 读入一行到一个字符数组</p><p>char s[100];</p><p>cin.getline(s,100);</p><p>puts(s)</p><p>cin读入一行数据</p><p>string：字符串 getline(cin,s); 把一行读入到一个string里</p><p>char数组用c语言方式读入的时候不需要加&amp;符号</p><p>char数组：</p><ul><li>数组名称就是地址</li><li>scanf(“%s”,s);</li><li>cin&gt;&gt;s+1；从下标1开始</li><li>cout&lt;&lt;s;</li><li>printf(“%s”,s);</li><li>gets &#x2F;&#x2F;淘汰</li><li>fgets(s,1000,stdin);</li><li>cin.getline(s,100);</li><li>puts(s)</li><li>strlen(s) &#x2F;&#x2F;获取字符串的长度，不包括’\0’</li><li>strcmp(s) &#x2F;&#x2F;比较字典序的大小，通过返回值来判断</li></ul><blockquote><p>输入输出字典序问题一般和贪心问题来一起解决</p></blockquote><p>string:</p><ul><li>getline(cin,s);</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安全多方计算</title>
    <link href="/2022/07/07/%E5%AE%89%E5%85%A8%E5%A4%9A%E6%96%B9%E8%AE%A1%E7%AE%97/"/>
    <url>/2022/07/07/%E5%AE%89%E5%85%A8%E5%A4%9A%E6%96%B9%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<p>本文是学习安全多方计算过程中的一些笔记和心得，欢迎大家留言讨论</p><span id="more"></span><h2 id="安全多方计算（保护协议参与方的隐私输入）"><a href="#安全多方计算（保护协议参与方的隐私输入）" class="headerlink" title="安全多方计算（保护协议参与方的隐私输入）"></a>安全多方计算（保护协议参与方的隐私输入）</h2><ul><li>优势：有效的保i护了协议参与方的隐私输入</li><li>劣势：</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>论文</tag>
      
      <tag>安全多方计算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>现代密码学学习笔记</title>
    <link href="/2022/07/06/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/07/06/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>本文主要是北京邮电大学网络空间安全学院谷利泽老师的现代密码学课堂学习笔记</p><span id="more"></span><h2 id="第一讲-绪论"><a href="#第一讲-绪论" class="headerlink" title="第一讲 绪论"></a>第一讲 绪论</h2><p>​    密码学中用到的密码和我们平时生活中接触到的密码有很大的区别，我们平时用到的例如qq、微信等密码不能称作是密码，只是简单的口令而已，口令只是身份验证的凭据。</p><p>现代密码学的主要功能：</p><ul><li>机密性</li><li>完整性</li><li>认证性</li><li>不可否认性</li></ul><p><img src="/../picture/image-20220706095935765.png" alt="image-20220706095935765"></p><h2 id="第二章-传统密码技术"><a href="#第二章-传统密码技术" class="headerlink" title="第二章 传统密码技术"></a>第二章 传统密码技术</h2><ul><li>置换算法<ul><li>行置换</li><li>周期置换</li></ul></li><li>代换算法</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>现代密码学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++类、指针和引用</title>
    <link href="/2022/07/03/C++%E7%B1%BB%E3%80%81%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8/"/>
    <url>/2022/07/03/C++%E7%B1%BB%E3%80%81%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>本文介绍了刷题中常用到的类和结构体的用法</p><span id="more"></span><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h3 id="C-中的类"><a href="#C-中的类" class="headerlink" title="C++中的类"></a>C++中的类</h3><p>​      对于程序来说，类可以将变量、数组、函数完美的打包在一起，这就是类的最基本的用法。</p><p>对于类来说，常用到的类的属性有public和private两种</p><ul><li>private:里面的内容只能在类里面调用，如果想要访问私有变量的话，可以在public里写一个函数让外部调用</li><li>public:里面的内容可以在类的外部访问</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> age,height;<br>    <span class="hljs-type">double</span> money;<br>    string books[<span class="hljs-number">100</span>];<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_money</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> money;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    string name;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">say</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;I&#x27;m&quot;</span>&lt;&lt;name&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_age</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_money</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span></span>&#123;<br>        money+=x;<br>    &#125;<br>    <span class="hljs-function">string <span class="hljs-title">get_name</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;c;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//    Person c;</span><br>    c.name=<span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-comment">//    c.age = 18;</span><br>    c.<span class="hljs-built_in">add_money</span>(<span class="hljs-number">1000</span>);<br>    cout&lt;&lt;c.<span class="hljs-built_in">get_name</span>()&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>类中的变量和函数统一被称为类的成员变量</p></blockquote><p>结构体和类的作用是基本是一样的，类中默认是private，结构体中默认是<a href="">public</a></p><p><strong>构造函数：</strong></p><ul><li>构造函数没有类型，函数名称和结构体名称一样</li><li>构造函数必须写到public里</li></ul><p><strong>结构体：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-type">int</span> age,height;<br>    <span class="hljs-type">double</span> money;<br>    <span class="hljs-built_in">Person</span>()&#123;&#125;;<br>    <span class="hljs-built_in">Person</span> (<span class="hljs-type">int</span> _age,<span class="hljs-type">int</span> _height)&#123;<br>        age=_age;<br>        height=_height;<br>    &#125;<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> _age,<span class="hljs-type">int</span> _height,<span class="hljs-type">double</span> _money):<span class="hljs-built_in">age</span>(_age),<span class="hljs-built_in">height</span>(_height),<span class="hljs-built_in">money</span>(_money)&#123;&#125;;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Person p;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">23</span>,<span class="hljs-number">180</span>,<span class="hljs-number">100.0</span>)</span></span>;<br>    Person p2 = &#123;<span class="hljs-number">18</span>,<span class="hljs-number">180</span>&#125;;<br>    cout&lt;&lt;p1.money&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>类和结构体的初始化</strong></p><ul><li>初始化的时候可以直接用构造函数来初始化，比如说：Person p(age,height);</li><li>也可以在结构体定义的时候初始化</li><li>也可以使用指针来初始化，例如：Person *p&#x3D;new Person(age,height);</li></ul><h3 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h3><p>​内存就好像是一个很大的存储数组，每一个存储在数组中的元素都有一个对应的地址来表示，定义指针的时候用*来定义，例如<code>int *p=&amp;a</code>，输出p就是输出了a的地址，输出*p就是输出了a的值，p就存放了a的地址，通过p就可以修改和表示a</p><p>​p的地址也可以用指针来存储，可以定义成<code>int **q=&amp;p</code>，q表示p的地址，*q表示a的地址，**q表示的是a的值，这种写法就类似于套娃，指针可以套指针</p><ul><li>局部变量开到栈空间里，全局变量开到堆空间里</li><li>栈和堆的新增数值方向是不同的</li></ul><p><img src="/../picture/memoharachy.jpeg" alt="img"></p><p>​数组本身就是一个指针，存的数组开始的地方，数组名就是数组第一个元素的首地址，输出<code>a</code>就能输出数组第一个元素的首地址，输出<code>*a</code>就是数组第一个元素的值，可以通过输出<code>*(a+n)</code>的值来表示后面的元素</p><ul><li>数组的名字就是指针，是数组第一个元素的地址</li><li>数组的地址是连续的一段，相邻两个元素相差的地址根据元素的类型决定</li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>​    引用和指针类似，相当于给变量起了一个别名，通过另一个名字来改变原来变量的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br>  <span class="hljs-type">int</span> *p=&amp;a;  <span class="hljs-comment">//指针</span><br>  <span class="hljs-type">int</span> &amp;p=a; <span class="hljs-comment">//引用或者别名 p和a存在统一个地址上了 </span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>​链表是数据结构当中的一种结构，一般使用结构体来定义，链表相当于用一串链子把数据连接起来了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//链表的声明</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">NodeList</span>&#123;<br>    <span class="hljs-type">int</span> val;<br>    NodeList* next;<br>    <span class="hljs-built_in">NodeList</span>(<span class="hljs-type">int</span> _val):<span class="hljs-built_in">val</span>(_val),<span class="hljs-built_in">next</span>(<span class="hljs-literal">NULL</span>)&#123;&#125;<br>&#125;;<br><span class="hljs-comment">//链表的初始化及遍历</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">auto</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">NodeList</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">auto</span> q = <span class="hljs-keyword">new</span> <span class="hljs-built_in">NodeList</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">auto</span> o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">NodeList</span>(<span class="hljs-number">3</span>);<br>    p-&gt;next =q;<br>    q-&gt;next=o;<br>    <span class="hljs-keyword">auto</span> head = p;<br>    <span class="hljs-keyword">for</span>(NodeList* i=head;i;i=i-&gt;next)&#123;<br>        cout&lt;&lt;i-&gt;val&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>注：调用的成员变量是一个变量的话用p.val和p.next</p><p>​      如果调用的成员变量是一个指针的话用p-&gt;val和p-&gt;next </p></blockquote><p><img src="/../picture/image-20220706221311294.png" alt="image-20220706221311294"></p><ul><li><p>头结点一般存在head里，head存的是头结点的地址】</p></li><li><p>头结点一般说的是第一个结点的地址，而不是值</p></li><li><p>链表的删除不是真正的删除</p></li><li><p>c++字符串切割<code>s.substr(0,n);</code> </p></li><li><p>c++字符串转化成整数 <code>stoi(str);</code></p></li><li><p>c++字符串长度获取<code>str.size();</code></p></li><li><p>c++三种空节点的表示形式</p><ul><li>0</li><li>NULL</li><li>nullptr</li></ul></li></ul><p><img src="/../picture/image-20220711100219197.png" alt="image-20220711100219197"></p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言入门</title>
    <link href="/2022/06/30/Go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/"/>
    <url>/2022/06/30/Go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p>开始愉快的Go语言学习之旅吧</p><span id="more"></span><h2 id="Go语言学习"><a href="#Go语言学习" class="headerlink" title="Go语言学习"></a>Go语言学习</h2><ul><li>Go语言支持跨平台编译</li><li>学习Go modules包管理工具</li><li>在终端输入指令go fmt 文件名 可以自动格式化go语言代码</li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="变量的申明"><a href="#变量的申明" class="headerlink" title="变量的申明"></a>变量的申明</h4><ul><li><p>标准声明</p><p><code>var name string</code></p></li><li><p>批量声明</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>a <span class="hljs-type">string</span><br>b <span class="hljs-type">int</span><br>)<br></code></pre></td></tr></table></figure></li><li><p>申明同时指定初始值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> name <span class="hljs-type">string</span>=<span class="hljs-string">&quot;milkboy&quot;</span><br><span class="hljs-keyword">var</span> age <span class="hljs-type">int</span> =<span class="hljs-number">18</span><br></code></pre></td></tr></table></figure></li><li><p>类型推导</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span>语言会根据变量内容自动进行变量类型推导，例如：<br><span class="hljs-keyword">var</span> name =<span class="hljs-string">&quot;milkboy&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>短变量声明</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">name:=<span class="hljs-string">&quot;milkboy&quot;</span><br>age:=<span class="hljs-number">18</span> <br></code></pre></td></tr></table></figure></li><li><p>匿名变量 _</p><ul><li>匿名变量不占用内存空间，不会分配内存。</li></ul></li></ul><blockquote><p>函数外面的语句必须以关键字开始</p><p>:&#x3D;不能再函数外面表示</p><p>_多用于占位，表示忽略值</p></blockquote><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量在声明的时候和变量一样，只不过常量是恒定不变的值，声明的时候把var改成const，常量声明的时候必须赋值，整个程序运行期间不允许改变</p><ul><li>iota<ul><li>在定义变量时，const每增加一行，iota计数+1</li><li>iota常量计数器，只能用在常量里</li><li>iota可以实现枚举</li><li>iota每新增一行，iota+1，遇到const，iota清零</li></ul></li></ul><p>常量声明中，如果第二行没有赋值，那么就默认值和第一行的值相同</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p><img src="/../picture/image-20220822151142231.png" alt="整型数值范围表"></p><ul><li><p>变量在表示的时候，0b表示二进制数，0o表示八进制数，0x表示十六进制数</p></li><li><p>输出二进制：fmt.Printf(“%b\n”,n);</p></li><li><p>输出十进制：fmt.Printf(“%d\n”,n);</p></li><li><p>输出八进制：fmt.Printf(“%o\n”,n);</p></li><li><p>输出十六进制：fmt.Printf(“%x\n”,n);</p></li><li><p>输出数据类型：fmt.Printf(“%T\n”,n);\</p></li></ul><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p>浮点型只有两种：float64和float32</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><img src="/../picture/image-20220822152247860.png" alt="字符串转义符"></p><ul><li>字符串的常用操作</li></ul><p><img src="/../picture/image-20220822153032593.png" alt="go语言中字符串常用方法"></p><h3 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h3><ul><li><code>uint8</code>类型，或者叫 byte 型，代表一个<code>ASCII码</code>字符。</li><li><code>rune</code>类型，代表一个 <code>UTF-8字符</code>。</li><li>遍历中英文结合的字符串时，尽量使用for range遍历</li><li>由于字符串底层使用的是[ ]byte和[ ]rune，所以修改字符串的时候需要先转换成[ ]byte和[ ]rune来进行修改</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">changeString</span><span class="hljs-params">()</span></span> &#123;<br>s1 := <span class="hljs-string">&quot;big&quot;</span><br><span class="hljs-comment">// 强制类型转换</span><br>byteS1 := []<span class="hljs-type">byte</span>(s1)<br>byteS1[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;p&#x27;</span><br>fmt.Println(<span class="hljs-type">string</span>(byteS1))<br><br>s2 := <span class="hljs-string">&quot;白萝卜&quot;</span><br>runeS2 := []<span class="hljs-type">rune</span>(s2)<br>runeS2[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;红&#x27;</span><br>fmt.Println(<span class="hljs-type">string</span>(runeS2))<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>go语言支持强制类型转换</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><table><thead><tr><th align="center">运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">相加</td></tr><tr><td align="center">-</td><td align="center">相减</td></tr><tr><td align="center">*</td><td align="center">相乘</td></tr><tr><td align="center">&#x2F;</td><td align="center">相除</td></tr><tr><td align="center">%</td><td align="center">求余</td></tr></tbody></table><p><strong>注意：</strong> <code>++</code>（自增）和<code>--</code>（自减）在Go语言中是单独的语句，并不是运算符。</p><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><table><thead><tr><th align="center">运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">&#x3D;&#x3D;</td><td align="center">检查两个值是否相等，如果相等返回 True 否则返回 False。</td></tr><tr><td align="center">!&#x3D;</td><td align="center">检查两个值是否不相等，如果不相等返回 True 否则返回 False。</td></tr><tr><td align="center">&gt;</td><td align="center">检查左边值是否大于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td align="center">&gt;&#x3D;</td><td align="center">检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td align="center">&lt;</td><td align="center">检查左边值是否小于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td align="center">&lt;&#x3D;</td><td align="center">检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。</td></tr></tbody></table><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><table><thead><tr><th align="center">运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">&amp;&amp;</td><td align="center">逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False。</td></tr><tr><td align="center">||</td><td align="center">逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False。</td></tr><tr><td align="center">!</td><td align="center">逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True。</td></tr></tbody></table><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>位运算符对整数在内存中的二进制位进行操作。</p><table><thead><tr><th align="center">运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">&amp;</td><td align="center">参与运算的两数各对应的二进位相与。 （两位均为1才为1）</td></tr><tr><td align="center">|</td><td align="center">参与运算的两数各对应的二进位相或。 （两位有一个为1就为1）</td></tr><tr><td align="center">^</td><td align="center">参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。 （两位不一样则为1）</td></tr><tr><td align="center">&lt;&lt;</td><td align="center">左移n位就是乘以2的n次方。 “a&lt;&lt;b”是把a的各二进位全部左移b位，高位丢弃，低位补0。</td></tr><tr><td align="center">&gt;&gt;</td><td align="center">右移n位就是除以2的n次方。 “a&gt;&gt;b”是把a的各二进位全部右移b位。</td></tr></tbody></table><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><table><thead><tr><th align="center">运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">&#x3D;</td><td align="center">简单的赋值运算符，将一个表达式的值赋给一个左值</td></tr><tr><td align="center">+&#x3D;</td><td align="center">相加后再赋值</td></tr><tr><td align="center">-&#x3D;</td><td align="center">相减后再赋值</td></tr><tr><td align="center">*&#x3D;</td><td align="center">相乘后再赋值</td></tr><tr><td align="center">&#x2F;&#x3D;</td><td align="center">相除后再赋值</td></tr><tr><td align="center">%&#x3D;</td><td align="center">求余后再赋值</td></tr><tr><td align="center">&lt;&lt;&#x3D;</td><td align="center">左移后赋值</td></tr><tr><td align="center">&gt;&gt;&#x3D;</td><td align="center">右移后赋值</td></tr><tr><td align="center">&amp;&#x3D;</td><td align="center">按位与后赋值</td></tr><tr><td align="center">|&#x3D;</td><td align="center">按位或后赋值</td></tr><tr><td align="center">^&#x3D;</td><td align="center">按位异或后赋值</td></tr></tbody></table><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="if条件判断"><a href="#if条件判断" class="headerlink" title="if条件判断"></a>if条件判断</h3><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>Go 语言中的所有循环类型均可以使用<code>for</code>关键字来完成。</p><p>for循环的基本格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> 初始语句;条件表达式;结束语句&#123;<br>    循环体语句<br>&#125;<br></code></pre></td></tr></table></figure><p>条件表达式返回<code>true</code>时循环体不停地进行循环，直到条件表达式返回<code>false</code>时自动退出循环。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">forDemo</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>fmt.Println(i)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>for循环的初始语句可以被忽略，但是初始语句后的分号必须要写，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">forDemo2</span><span class="hljs-params">()</span></span> &#123;<br>i := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> ; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>fmt.Println(i)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>for循环的初始语句和结束语句都可以省略，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">forDemo3</span><span class="hljs-params">()</span></span> &#123;<br>i := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i &lt; <span class="hljs-number">10</span> &#123;<br>fmt.Println(i)<br>i++<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种写法类似于其他编程语言中的<code>while</code>，在<code>while</code>后添加一个条件表达式，满足条件表达式时持续循环，否则结束循环。</p><h3 id="switch-case"><a href="#switch-case" class="headerlink" title="switch-case"></a>switch-case</h3><p>使用<code>switch</code>语句可方便地对大量的值进行条件判断。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">switchDemo1</span><span class="hljs-params">()</span></span> &#123;<br>finger := <span class="hljs-number">3</span><br><span class="hljs-keyword">switch</span> finger &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>fmt.Println(<span class="hljs-string">&quot;大拇指&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>fmt.Println(<span class="hljs-string">&quot;食指&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>fmt.Println(<span class="hljs-string">&quot;中指&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>fmt.Println(<span class="hljs-string">&quot;无名指&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>fmt.Println(<span class="hljs-string">&quot;小拇指&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;无效的输入！&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Go语言规定每个<code>switch</code>只能有一个<code>default</code>分支。</p><p>一个分支可以有多个值，多个case值中间使用英文逗号分隔。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testSwitch3</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">switch</span> n := <span class="hljs-number">7</span>; n &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>:<br>fmt.Println(<span class="hljs-string">&quot;奇数&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>:<br>fmt.Println(<span class="hljs-string">&quot;偶数&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>fmt.Println(n)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分支还可以使用表达式，这时候switch语句后面不需要再跟判断变量。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">switchDemo4</span><span class="hljs-params">()</span></span> &#123;<br>age := <span class="hljs-number">30</span><br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> age &lt; <span class="hljs-number">25</span>:<br>fmt.Println(<span class="hljs-string">&quot;好好学习吧&quot;</span>)<br><span class="hljs-keyword">case</span> age &gt; <span class="hljs-number">25</span> &amp;&amp; age &lt; <span class="hljs-number">35</span>:<br>fmt.Println(<span class="hljs-string">&quot;好好工作吧&quot;</span>)<br><span class="hljs-keyword">case</span> age &gt; <span class="hljs-number">60</span>:<br>fmt.Println(<span class="hljs-string">&quot;好好享受吧&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;活着真好&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>fallthrough</code>语法可以执行满足条件的case的下一个case，是为了兼容C语言中的case设计的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">switchDemo5</span><span class="hljs-params">()</span></span> &#123;<br>s := <span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> s == <span class="hljs-string">&quot;a&quot;</span>:<br>fmt.Println(<span class="hljs-string">&quot;a&quot;</span>)<br><span class="hljs-keyword">fallthrough</span><br><span class="hljs-keyword">case</span> s == <span class="hljs-string">&quot;b&quot;</span>:<br>fmt.Println(<span class="hljs-string">&quot;b&quot;</span>)<br><span class="hljs-keyword">case</span> s == <span class="hljs-string">&quot;c&quot;</span>:<br>fmt.Println(<span class="hljs-string">&quot;c&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;...&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>break跳出循环的时候，只能跳出一层循环</p><p>break语句和continue语句可以添加代码块使用</p></blockquote><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组的声明"><a href="#数组的声明" class="headerlink" title="数组的声明"></a>数组的声明</h3><ul><li>数组的长度一旦定义，就不能改变，在go语言中，数组的长度也是数组类型的一部分</li><li>定义数组时，可以使用三个点来推测数组长度，例如：<code>var a=[...]&#123;1,2,3&#125;</code></li><li>数组声明时可以根据索引来声明，例如：<code>var a=[...]&#123;1:2,2:3,3:4&#125;</code>，数组的值为<code>[0,2,3,4]</code></li></ul><h3 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h3><ul><li>for 循环比那里</li><li>for range遍历</li></ul><blockquote><p>数组是值类型，赋值和传参会复制整个数组，改变副本的值，不会改变本身的值。</p></blockquote><h2 id="切片-Slice"><a href="#切片-Slice" class="headerlink" title="切片 Slice"></a>切片 Slice</h2><p>切片的本质是数组，它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。</p><p>切片初始化以后，就不为空了，切片有自己的长度和容量，可以使用<code>len(a)</code>获取切片的长度，使用<code>cap(a)</code>获取切片的容量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a = []<span class="hljs-type">int</span>&#123;&#125;<br><span class="hljs-keyword">var</span> b []<span class="hljs-type">int</span><br>fmt.Println(a == <span class="hljs-literal">nil</span>) <span class="hljs-comment">//false</span><br>fmt.Println(b == <span class="hljs-literal">nil</span>) <span class="hljs-comment">//true</span><br>fmt.Println(<span class="hljs-built_in">len</span>(a)) <span class="hljs-comment">//0</span><br>fmt.Println(<span class="hljs-built_in">len</span>(b)) <span class="hljs-comment">//0</span><br></code></pre></td></tr></table></figure><h3 id="切片表达式"><a href="#切片表达式" class="headerlink" title="切片表达式"></a>切片表达式</h3><ul><li>从数组中获取切片<ul><li>范围：左闭右开</li><li>长度：high-low</li><li>容量：等于从low开始底层数组的容量</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">a := [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>s := a[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]<br>fmt.Println(s) <span class="hljs-comment">//[2,3]</span><br>fmt.Println(<span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s)) <span class="hljs-comment">//2,4</span><br></code></pre></td></tr></table></figure><ul><li>切片可以再次切片，再次执行切片时范围是容量，不是长度</li><li>完整的切片表达式<ul><li><code>a[low:high:max]</code></li><li>长度：high-low</li><li>容量：max-low</li></ul></li></ul><h3 id="使用make函数构造切片"><a href="#使用make函数构造切片" class="headerlink" title="使用make函数构造切片"></a>使用make函数构造切片</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br>fmt.Println(s, <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s)) <span class="hljs-comment">//[0 0 0] 3 5</span><br></code></pre></td></tr></table></figure><h3 id="切片的本质"><a href="#切片的本质" class="headerlink" title="切片的本质"></a>切片的本质</h3><p>切片的本质是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。</p><p>举个例子，现在有一个数组<code>a := [8]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125;</code>，切片<code>s1 := a[:5]</code>，相应示意图如下。<img src="https://www.liwenzhou.com/images/Go/slice/slice_01.png" alt="切片的本质">切片<code>s2 := a[3:6]</code>，相应示意图如下：<img src="https://www.liwenzhou.com/images/Go/slice/slice_02.png" alt="切片的本质"></p><blockquote><p>判断切片是否为空使用len(s)&#x3D;&#x3D;0，不可以使用s&#x3D;&#x3D;nil</p></blockquote><ul><li>数组的长度也是数据类型的一部分</li><li>切片是由底层数组的指针，切片的长度，切片的容量三部分组成的</li><li>切片声明了之后一定要初始化才能使用</li></ul><h3 id="切片的比较"><a href="#切片的比较" class="headerlink" title="切片的比较"></a>切片的比较</h3><ul><li>切片之间是不能用&#x3D;&#x3D;来进行比较的，切片只能用来和nil比较</li></ul><h3 id="切片的赋值"><a href="#切片的赋值" class="headerlink" title="切片的赋值"></a>切片的赋值</h3><ul><li>赋值的两个切片共享的是同一个底层数组，其中一个数组值的变化会影响另一个数组</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">s1 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">//[0 0 0]</span><br>s2 := s1             <span class="hljs-comment">//将s1直接赋值给s2，s1和s2共用一个底层数组</span><br>s2[<span class="hljs-number">0</span>] = <span class="hljs-number">100</span><br>fmt.Println(s1) <span class="hljs-comment">//[100 0 0]</span><br>fmt.Println(s2) <span class="hljs-comment">//[100 0 0]</span><br></code></pre></td></tr></table></figure><h3 id="切片的遍历"><a href="#切片的遍历" class="headerlink" title="切片的遍历"></a>切片的遍历</h3><ul><li>for循环遍历</li><li>for range遍历</li></ul><h3 id="切片添加元素"><a href="#切片添加元素" class="headerlink" title="切片添加元素"></a>切片添加元素</h3><p>可以使用append()方法在切片后面添加元素，如果添加另一个切片的话需要在切片后面加…</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s []<span class="hljs-type">int</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">1</span>)        <span class="hljs-comment">// [1]</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)  <span class="hljs-comment">// [1 2 3 4]</span><br>s2 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;  <br>s = <span class="hljs-built_in">append</span>(s, s2...)    <span class="hljs-comment">// [1 2 3 4 5 6 7]</span><br></code></pre></td></tr></table></figure><p>每个切片会指向一个底层数组，这个数组的容量够用就添加新增元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。“扩容”操作往往发生在<code>append()</code>函数调用时，所以我们通常都需要用原变量接收append函数的返回值。</p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//append()添加元素和切片扩容</span><br><span class="hljs-keyword">var</span> numSlice []<span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>numSlice = <span class="hljs-built_in">append</span>(numSlice, i)<br>fmt.Printf(<span class="hljs-string">&quot;%v  len:%d  cap:%d  ptr:%p\n&quot;</span>, numSlice, <span class="hljs-built_in">len</span>(numSlice), <span class="hljs-built_in">cap</span>(numSlice), numSlice)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">[0] 1 1 0x140000ae000<br>[0 1] 2 2 0x140000ae020<br>[0 1 2] 3 4 0x140000b6000<br>[0 1 2 3] 4 4 0x140000b6000<br>[0 1 2 3 4] 5 8 0x140000b8000<br>[0 1 2 3 4 5] 6 8 0x140000b8000<br>[0 1 2 3 4 5 6] 7 8 0x140000b8000<br>[0 1 2 3 4 5 6 7] 8 8 0x140000b8000<br>[0 1 2 3 4 5 6 7 8] 9 16 0x140000ba000<br>[0 1 2 3 4 5 6 7 8 9] 10 16 0x140000ba000<br></code></pre></td></tr></table></figure><p>从上面的结果可以看出：</p><ol><li><code>append()</code>函数将元素追加到切片的最后并返回该切片。</li><li>切片numSlice的容量按照1，2，4，8，16这样的规则自动进行扩容，每次扩容后都是扩容前的2倍。</li></ol><h3 id="使用copy函数复制切片"><a href="#使用copy函数复制切片" class="headerlink" title="使用copy函数复制切片"></a>使用copy函数复制切片</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">a := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>b := a<br>fmt.Println(a) <span class="hljs-comment">//[1 2 3 4 5]</span><br>fmt.Println(b) <span class="hljs-comment">//[1 2 3 4 5]</span><br>b[<span class="hljs-number">0</span>] = <span class="hljs-number">1000</span><br>fmt.Println(a) <span class="hljs-comment">//[1000 2 3 4 5]</span><br>fmt.Println(b) <span class="hljs-comment">//[1000 2 3 4 5]</span><br></code></pre></td></tr></table></figure><p>由于切片是引用类型，所以a和b其实都指向了同一块内存地址。修改b的同时a的值也会发生变化。</p><p>Go语言内建的<code>copy()</code>函数可以迅速地将一个切片的数据复制到另外一个切片空间中，<code>copy()</code>函数的使用格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">copy(destSlice, srcSlice []T)<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li>srcSlice: 数据来源切片</li><li>destSlice: 目标切片</li></ul><h3 id="切片的删除"><a href="#切片的删除" class="headerlink" title="切片的删除"></a>切片的删除</h3><p>Go语言中并没有删除切片元素的专用方法，我们可以使用切片本身的特性来删除元素。 代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 从切片中删除元素</span><br>a := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">32</span>, <span class="hljs-number">33</span>, <span class="hljs-number">34</span>, <span class="hljs-number">35</span>, <span class="hljs-number">36</span>, <span class="hljs-number">37</span>&#125;<br><span class="hljs-comment">// 要删除索引为2的元素</span><br>a = <span class="hljs-built_in">append</span>(a[:<span class="hljs-number">2</span>], a[<span class="hljs-number">3</span>:]...)<br>fmt.Println(a) <span class="hljs-comment">//[30 31 33 34 35 36 37]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>总结一下就是：要从切片a中删除索引为<code>index</code>的元素，操作方法是<code>a = append(a[:index], a[index+1:]...)</code></p><h3 id="切片的排序"><a href="#切片的排序" class="headerlink" title="切片的排序"></a>切片的排序</h3><p>Go语言中不能给数组排序，只能给相对应的切片排序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a = [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>&#125;<br>sort.Ints(a[:])<br>fmt.Println(a)<br></code></pre></td></tr></table></figure><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><ul><li><p>map是一种无序的key-value结构，在Go语言中map是引用类型，需要初始化才能使用</p></li><li><p>map的默认值是nil，需要使用make()函数来分配内存，<code>make(map[string]int,8)</code></p></li><li><p>引用类型必须初始化之后才能被使用，不能直接使用</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//map的初始化</span><br>scoreMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>, <span class="hljs-number">8</span>)<br>scoreMap[<span class="hljs-string">&quot;张三&quot;</span>] = <span class="hljs-number">90</span><br>scoreMap[<span class="hljs-string">&quot;小明&quot;</span>] = <span class="hljs-number">100</span><br>fmt.Println(scoreMap)<br>fmt.Println(scoreMap[<span class="hljs-string">&quot;小明&quot;</span>])<br>fmt.Printf(<span class="hljs-string">&quot;type of a:%T\n&quot;</span>, scoreMap)<br><span class="hljs-comment">//map没有初始化，不能直接操作</span><br><span class="hljs-keyword">var</span> c <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span><br>c[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span> <span class="hljs-comment">//会报错</span><br>fmt.Println(c)<br></code></pre></td></tr></table></figure><h3 id="判断某个键是否存在"><a href="#判断某个键是否存在" class="headerlink" title="判断某个键是否存在"></a>判断某个键是否存在</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//判断某个键是否存在</span><br><span class="hljs-keyword">var</span> scoreMap = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>, <span class="hljs-number">8</span>)<br>scoreMap[<span class="hljs-string">&quot;沙河娜扎&quot;</span>] = <span class="hljs-number">100</span><br>scoreMap[<span class="hljs-string">&quot;沙河小王子&quot;</span>] = <span class="hljs-number">200</span><br>v, ok := scoreMap[<span class="hljs-string">&quot;沙河娜扎&quot;</span>]<br>fmt.Println(v, ok)<br></code></pre></td></tr></table></figure><h3 id="map的遍历"><a href="#map的遍历" class="headerlink" title="map的遍历"></a>map的遍历</h3><ul><li>使用for range循环来遍历key和value</li><li>也可以使用for range循环单独遍历key</li></ul><h3 id="删除map的某个键值对"><a href="#删除map的某个键值对" class="headerlink" title="删除map的某个键值对"></a>删除map的某个键值对</h3><ul><li>使用delete函数删除map的某个键值对</li></ul><h3 id="按照指定顺序遍历map"><a href="#按照指定顺序遍历map" class="headerlink" title="按照指定顺序遍历map"></a>按照指定顺序遍历map</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go">rand.Seed(time.Now().UnixNano()) <span class="hljs-comment">//初始化随机数种子</span><br><span class="hljs-keyword">var</span> scoreMap = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>, <span class="hljs-number">200</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>key := fmt.Sprintf(<span class="hljs-string">&quot;stu%02d&quot;</span>, i) <span class="hljs-comment">//生成stu开头的字符串</span><br>value := rand.Intn(<span class="hljs-number">100</span>)          <span class="hljs-comment">//生成0~99的随机整数</span><br>scoreMap[key] = value<br>&#125;<br><span class="hljs-comment">//取出map中的所有key存入切片keys</span><br><span class="hljs-keyword">var</span> keys = <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>, <span class="hljs-number">200</span>)<br><span class="hljs-keyword">for</span> key := <span class="hljs-keyword">range</span> scoreMap &#123;<br>keys = <span class="hljs-built_in">append</span>(keys, key)<br>&#125;<br><span class="hljs-comment">//对切片进行排序</span><br>sort.Strings(keys)<br><span class="hljs-comment">//按照排序后的key遍历map</span><br><span class="hljs-keyword">for</span> _, key := <span class="hljs-keyword">range</span> keys &#123;<br>fmt.Println(key, scoreMap[key])<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="元素为map类型的切片"><a href="#元素为map类型的切片" class="headerlink" title="元素为map类型的切片"></a>元素为map类型的切片</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> mapSlice = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>, <span class="hljs-number">3</span>)<br><span class="hljs-keyword">for</span> index, value := <span class="hljs-keyword">range</span> mapSlice &#123;<br>  fmt.Printf(<span class="hljs-string">&quot;index:%d value:%v\n&quot;</span>, index, value)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;after init&quot;</span>)<br><span class="hljs-comment">// 对切片中的map元素进行初始化</span><br>mapSlice[<span class="hljs-number">0</span>] = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>, <span class="hljs-number">10</span>)<br>mapSlice[<span class="hljs-number">0</span>][<span class="hljs-string">&quot;name&quot;</span>] = <span class="hljs-string">&quot;小王子&quot;</span><br>mapSlice[<span class="hljs-number">0</span>][<span class="hljs-string">&quot;password&quot;</span>] = <span class="hljs-string">&quot;123456&quot;</span><br>mapSlice[<span class="hljs-number">0</span>][<span class="hljs-string">&quot;address&quot;</span>] = <span class="hljs-string">&quot;沙河&quot;</span><br><span class="hljs-keyword">for</span> index, value := <span class="hljs-keyword">range</span> mapSlice &#123;<br>  fmt.Printf(<span class="hljs-string">&quot;index:%d value:%v\n&quot;</span>, index, value)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="值为切片类型的map"><a href="#值为切片类型的map" class="headerlink" title="值为切片类型的map"></a>值为切片类型的map</h3><p>下面a的代码演示了map中值为切片类型的操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> sliceMap = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]<span class="hljs-type">string</span>, <span class="hljs-number">3</span>)<br>fmt.Println(sliceMap)<br>fmt.Println(<span class="hljs-string">&quot;after init&quot;</span>)<br>key := <span class="hljs-string">&quot;中国&quot;</span><br>value, ok := sliceMap[key]<br><span class="hljs-keyword">if</span> !ok &#123;<br>value = <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)<br>&#125;<br>value = <span class="hljs-built_in">append</span>(value, <span class="hljs-string">&quot;北京&quot;</span>, <span class="hljs-string">&quot;上海&quot;</span>)<br>sliceMap[key] = value<br>fmt.Println(sliceMap)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="function"><a href="#function" class="headerlink" title="function"></a>function</h2><p>函数是组织好的、可重复使用的、用于执行指定任务的代码块。</p><h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p>可变参数是指函数的参数数量不固定。Go语言中的可变参数通过在参数名后加<code>...</code>来标识。</p><p>注意：可变参数通常要作为函数的最后一个参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">intSum2</span><span class="hljs-params">(x ...<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>fmt.Println(x) <span class="hljs-comment">//x是一个切片</span><br>sum := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> x &#123;<br>sum = sum + v<br>&#125;<br><span class="hljs-keyword">return</span> sum<br>&#125;<br></code></pre></td></tr></table></figure><p>固定参数搭配可变参数使用时，可变参数要放在固定参数的后面。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">intSum3</span><span class="hljs-params">(x <span class="hljs-type">int</span>, y ...<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>fmt.Println(x, y)<br>sum := x<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> y &#123;<br>sum = sum + v<br>&#125;<br><span class="hljs-keyword">return</span> sum<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h4><p>Go语言中函数支持多返回值，函数如果有多个返回值时必须用<code>()</code>将所有返回值包裹起来。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calc</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) &#123;<br>sum := x + y<br>sub := x - y<br><span class="hljs-keyword">return</span> sum, sub<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="返回值命名"><a href="#返回值命名" class="headerlink" title="返回值命名"></a>返回值命名</h4><p>函数定义时可以给返回值命名，并在函数体中直接使用这些变量，最后通过<code>return</code>关键字返回。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calc</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> (sum, sub <span class="hljs-type">int</span>) &#123;<br>sum = x + y<br>sub = x - y<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><ul><li>全局变量是定义在函数外部的变量，它在程序整个运行周期内都有效。 在函数中可以访问到全局变量。</li><li>局部变量又分为两种： 函数内定义的变量无法在该函数外使用</li></ul><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><h4 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> x + y<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calc</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>, op <span class="hljs-keyword">func</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> op(x, y)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ret2 := calc(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, add)<br>fmt.Println(ret2) <span class="hljs-comment">//30</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h4><p>函数也可以作为返回值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">do</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">switch</span> s &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:<br><span class="hljs-keyword">return</span> add, <span class="hljs-literal">nil</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:<br><span class="hljs-keyword">return</span> sub, <span class="hljs-literal">nil</span><br><span class="hljs-keyword">default</span>:<br>err := errors.New(<span class="hljs-string">&quot;无法识别的操作符&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="匿名函数和闭包"><a href="#匿名函数和闭包" class="headerlink" title="匿名函数和闭包"></a>匿名函数和闭包</h2><p>匿名函数就是没有函数名的函数，匿名函数因为没有函数名，所以没办法像普通函数那样调用，所以匿名函数需要保存到某个变量或者作为立即执行函数:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 将匿名函数保存到变量</span><br>add := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> &#123;<br>fmt.Println(x + y)<br>&#125;<br>add(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>) <span class="hljs-comment">// 通过变量调用匿名函数</span><br><br><span class="hljs-comment">//自执行函数：匿名函数定义完加()直接执行</span><br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> &#123;<br>fmt.Println(x + y)<br>&#125;(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>匿名函数多用于实现回调函数和闭包。</p></blockquote><p>闭包指的是一个函数和与其相关的引用环境组合而成的实体。简单来说，<code>闭包=函数+引用环境</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">adder</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> x <span class="hljs-type">int</span><br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>x += y<br><span class="hljs-keyword">return</span> x<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> f = adder()<br>fmt.Println(f(<span class="hljs-number">10</span>)) <span class="hljs-comment">//10</span><br>fmt.Println(f(<span class="hljs-number">20</span>)) <span class="hljs-comment">//30</span><br>fmt.Println(f(<span class="hljs-number">30</span>)) <span class="hljs-comment">//60</span><br><br>f1 := adder()<br>fmt.Println(f1(<span class="hljs-number">40</span>)) <span class="hljs-comment">//40</span><br>fmt.Println(f1(<span class="hljs-number">50</span>)) <span class="hljs-comment">//90</span><br>&#125;<br></code></pre></td></tr></table></figure><p>变量<code>f</code>是一个函数并且它引用了其外部作用域中的<code>x</code>变量，此时<code>f</code>就是一个闭包。 在<code>f</code>的生命周期内，变量<code>x</code>也一直有效。 闭包进阶示例1：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">adder2</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>x += y<br><span class="hljs-keyword">return</span> x<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> f = adder2(<span class="hljs-number">10</span>)<br>fmt.Println(f(<span class="hljs-number">10</span>)) <span class="hljs-comment">//20</span><br>fmt.Println(f(<span class="hljs-number">20</span>)) <span class="hljs-comment">//40</span><br>fmt.Println(f(<span class="hljs-number">30</span>)) <span class="hljs-comment">//70</span><br><br>f1 := adder2(<span class="hljs-number">20</span>)<br>fmt.Println(f1(<span class="hljs-number">40</span>)) <span class="hljs-comment">//60</span><br>fmt.Println(f1(<span class="hljs-number">50</span>)) <span class="hljs-comment">//110</span><br>&#125;<br></code></pre></td></tr></table></figure><p>闭包进阶示例2：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeSuffixFunc</span><span class="hljs-params">(suffix <span class="hljs-type">string</span>)</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(name <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">if</span> !strings.HasSuffix(name, suffix) &#123;<br><span class="hljs-keyword">return</span> name + suffix<br>&#125;<br><span class="hljs-keyword">return</span> name<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>jpgFunc := makeSuffixFunc(<span class="hljs-string">&quot;.jpg&quot;</span>)<br>txtFunc := makeSuffixFunc(<span class="hljs-string">&quot;.txt&quot;</span>)<br>fmt.Println(jpgFunc(<span class="hljs-string">&quot;test&quot;</span>)) <span class="hljs-comment">//test.jpg</span><br>fmt.Println(txtFunc(<span class="hljs-string">&quot;test&quot;</span>)) <span class="hljs-comment">//test.txt</span><br>&#125;<br></code></pre></td></tr></table></figure><p>闭包进阶示例3：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calc</span><span class="hljs-params">(base <span class="hljs-type">int</span>)</span></span> (<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>) &#123;<br>add := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>base += i<br><span class="hljs-keyword">return</span> base<br>&#125;<br><br>sub := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>base -= i<br><span class="hljs-keyword">return</span> base<br>&#125;<br><span class="hljs-keyword">return</span> add, sub<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>f1, f2 := calc(<span class="hljs-number">10</span>)<br>fmt.Println(f1(<span class="hljs-number">1</span>), f2(<span class="hljs-number">2</span>)) <span class="hljs-comment">//11 9</span><br>fmt.Println(f1(<span class="hljs-number">3</span>), f2(<span class="hljs-number">4</span>)) <span class="hljs-comment">//12 8</span><br>fmt.Println(f1(<span class="hljs-number">5</span>), f2(<span class="hljs-number">6</span>)) <span class="hljs-comment">//13 7</span><br>&#125;<br></code></pre></td></tr></table></figure><p>闭包其实并不复杂，只要牢记<code>闭包=函数+引用环境</code>。</p><h3 id="defer语句"><a href="#defer语句" class="headerlink" title="defer语句"></a>defer语句</h3><p>Go语言中的<code>defer</code>语句会将其后面跟随的语句进行延迟处理。在<code>defer</code>归属的函数即将返回时，将延迟处理的语句按<code>defer</code>定义的逆序进行执行，也就是说，先被<code>defer</code>的语句最后被执行，最后被<code>defer</code>的语句，最先被执行。</p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;start&quot;</span>)<br><span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-number">3</span>)<br>fmt.Println(<span class="hljs-string">&quot;end&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">start<br>end<br><span class="hljs-number">3</span><br><span class="hljs-number">2</span><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><blockquote><p>由于<code>defer</code>语句延迟调用的特性，所以<code>defer</code>语句能非常方便的处理资源释放问题。比如：资源清理、文件关闭、解锁及记录时间等。</p></blockquote><h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
